#!/usr/bin/perl

#use strict;

my($VERSION)='3.97';

=head1 NAME

alti+server - Altitude server designed to support extended game types

=cut

my($INSTALL_ROOT)=$ENV{'ALTITUDE_ROOT'} || "$ENV{'HOME'}/altitude";

#$MAPDIR moved to 'mapDir' in OPTIONS just below.  Now, you can use
#"/server set mapDir ..." to have this option persist across upgrades!
#Set mapDir the first time you upgrade to this version, then it will be stored
#in your json stash, you won't ever have to set it here again.

my(%OPTIONS)=(
	mapDir		=> '',			#Directory under $INSTALL_ROOT/maps
								#to store maps. (e.g. "download")
	raceData		=> undef,			#Defaults to $INSTALL_ROOT/servers
	lobby		=> '',			#Lobby map for this server
	secretCode	=> undef,			#The secret required to join the server
	updateMapList	=> 1,               #Let alti+server change the mapList
	assignRank	=> 0,			#Use the ranking engine to assign teams
	enableTalk	=> 0,			#Enable server aided direct player chat
	changePlane	=> 1,			#Number of players to disable /cp
	hitchThreshold	=> 0.6,			#Length of serverHitch to report
	restartMapTime	=> 25,			#restart map if downloads succeed in 25s
	restartMapTypes=> 'coop,race',	#restart map only on these game types
	timeIdleChange	=> 7200,			#changeMap when server is idle for 2hrs
	cpuUsedChange	=> 300,			#changeMap idle servers at 5min CPU used
	allowUploads	=> 1,			#Allow superAdmins to upload maps
	ulSizeLimit	=> 10485760,        #Max allowed download size
	altBouncer	=> 0,			#Upload users to AltBouncer, 0=no/1=yes
	boxColor		=> 'blue',          #Curses color palet:
	chatFromColor	=> 'cyan',          # black, blue, cyan, green,
	chatToColor	=> 'yellow',        # magenta, red, white, yellow
	uiPrettyBoxes	=> 0,               #0='|','-'; 1=ACS/Unicode prettiness
	db_type		=> 'SQLite',		#Or 'Pg' for postgres
	db_name		=> 'sqlite.db',	#Or 'hostname' for postgres
	db_user		=> '',			#Actual username for postgres
	db_pass		=> '',			#Run through "utils::get_value"
	noviceLevel	=> undef,           #Level for Ace 0 to play
	aceLevel		=> undef,           #Level for Ace 1-10 to play
	snarkChance	=> 16,              #per player 1 in snarkChance, 0 disables
	bullyKick		=> 1,               #Kick repeated aggressive language
	infractions	=> 10,			#10 infractions gets players kicked
	debug		=> 0,			#Debug is on(1) or off(0)
	awards		=> 1,			#Give out awards at the end of a round
	javaHome		=> '',			#Change JAVA_HOME to point to your JDK
	xxEnabled		=> 1,			#Enable xx server patch if available
	recordsTypes	=> 'coop,race,ruin',#Which map types to keep records on
	saveLogTypes	=> 'coop',		#Save the logs for these game types
	saveLogAlways  => undef,			#Always save logs, regardless of record
	saveLogRecord	=> 5,			#Restrict save logs to top 5 placements
	rotationRE	=> 'tbd|ball|tdm',  #Which maps go into rotation
	configSize	=> 'normal',		#How helpful are extended commands:
								# normal: all commands and help
								# small: all commands, but no help
								# tiny: only required, admin merged
	superAdmin	=> 'admin',		#Super Admin command access:
	                                   # admin: all admins are super admins
								# console: cmds typed at console only
								# list: vaporId from @superAdmins array:
	admins		=> join(';',
			'00000000-0000-0000-0000-000000000000',
		),
	superAdmins	=> join(';',
			'00000000-0000-0000-0000-000000000000',
		),
	moderators	=> join(';',
			'00000000-0000-0000-0000-000000000000',
		),
	motd			=> join(';', 
			'See https://github.com/biell/alti-server for server manual',
		),
	updateServer	=> 'vapor.nimblygames.com',	#Nimbly update server
);

my(@MODES)=qw(1bd 1de 1dm ball ffa tbd tdm);
my(@TYPES)=qw(coop flag mdg race ruin zone 1lh);

my($ROLL_LOGS)=4 * 2**20;
my($RADIANS)=3.1415926535/180;

=head1 DESCRIPTION

The B<alti+server> server script is a perl wrapper around the Altitude
game server engine.  Altitude provides facilities for server hosting
integration for providing custom features and extensions.  

B<alti+server> has one major limitation which is integral to it's design,
and so will not be fixed.  It is designed to run only one server at a time.
An Altitude game server is capable of running multiple engines simultaneously
with a single set of log and command files.  This allows for a more efficient
use of resources, as one java process can run each engine.  If you try to
run multiple simultaneous game engines, B<alti+server> will fail
misserably, don't bother trying.

Beyond adding extra commands for users and map makers, B<alti+server> also
makes management of the server easier.  For example, console errors are
caught, and result in a server restart, allowing the server to maintain a
higher uptime.  Also, B<alti+server> creates a multi-paned curses interface
which allows management of the server to be easier.

=cut

use POSIX;
use IO::Handle;
use IPC::Open3;
use List::Util;
use Tie::RefHash;
use Data::Dumper;
use MIME::Base64;
use Types::Serialiser;

my($FATAL_SERVER_ERRORS)=join('|',
	'Server config size \(\d+ bytes\) exceeds max allowed size',
	'A fatal error has been detected by the Java Runtime Environment',
	'java.io.IOException: Oversized packet (\d+ bytes) to IP',
	'No suitable Java Virtual Machine could be found',
	'no available nuons!',
	'ERROR : serverLoop disrupted',
);

my(%CURL_RV)=(
	6	=> 'Could not resolve host',
	7	=> 'Failed to connect to host',
	28	=> 'Operation timeout',
	35	=> 'SSL Error',
	47	=> 'Too many redirects',
	53	=> 'No SSL support on localhost',
	63	=> 'File size limit exceeded',
	67	=> 'Authentication Failure',
);

my(%HOOKS, %CONSOLE, %ALTIPLUS);

if(exists($ENV{'INSTALL4J_ADD_VM_PARAMS'})) {
	unless($ENV{'INSTALL4J_ADD_VM_PARAMS'}=~m/-verbose:gc/) {
		$ENV{'INSTALL4J_ADD_VM_PARAMS'}.=' -verbose:gc';
	}
} else {
	$ENV{'INSTALL4J_ADD_VM_PARAMS'}='-verbose:gc';
}

if(exists($ENV{'INSTALL4J_JAVA_HOME_OVERRIDE'})) {
	$OPTIONS{'javaHome'}=$ENV{'INSTALL4J_JAVA_HOME_OVERRIDE'};
}

=pod

In addition to all it's other features, B<alti+server> can package up
the logs from games for later review.  This is helpful for tournaments or
any game where resolving complaints is a possibility.

=cut

{	package log;

	my($Logdir)="$INSTALL_ROOT/servers/log";
	my($Enabled)=0;
	my($Record)=undef;
	my($Override)=undef;
	my(@Stdout, @Chat, @Log, @Command, @Note, @Player);
	my($Map, $Date);

	sub start {
		my($map, $mode, $type)=@_;
		my($debug)=config::option('debug');
		my($save_log)=config::option('saveLogTypes');
		local($_);

		$Enabled=$debug;

		foreach(split(m/[,\s|]+/, $save_log)) {
			if(m/^($mode|$type|all)$/i) {
				$Enabled=1;
				last;
			}
		}

		$Record=undef;
		$Map=$map;
		$Date=POSIX::strftime("%Y%m%dT%H%M", gmtime(time));
		@Stdout=();
		@Chat=();
		@Log=();
		@Command=();
		@Note=();
		@Player=();
	}

	sub finish {
		my($limit)=config::option('saveLogRecord');
		my($always)=config::option('saveLogAlways');
		my($out)=IO::Handle->new;
		local($_);

		return unless($Enabled);
		unless($always) {
			return unless($Record);
			return if($Record>$limit);
		}

		mkdir("$Logdir") unless(-d "$Logdir");
		mkdir("$Logdir/$Map") unless(-d "$Logdir/$Map");
		mkdir("$Logdir/$Map/$Date") unless(-d "$Logdir/$Map/$Date");
		
		open($out, '>', "$Logdir/$Map/$Date/stdout.txt");
		for(@Stdout) {
			print $out $_, "\n";
		}
		close($out);

		open($out, '>', "$Logdir/$Map/$Date/chat.txt");
		for(@Chat) {
			print $out $_, "\n";
		}
		close($out);

		open($out, '>', "$Logdir/$Map/$Date/log.txt");
		for(@Log) {
			print $out $_, "\n";
		}
		close($out);

		open($out, '>', "$Logdir/$Map/$Date/command.txt");
		for(@Command) {
			print $out $_, "\n";
		}
		close($out);

		open($out, '>', "$Logdir/$Map/$Date/note.txt");
		for(@Note) {
			print $out $_, "\n";
		}
		close($out);

		open($out, '>', "$Logdir/$Map/$Date/player.txt");
		print $out Data::Dumper::Dumper([@Player]);
		close($out);

		$Date=POSIX::strftime("%Y%m%dT%H%M", gmtime(time));
		@Stdout=();
		@Chat=();
		@Log=();
		@Command=();
		@Note=();
		@Player=();
	}

	sub record {
		($Record)=@_;
	}

	sub stdout {
		return unless($Enabled);
		push(@Stdout, join(' ',
			POSIX::strftime('%H:%M:%S', gmtime(time)), @_));
	}

	sub chat {
		return unless($Enabled);
		push(@Chat, join(' ', @_));
	}

	sub log {
		return unless($Enabled);
		push(@Log, join(' ',
			POSIX::strftime('%H:%M:%S', gmtime(time)), @_));
	}

	sub command {
		return unless($Enabled);
		push(@Command, join(' ',
			POSIX::strftime('%H:%M:%S', gmtime(time)), @_));
	}

	sub note {
		return unless($Enabled);
		push(@Note, join(' ',
			POSIX::strftime('%H:%M:%S', gmtime(time)), @_));
	}

	sub player {
		return unless($Enabled);
		push(@Player, @_);
	}
}

=head2 Interface

There are three panes to the B<alti+server> interface:

=over 8

=item top

The top pane contains output from the Altitude server engine and additional
logs from B<alti+server> itself.  This data should scroll in such a way
that the scroll-back buffer on your terminal emulator.  Interestingly,
xterm and urxvt tend to hold only this buffer in their scrollback, whereas
screen tends to hold scrolled data from the middle pane also.  This pane
is used to keep track of what is going on with the server.

=item middle

The middle pane is a boxed window.  Inside of it are all chat and
serverMessage entries on the game.  Messages start with the originating user,
then a code for the destination, then the message itself.  The codes are as
such: (*) all user chat, (<) left team chat, (>) right team chat,
(?) spectator team chat, and the nickname of the receipient for direct
communication.

=item bottom

The bottom pane is a small one line box.  It works much the same as the
in-game all-chat box.  Text typed into it will appear as a server message
to players.  If the text starts with a slash (/) character, then it is
assumed to be a server command.  Server commands have a limited tab
completion.

=back

If your terminal supports color, colors will be used to make certain aspects
stand out or fade away.  Specifically, the boxes around windows are dark
blue, Nicks (in chat window) are cyan, and destination specifier (in chat
window) is dark yellow/amber.

=cut

delete($ENV{'LINES'});
delete($ENV{'COLUMNS'});

{	package ui;

	use Curses;
	use Term::ReadKey;

	initscr();

	my($Outfile)	="$INSTALL_ROOT/servers/stdout.txt";
	my($Outfile_o)	="$INSTALL_ROOT/servers/stdout_old.txt";
	my($Chatfile)	="$INSTALL_ROOT/servers/chat.txt";
	my($Chatfile_o)="$INSTALL_ROOT/servers/chat_old.txt";

	our($Cols, $Rows, $Px, $Py)=GetTerminalSize;
	my($Sline, $Iline)=($Rows/2-1, $Rows-3);
	my($Iputw)=$Cols-6;

	my($Sscroll, $Cscroll)=(200, 200);

	my($Swin)=newpad($Sscroll, $Cols);
	my($Cwin)=newwin($Sline-1, $Cols-2, $Sline,   1 );
	my($Iwin)=newwin(3,        $Cols-4, $Iline,   2 );
	my($Iput)=newwin(1,        $Iputw,  $Iline+1, 3 );
	my($Chat)=newpad($Cscroll, $Cols-4);

	my($Redirect)=undef;

	sub redirect {
		$Redirect=$_[0];

		($Swin, $Cwin, $Iwin, $Chat, $Iput)=undef;	
	}

	sub adjust_win {
		my($win, $height, $width, $y, $x)=@_;

		$win->resize($height, $width);
		$win->move($y, $x);
		$win->redrawwin();
		$win->refresh();
	}

	sub adjust_pad {
		my($pad, $index, $height, $width, $y, $x)=@_;

		$pad->resize(200, $width);
		$pad->redrawwin();
		$pad->prefresh($index-$height,0, $y,$x, $y+$height-1,$x+$width-1);
		$pad->refresh();
	}

	sub refresh_chat {
		&adjust_pad($Chat, $Cscroll, $Sline-3, $Cols-4, $Sline+1, 2 );
	}

	sub refresh_swin {
		&adjust_pad($Swin, $Sscroll, $Sline,   $Cols,   0,        0 );
	}

	sub chat_scroll {
		local($_)=@_;

		if(m/next/i) {
			if($Cscroll>197) {
				$Cscroll=200;
			} else {
				$Cscroll+=2;
			}
		} elsif(m/prev/i) {
			if($Cscroll<$Sline-5) {
				$Cscroll=$Sline-3;
			} else {
				$Cscroll-=2;
			}
		} elsif(m/home/i) {
			$Cscroll=$Sline-3;
		} elsif(m/end/i) {
			$Cscroll=200;
		} elsif(m/(-?\d+)/) {
			$Cscroll+=$1;
		}

		&refresh_chat;
	}

	sub swin_scroll {
		local($_)=@_;

		if(m/next/i) {
			if($Sscroll>197) {
				$Sscroll=200;
			} else {
				$Sscroll+=2;
			}
		} elsif(m/prev/i) {
			if($Sscroll<$Sline-2) {
				$Sscroll=$Sline;
			} else {
				$Sscroll-=2;
			}
		} elsif(m/home/i) {
			$Sscroll=$Sline;
		} elsif(m/end/i) {
			$Sscroll=200;
		} elsif(m/(-?\d+)/) {
			$Sscroll+=$1;
		}

		&refresh_swin;
	}

	sub setup_screen {
		my($default)=-1;
		my($boxColor)='COLOR_'.uc(config::option('boxColor'));
		my($chatFromColor)='COLOR_'.uc(config::option('chatFromColor'));
		my($chatToColor)='COLOR_'.uc(config::option('chatToColor'));

		#Make sure size is right:
		($Cols, $Rows, $Px, $Py)=GetTerminalSize;
		($Sline, $Iline)=($Rows/2-1, $Rows-3);
		($Iputw)=$Cols-6;
		&refresh_swin;
		$Cwin->clear;
		&adjust_win($Cwin, $Sline-1, $Cols-2, $Sline,   1 );
		&adjust_win($Iwin, 3,        $Cols-4, $Iline,   2 );
		&refresh_chat;
		&adjust_win($Iput, 1,        $Iputw,  $Iline+1, 3 );

		start_color();
		use_default_colors();
		if(has_colors()) {
			init_pair(1, eval($boxColor),		$default);
			init_pair(2, eval($chatFromColor),	$default);
			init_pair(3, eval($chatToColor),	$default);
		} else {
			init_pair(1, $default, $default);
			init_pair(2, $default, $default);
			init_pair(3, $default, $default);
		}

		stdscr->clear();
		stdscr->refresh();

		$Swin->scrollok(1);
		$Chat->scrollok(1);

		&refresh_swin;
		$Cwin->redrawwin();
		&refresh_chat;
		$Iwin->redrawwin();
		$Iput->redrawwin();

		$Cwin->attron(COLOR_PAIR(1));
		$Iwin->attron(COLOR_PAIR(1));
		if(config::option('uiPrettyBoxes')) {
			$Cwin->box(0, 0);
			$Iwin->box(0, 0);
		} else {
			$Cwin->border('|', '|', '-', '-', ' ', ' ', ' ', ' ');
			$Iwin->border('|', '|', '-', '-', ' ', ' ', ' ', ' ');
		}
		$Cwin->attroff(COLOR_PAIR(1));
		$Iwin->attroff(COLOR_PAIR(1));

		$Swin->leaveok(1);
		$Cwin->leaveok(1);

		noecho();
		cbreak();
		keypad(1);

		&refresh_swin;
		$Cwin->refresh();
		&refresh_chat;
		$Iwin->refresh();
		$Iput->refresh();
	}

	sub slog {
		my($slog)=IO::Handle->new;
		my($entry)=join(' ', map({ (ref($_))?(json::encode($_)):($_) } @_));

		chomp($entry);

		return unless($entry);

		if($Redirect) {
			print $Redirect $entry, "\n";
		} else {
			rename($Outfile, $Outfile_o) if(-s $Outfile > $ROLL_LOGS);

			open($slog, '>>', $Outfile);
			print $slog $entry, "\n";
			close($slog);

			log::stdout($entry);

			$Swin->scrl(1);
			$Swin->addstr(199, 0, $entry);
			&refresh_swin;
			$Iput->refresh();
		}
	}

	sub save_log {
		my($save)=join('-',
			$Outfile, 
			POSIX::strftime("%Y%m%dT%H%M", gmtime(time))
		);
		rename($Outfile, $save);
	}

	sub display {
		my($pre, $type, $text)=@_;
		my($offset1)=length($pre)+1;
		my($offset2)=length($type)+$offset1+1;

		$Chat->scrl(1);
		if($pre) {
			$Chat->attron(COLOR_PAIR(2));
			$Chat->addstr(199, 0, $pre);
			$Chat->attroff(COLOR_PAIR(2));

			$Chat->attron(COLOR_PAIR(3));
			$Chat->addstr(199, $offset1, $type);
			$Chat->attroff(COLOR_PAIR(3));

			$Chat->addstr(199, $offset2, $text);
		} else {
			$Chat->addstr(199, 0, $text);
		}
		&refresh_chat;
		$Iput->refresh();
	}

	sub chat_log {
		my($type, $nick, $msg)=@_;
		my($clog)=IO::Handle->new;
		my($time)=POSIX::strftime("%Y%m%dT%H%M%S", localtime(time()));
		my($entry)=sprintf("[%s:%-16s:%s] %s", $time, $nick, $type, $msg);

		rename($Chatfile, $Chatfile_o) if(-s $Chatfile > $ROLL_LOGS);

		open($clog, '>>', $Chatfile);
		print $clog $entry, "\n";
		close($clog);

		log::chat($entry);

		if($Redirect) {
			print $Redirect $entry, "\n";
		} else {
			&display($nick, $type, $msg);
		}
	}

	sub update_input {
		my($msg, $cursor)=@_;

		if($cursor>=$Iputw) {
			$Iput->addstr(0, 0, sprintf("%-${Iputw}s", substr($msg, $cursor-$Iputw+1, $Iputw-1)));
			$Iput->move(0, $Iputw);
		} else {
			$Iput->addstr(0, 0, sprintf("%-${Iputw}s", substr($msg, 0, $Iputw)));
			$Iput->move(0, $cursor);
		}
		$Iput->refresh();
		$Iput->attroff(A_REVERSE());
	}

	sub flash {
		$Iput->attron(A_REVERSE());
	}

	sub shutdown {
		stdscr->move($Rows, $Cols);
		endwin;
		print "\n";
	}

	sub keypress {
		my($input)=getch();
		my($ord)=ord($input);
		my($meta);

		if($ord==033) {
			nodelay(1);
			while($meta=getch()) {
				last if(!$meta || $meta=~m/-1/);
				$input.=$meta;
			}
			nodelay(0);

			if($input=~m/\033\[7~/) {
				$input=KEY_HOME;
			} elsif($input=~m/\033\[8~/) {
				$input=KEY_END;
			} elsif($input=~m/\033O([q-y])/) {
				$input=sprintf('%d', ord($1)-112);
			}
		}
		
		if($input == KEY_RESIZE) {
			#&slog('resize');
			&setup_screen;
			return();
		} elsif($input eq "\014") {
			&setup_screen;
			return();
		} elsif($input == KEY_UP) {
			return('up');
		} elsif($input == KEY_DOWN) {
			return('down');
		} elsif($input == KEY_LEFT) {
			return('left');
		} elsif($input == KEY_RIGHT) {
			return('right');
		} elsif($input == KEY_PPAGE) {
			&chat_scroll('prev');
			return();
		} elsif($input == KEY_NPAGE) {
			&chat_scroll('next');
			return();
		} elsif($input == KEY_HOME) {
			&chat_scroll('home');
			return();
		} elsif($input == KEY_END) {
			&chat_scroll('end');
			return();
		} elsif($input == KEY_F(11)) {
			&swin_scroll('prev');
			return();
		} elsif($input == KEY_F(12)) {
			&swin_scroll('next');
			return();
		} elsif($input == KEY_F(9)) {
			&swin_scroll('home');
			return();
		} elsif($input == KEY_F(10)) {
			&swin_scroll('end');
			return();
		} elsif($input == KEY_BACKSPACE || $ord==127) {
			return('bs');
		} elsif($input == KEY_DC) {
			return('del');
		} elsif($input eq "\025") {
			return('clear');
		} elsif($input eq "\t") {
			return('tab');
		} elsif($input eq "\n") {
			&swin_scroll('end');
			&chat_scroll('end');
			return('enter');
		} else {
			return($input);
		}
	}
}

=head2 Input and Interaction

Standard keyboard input is availble in the bottom window of the B<alti+server>
interface.  Lines which start with a slash (/) character are assumed to be
commands, and are interpeted as such.  Commands allow for tab expansion.
Commands which require a map as an argument also allow for the expansion of
the map name.  Additionally, a history buffer of the last 50 commands is saved
for easy retrieval;  use the up and down arrow keys to access the history
list.

=cut

{	package input;

	my(@Hist)=();
	my(@Clist)=();

	my($Hindex)=-1;
	my($Eindex)=0;

	my($Input);
	my($Cursor)=0;

	sub hist_up {
		$Hindex++ if($Hindex<$#Hist);
		return($Hist[$Hindex]);
	}

	sub hist_down {
		if($Hindex>0) {
			$Hindex--;
			return($Hist[$Hindex]);
		} else {
			$Hindex=-1;
			return('');
		}
	}

	sub hist_push {
		my($line)=@_;
		unshift(@Hist, '/'.$line);
		pop(@Hist) if(@Hist>50);
		$Hindex=-1;
	}

	sub common_prefix {
		my($len, $prefix, $newtry);

		List::Util::reduce {
			$len=List::Util::min(length($a), length($b));
			$prefix=substr($a, 0, $len);
			$newtry=substr($b, 0, $len);

			while($prefix ne $newtry) {
				chop($prefix);
				chop($newtry);
			}

			return($prefix);
		} @_;
	}

	sub expand_clear {
		my($entry)=@Clist[0];
		@Clist=();
		return($entry);
	}

	sub expand_args {
		my(@cmd)=@_;
		my(@args)=config::arguments($cmd[0]);
		my($arg)=$#cmd-1;
		my($str)=pop(@cmd);
		my($prefix);

		return('/'.join(' ', @cmd, $str)) unless(@args);

		if(@Clist==1) {
			ui::flash;
			return('/'.join(' ', @cmd, &expand_clear));
		} elsif(@Clist) {
			$Eindex=($Eindex+1)%@Clist;
			return('/'.join(' ', @cmd, $Clist[$Eindex]));
		} else {
			$str=~s/^"//;
			if(ref($args[$arg]) eq 'ARRAY') {
				@Clist=grep(m|^\Q$str|i, @{$args[$arg]});
			} elsif($args[$arg] eq 'map') {
				@Clist=grep(m|^\Q$str|i, config::maps());
			} elsif($args[$arg] eq 'player') {
				@Clist=grep(m|^\Q$str|i, player::values('nickname'));
			} elsif($args[$arg] eq 'vaporId') {
				@Clist=grep(m|^\Q$str|i, player::values('vaporId'));
			} else {
				return('/'.join(' ', @cmd, $str).'  ');
			}

			$Eindex=0;
			$prefix=&common_prefix(@Clist);

			foreach(@Clist) {
				if(m/\s/) {
					s/^/"/;
					s/$/"/;
				}
			}

			if(!@Clist) {
				ui::flash();
				return('/'.join(' ', @cmd, $str));
			} elsif($str ne $prefix) {
				@Clist=();
				$prefix=~s/^/"/ if($prefix=~m/\s/);
				return('/'.join(' ', @cmd, $prefix));
			} else {
				ui::slog('Choices:', @Clist) if(@Clist>1);
				return('/'.join(' ', @cmd, $Clist[0]));
			}
		}
	}

	sub expand_command {
		my($str)=@_;
		my($prefix);

		if(@Clist==1) {
			ui::flash();
			return('/'.&expand_clear);
		} elsif(@Clist) {
			$Eindex=($Eindex+1)%@Clist;
			return('/'.$Clist[$Eindex]);
		} else {
			@Clist=config::commands($str);
			$Eindex=0;
			$prefix=&common_prefix(@Clist);

			if(!@Clist) {
				ui::flash();
				return('/'.$str);
			} elsif($str ne $prefix) {
				@Clist=();
				return('/'.$prefix);
			} else {
				ui::slog('Cmds:', @Clist) if(@Clist>1);
				return('/'.$Clist[0]);
			}
		}
	}

	sub insert_key {
		my($key)=@_;

		substr($Input, $Cursor, 0, $key);
		$Cursor+=length($key);
	}

	sub remove_key {
		my($length)=@_;
		my($max)=length($Input);

		if($Input) {
			if($Cursor<0) {
				$Cursor=0;
			} elsif($Cursor>$max) {
				$Cursor=$max;
			} else {
				substr($Input, $Cursor+$length, 1, '');
				$Cursor+=$length
			}
		}
	}

	sub overwrite_input {
		my($string)=@_;

		$Input=$string;
		$Cursor=length($Input);
	}

	sub stdin {
		my($key)=ui::keypress;
		my(@cmd);

		if($key eq 'up') {
			&overwrite_input(&hist_up);
		} elsif($key eq 'down') {
			&overwrite_input(&hist_down);
		} elsif($key eq 'left') {
			$Cursor-- if($Cursor>0);
		} elsif($key eq 'right') {
			$Cursor++ if($Cursor<length($Input));
		} elsif($key eq 'bs') {
			&remove_key(-1);
		} elsif($key eq 'del') {
			&remove_key(0);
		} elsif($key eq 'clear') {
			&overwrite_input('');
		} elsif($key eq 'tab') {
			if($Input=~s|^\s*/||) {
				@cmd=server::parse_cmd($Input);
				if(@cmd==1) {
					&overwrite_input(&expand_command(@cmd));
				} else {
					&overwrite_input(&expand_args(@cmd));
				}
			} else {
				&insert_key('  ');
			}
		} elsif($key eq ' ') {
			if($Input=~m|^\s*/(\S+)$|) {
				config::command_help(player::server(), $1);
			}
			&insert_key(' ');
		} elsif($key eq 'enter') {
			$Input=~s|^\s+||;

			if($Input=~s|^/||) {
				@cmd=server::parse_cmd($Input);

				&hist_push($Input);

				if(exists($CONSOLE{$cmd[0]})) {
					$CONSOLE{$cmd[0]}->(splice(@cmd, 1));
				} else {
					server::send(@cmd);
				}

				&overwrite_input('');
			} else {
				chat::all($Input);
				&overwrite_input('');
			}
		} elsif(!defined($key)) {
			'skip';
		} else {
			&insert_key($key);
		}

		&expand_clear if($key ne 'tab');

		ui::update_input($Input, $Cursor);
	}
}

=head2 Server Notes

B<alti+server> is designed to run on Linux, but may also run on other
UNIX like operating systems.  It is likely that it could be modified
to run on non UNIX like systems, if necessary.  A recent version of
L<perl(1)> should be used to ensure basic operation.

=cut

{	package utils;

	use Digest::SHA;

	my(@Path)=(
		split(m/:+/, $ENV{'PATH'}),
		qw(/usr/bin /bin /usr/sbin /sbin /usr/local/bin /opt/bin),
		"$ENV{'HOME'}/bin",
	);

	my($Ticks)=POSIX::sysconf(&POSIX::_SC_CLK_TCK);

	my($Geoip);
	my($Ping);

	sub which {
		my($prog, $feeling, $failing)=@_;
		my(%checked)=();
		my($bin);

		foreach my $dir (@Path) {
			next if($checked{$dir}++);

			$bin="$dir/$prog";
			if(-x $bin) {
				if($feeling) {
					ui::slog('Using', $bin, "($feeling)");
				} else {
					ui::slog('Using', $bin);
				}
				return($bin);
			}
		}

		if($failing) {
			ui::slog($prog, 'not found,', $failing);
		} else {
			ui::slog($prog, 'not found');
		}

		return(undef);
	}

	$Geoip=&which('geoiplookup', 'good', 'Country lookups not available');
	$Ping=&which('ping', 'good', 'Cannot check server availability');

	sub pluck(\@) {
		my($ary)=shift;
		return(splice(@$ary, int(rand(@$ary)), 1));
	}

	sub mid {
		my(@list)=sort {$a<=>$b} @_;
		return($list[int(@list/2)]);
	}

	sub minmax {
		my($pair);
		
		return(undef, undef) unless(@_);

		List::Util::reduce {
			$pair=(ref($a) eq 'ARRAY')?$a:[$a, $a];
			$pair->[0]=$b if($pair->[0]>$b);
			$pair->[1]=$b if($pair->[1]<$b);

			return($pair);
		} @_;

		return(@$pair);
	}

	sub uniq {
		my(%uniq)=();

		foreach my $elt (@_) {
			$uniq{$elt}=1;
		}

		return(sort(keys(%uniq)));
	}

	sub simplify {
		local($_)=@_;

		s/^[\s,;|]+//;
		s/[\s,;|]+$//;
		s/([\s,;|])+/$1/g;

		return($_);
	}

	sub levdist {
		my(@a1)=split(m//, $_[0]);
		my(@a2)=split(m//, $_[1]);
		my($l1, $l2)=(scalar(@a1), scalar(@a2));
		my(@matrix)=([]);
		my($i, $j);

		#Init
		for($i=0; $i<=$l1; $i++) {
			for($j=1; $j<=$l2; $j++) {
				$matrix[$i][$j]=0;
				$matrix[0][$j]=$j;
			}

			$matrix[$i][0]=$i;
		}

		#Compare
		for($i=1; $i<=$l1; $i++) {
			for($j=1; $j<=$l2; $j++) {
				$matrix[$i][$j]=List::Util::min(
					$matrix[$i-1][$j]+1,
					$matrix[$i][$j-1]+1,
					$matrix[$i-1][$j-1]+($a1[$i-1] ne $a2[$j-1])
				);
			}
		}

		return($matrix[$l1][$l2]);
	}

	sub like {
		my($a, $b)=@_;
		my($scale);
		local($_);

		return(undef) unless($a && $b);

		foreach($a, $b) {
			s/\(\)/o/g;
			s/\>\</x/g;
			s/\|_/l/g;
			s/\s+//g;
			tr/A-Z/a-z/;
			tr/01345689!\$\+\|/oieasgbgistl/;
		}

		$scale=List::Util::max(length($a), length($b));

		return($a=~m/\Q$b/ || $b=~m/\Q$a/ || &levdist($a, $b)/$scale<0.4);
	}

	sub invert {
		my($hash)=@_;
		my($inverted)={};

		if($hash) {
			foreach my $key (keys(%$hash)) {
				push(@{$inverted->{$hash->{$key}}}, $key);
			}
		}

		return($inverted);
	}

	sub geoip {
		my($ip)=@_;
		my($lookup)=IO::Handle->new;
		my($country)=undef;

		if($Geoip) {
			$ip=~s/:.*$//;

			open($lookup, '-|', $Geoip, $ip);
			while(<$lookup>) {
				$country=$1 if(m/,\s+(.*?)\s*$/);
			}
			close($lookup);
		}

		return($country);
	}

	sub ping {
		my($host)=@_;
		my($pid);

		return(1) unless($Ping);

		if($pid=fork()) {
			waitpid($pid, 0);
			if($?==0) {
				ui::slog('Ping of', $host, 'successful.');
				return(1);
			} else{
				ui::slog('Ping of', $host, 'FAILED.');
				return(undef);
			}
		} else {
			close(STDOUT);
			close(STDERR);
			exec($Ping, '-c', 2, $host);
		}
	}

	sub distance {
		my($x1, $y1, $x2, $y2)=@_;

		return(sqrt( ($x2-$x1)**2 + ($y2-$y1)**2 ));
	}

	sub direction {
		my($x, $y)=@_;

		return(int(atan2($y, $x)/$RADIANS));
	}

	sub angle {
		my($a)=@_;

		#Accept -90, 270, 'down', or 's' to signify straight down:
		if($a eq 'up' || $a eq 'n' || $a eq 'north') {
			$a=90;
		} elsif($a eq 'down' || $a eq 's' || $a eq 'south') {
			$a=-90;
		} elsif($a eq 'left' || $a eq 'w' || $a eq 'west') {
			$a=180;
		} elsif($a eq 'right' || $a eq 'e' || $a eq 'east') {
			$a=0;
		} elsif($a eq 'ne' || $a eq 'northeast') {
			$a=45;
		} elsif($a eq 'se' || $a eq 'southeast') {
			$a=-45;
		} elsif($a eq 'sw' || $a eq 'southwest') {
			$a=-135;
		} elsif($a eq 'nw' || $a eq 'northwest') {
			$a=135;
		} elsif($a<=-180) {
			$a=int($a + 360);
		} elsif($a>180) {
			$a=int($a - 360);
		} else {
			$a=int($a);
		}

		return($a);
	}

	sub course {
		my($x, $y, $a, $d)=@_;

		$a=&angle($a)*$RADIANS;
		
		return($x+$d*cos($a), $y+$d*sin($a));
	}


	sub transform {
		my($t, $x, $y)=@_;
		my($a)=$t->{'rotate'};

		$x+=$t->{'translate'}{'x'};
		$x*=$t->{'scale'};

		$y+=$t->{'translate'}{'y'};
		$y*=$t->{'scale'};

		if($t->{'flipX'} eq 'true') {
			if($a<0) {
				$a=-180-$a;
			} else {
				$a=180-$a;
			}
		}

		if($t->{'flipY'} eq 'true') {
			$a*=-1;
		}

		$a*=$RADIANS;

		return($x*cos($a)-$y*sin($a), $x*sin($a)+$y*cos($a));
	}

	sub uuid {
		my(@seed)=(POSIX::uname(), $$, time(), rand(2**63), rand(2**31));
		my($digest)=Digest::SHA::sha256_hex(@seed);
		my($x)='0'; #not a standard mechanism, mix of 4 and 5
		my($y)=sprintf('%x', 8+rand(4));
		
		$digest=~m/(.{8}).(.{4}).(.{3}).(.{3}).(.{16})/;

		return(join('-', $1, $2, $x.$3, $y.$4, $5));
	}

	sub is_vapor {
		local($_)=@_;
		m/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{16}$/;
	}

	sub is_int {
		local($_)=@_;
		m/^\d+$/;
	}

	sub proc_time {
		my($pid)=@_;
		my($stat)=IO::Handle->new;
		my($file)="/proc/$pid/stat";
		my($user, $sys)=(0, 0);
		my(@proc);

		if(-r $file) {
			open($stat, '<', $file);
			@proc=split(m/\s+/, $stat->getline);
			close($stat);

			$user=$proc[13]+$proc[15];
			$sys=$proc[14]+$proc[16];
		}

		return($user/$Ticks, $sys/$Ticks);
	}

	sub delta {
		return(time()-$_[0]);
	}

	sub date {
		my($time)=@_;
		my($delta)=&delta($time);

		if($time<=1) {
			return('never');
		} elsif($delta<60) {
			return('now');
		} elsif($delta<6000) {
			return(sprintf('%d minutes ago', $delta/60));
		} elsif($delta<108000) {
			return(sprintf('%.1f hours ago', $delta/3600));
		} else {
			return(POSIX::strftime("%Y-%m-%d", gmtime($time)));
		}
	}

	sub secs2mins {
		my($time)=@_;

		return(sprintf('%02d:%04.1f', $time/60, POSIX::fmod($time, 60)));
	}

	sub secs2hrs {
		my($time)=@_;
		my($hrs, $mins, $secs);

		$secs=$time%60;
		$mins=($time/60)%60;
		$hrs=$time/3600;

		return(sprintf('%02d:%02d:%02d', $hrs, $mins, $secs));
	}

	sub nth {
		my($n)=@_;

		if($n=~m/1[123]$/) {
			return($n.'th');
		} elsif($n=~m/1$/) {
			return($n.'st');
		} elsif($n=~m/2$/) {
			return($n.'nd');
		} elsif($n=~m/3$/) {
			return($n.'rd');
		} else {
			return($n.'th');
		}
	}

	sub get_value {
		my($string)=@_;
		my($read)=IO::Handle->new;
		my(@cmd);

		if($string=~s/^{B64}//) {
			$string=MIME::Base64::decode_base64($string);
		} elsif($string=~s/^{xor}//) {
			$string=MIME::Base64::decode_base64($string);
			$string=~s/(.)/$1^'_'/ge;
		}

		1 while($string=~s/\$\{?(\w+)\}?/$ENV{"$1"}/);

		if($string=~s/\s*\|\s*$//) {
			@cmd=$string=~m/(".*?"|'.*?'|\S+)/g;
			foreach(@cmd) {
				s/^["']//;
				s/["']$//;
			}

			open($read, '-|', @cmd);
			$string=$read->getline;
			close($read);
		} elsif($string=~m|^/|) {
			if(-r $string) {
				open($read, '<', $string);
				$string=$read->getline;
				close($read);
			} else {
				$string=undef;
			}
		}

		return($string);
	}

	sub powerup {
		local($_)=@_;

		s/bomb/Bomb/i;
		s/plant.*/Demolition Charge/i;
		s/.*charge/Demolition Charge/i;
		s/ball/Ball/i;
		s/health/Health/i;
		s/shield/Shield/i;
		s/wall/Wall/i;
		s/.*missile/Homing Missile/i;

		return($_);
	}

	sub is_powerup {
		local($_)=&powerup(@_);
		return(m/(Bomb|Demolition Charge|Ball|Health|Shield|Wall|Homing Missile)/);
	}

	sub plane {
		local($_)=@_;

		s/loop\w*/Loopy/i;
		s/[bd]ombe\w*/Bomber/i;
		s/whale/Explodet/i;
		s/expl\w*/Explodet/i;
		s/bip\w*/Biplane/i;
		s/\w*randa/Miranda/i;
		s/mir\w*/Miranda/i;

		return($_);
	}

	sub is_plane {
		local($_)=&plane(@_);
		return(m/(Loopy|Bomber|Explodet|Biplane|Miranda)/);
	}

	sub green {
		local($_)=@_;

		s/no green.*/No Green Perk/i;
		s/rubber.*/Rubberized Hull/i;
		s/^ha$/Heavy Armor/i;
		s/.*armor/Heavy Armor/i;
		s/repair.*/Repair Drone/i;
		s/flex.*/Flexible Wings/i;

		return($_);
	}

	sub is_green {
		local($_)=&green(@_);
		return(m/(Rubberized Hull|Heavy Armor|Repair Drone|Flexible Wings)/);
	}

	sub red {
		local($_)=@_;

		s/track.*/Tracker/i;
		s/^df$/Double Fire/i;
		s/double.*/Double Fire/i;
		s/acid.*/Acid Bomb/i;

		s/sup.*/Suppressor/i;
		s/.*[db]ombs/Bombs/i;
		s/flak.*/Flak Tailgun/i;

		s/direct.*/Director/i;
		s/thermo.*/Thermobarics/i;
		s/remote.*/Remote Mine/i;
		s/^rm.*/Remote Mine/i;

		s/dog.*/Dogfighter/i;
		s/recoil.*/Recoilless Gun/i;
		s/^hc$/Heavy Cannon/i;
		s/.*cannon/Heavy Cannon/i;

		s/trick.*/Trickster/i;
		s/laser/Laser/i;
		s/time.*/Time Anchor/i;
		s/.*anchor/Time Anchor/i;
		s/^ta$/Time Anchor/i;

		return($_);
	}

	sub is_red {
		local($_)=&red(@_);
		my($re)=join('|',
			'Tracker', 'Double Fire', 'Acid Bomb',
			'Suppressor', 'Bombs', 'Flak Tailgun',
			'Director', 'Thermobarics', 'Remote Mine',
			'Dogfighter', 'Recoilless Gun', 'Heavy Cannon',
			'Trickster', 'Laser', 'Time Anchor',
		);
		return(m/($re)/);
	}

	sub blue {
		local($_)=@_;

		s/no blue.*/No Blue Perk/i;
		s/turbo.*/Turbocharger/i;
		s/ultra.*/Ultracapacitor/i;
		s/rev.*/Reverse Thrust/i;
		s/ace.*/Ace Instincts/i;

		return($_);
	}

	sub is_blue {
		local($_)=&blue(@_);
		return(m/(Turbocharger|Ultracapacitor|Reverse Thrust|Ace Instincts)/);
	}

	sub skin {
		local($_)=@_;

		s/^no.*/No Skin/i;
		s/^shark.*/Shark Skin/i;
		s/^zebra.*/Zebra Skin/i;
		s/^checker.*/Checker Skin/i;
		s/^flame.*/Flame Skin/i;
		s/^santa.*/Santa Hat/i;

		return($_);
	}

	sub is_skin {
		local($_)=&skin(@_);
		return(m/(No Skin|Shark Skin|Zebra Skin|Checker Skin|Flame Skin|Santa Hat)/);
	}

	sub all_setups {
		my(@reds)=(
			'Loopy,Tracker', 'Loopy,Double Fire', 'Loopy,Acid Bomb',
			'Bomber,Suppressor', 'Bomber,Bombs', 'Bomber,Flak Tailgun',
			'Explodet,Director', 'Explodet,Thermobarics', 'Explodet,Remote Mine',
			'Biplane,Dogfighter', 'Biplane,Recoilless Gun', 'Biplane,Heavy Cannon',
			'Miranda,Trickster', 'Miranda,Laser', 'Miranda,Time Anchor',
		);
		my(@greens)=(
			'Rubberized Hull', 'Heavy Armor',
			'Repair Drone', 'Flexible Wings',
		);
		my(@blues)=(
			'Turbocharger', 'Ultracapacitor',
			'Reverse Thrust', 'Ace Instincts',
		);
		my(%setups)=();

		foreach my $red (@reds) {
			foreach my $green (@greens) {
				foreach my $blue (@blues) {
					$setups{join(',', $red, $green, $blue)}=1;
				}
			}
		}

		return(%setups);
	}

	sub coin_toss {
		return(int(rand(2)));
	}

}


=head2 Interchange Formats

B<alti+server> can talk both JSON and XML, but needs the libraries to
do so.  The only non-core libraries you should install for B<alti+server>
are C<JSON::XS> and C<XML::Simple>.  Newer versions of perl contain a
pure-perl C<JSON::PP>, and this will be used if C<JSON::XS> is not found.

=cut

{	package json;

	my($String)='';
	my($Json);

	if($Json=eval('use JSON::XS; JSON::XS->new()')) {
		ui::slog('using JSON::XS (good)');
	} elsif($Json=eval('use JSON::PP; JSON::PP->new()')) {
		ui::slog('using JSON::PP, consider installing JSON::XS (its faster)');
	} else {
		die('Could not find a JSON library, please install JSON::XS');
	}

	sub decode {
		local($SIG{'__DIE__'})=sub {
			ui::slog(@_);
			select(undef, undef, undef, 0.1);
			return(0);
		};
		my($ds)=undef;

		$String=join('', $String, @_);

		if($String=~m/^\s*{/ && $String=~m/}\s*$/) {
			$ds=eval { $Json->decode($String) };
			$String='';
		}

		return($ds);
	}

	sub encode {
		return($Json->encode(@_));

	}

	sub pretty {
		my($string);

		$Json->pretty(1);
		$string=$Json->encode(@_);
		$Json->pretty(0);

		return($string);
	}

	sub true {
		return(Types::Serialiser::true);
	}

	sub false {
		return(Types::Serialiser::false);
	}

	sub read_file {
		my($file)=@_;
		my($fh)=IO::Handle->new;
		my($data);

		if(-r $file) {
			open($fh, '<', $file);
			$data=join('', <$fh>);
			close($fh);
			return(&decode($data));
		} else {
			return({});
		}
	}

	sub write_file {
		my($ds, $file)=@_;
		my($fh)=IO::Handle->new;

		foreach my $key (keys(%$ds)) {
			if(ref($ds->{$key}) eq 'HASH') {
				delete($ds->{$key}) unless(keys(%{$ds->{$key}}));
			} elsif(ref($ds->{$key}) eq 'ARRAY') {
				delete($ds->{$key}) unless(@{$ds->{$key}});
			} elsif(ref($ds->{$key})) {
				delete($ds->{$key}) unless(defined(${$ds->{$key}}));
			} elsif(!defined($ds->{$key})) {
				delete($ds->{$key});
			}
		}

		rename($file, "$file.bak") if(-e $file);
		open($fh, '>', $file);
		print $fh json::pretty($ds);
		close($fh);
	}

}

{	package xml;

	use XML::Simple;

	sub decode {
		local($SIG{'__DIE__'})=sub {
			ui::slog(@_);
			select(undef, undef, undef, 0.1);
			return(0);
		};
		my($ds)=eval { XMLin(@_) };

		if($ds) {
			return($ds);
		} else {
			if(@_<2) {
				ui::slog('Failed to read XML from:', @_);
			} else {
				ui::slog('Failed to read XML from:', $_[0], json::encode($_[1]));
			}
			return(undef);
		}
	}

	sub encode {
		my($ds, @opts)=@_;
		my($header)='<?xml version="1.0" encoding="UTF-8"?>';

		unless(ref($ds)) {
			ui::slog('Invalid data structure sent to xml::encode');
			return('');
		}

		return(XMLout($ds, @opts, 'KeepRoot' => 1, 'XMLDecl' => $header));
	}

	sub valid {
		if(&decode(@_)) {
			return(1);
		} else {
			return(0);
		}
	}

}


=head2 State

B<alti+server> keeps state from one invocation to another.  It stores
user preferences for certain extensions, and map preferences.  These are
used to ensure games are playable as designed for different types of maps.
The format for this data is JSON.

This file is read from at startup, and written to when settings changes
are requested by administrative users.  When written to, the previous
version is stored as F<json_attic.txt>.  All settings changes to this
stash are automatically saved to disk.

=cut

{	package stash;

	use Storable;

	my($Stashfile)="$INSTALL_ROOT/servers/json_stash.txt";
	my($Stashattic)="$INSTALL_ROOT/servers/json_attic.txt";
	my($Stash)=undef;

	sub get {
		my($value);

		$Stash=json::read_file($Stashfile) unless($Stash);

		$value=$Stash;
		while(@_) {
			$value=$value->{pop(@_)};
		}

		return($value);
	}

	sub save {
		json::write_file($Stash, $Stashfile);
	}

	sub set {
		my($data)=pop(@_);
		my($next, $value);

		$Stash=json::read_file($Stashfile) unless($Stash);

		$value=$Stash;
		while(@_>1) {
			$next=pop(@_);
			$value->{$next}={} unless(exists($value->{$next}));
			$value=$value->{$next};
		}
		$next=pop(@_);


		if(ref($data)) {
			$value->{$next}=$data;
		} elsif($data=~m/^(\d+|\d+\.\d+)$/) {
			$value->{$next}=$data*1;
		} else {
			$value->{$next}=$data;
		}

		&save;

		return($data);
	}

	sub delete {
		my(@hist)=();
		my($next, $value);

		$Stash=json::read_file($Stashfile) unless($Stash);

		$value=$Stash;
		while(@_>1) {
			$next=pop(@_);

			push(@hist, [$value, $next]);
			$value=$value->{$next};
		}

		if(defined(delete($value->{$_[0]}))) {
			while(@hist) {
				($value, $next)=@{pop(@hist)};
				if(	ref($value) eq 'HASH'			&&
					ref($value->{$next}) eq 'HASH'	&&
					!%{$value->{$next}}
				) {
					delete($value->{$next});
				}
			}

			&save;
			return(1);
		} else {
			return(0);
		}
	}

	sub marry {
		my($sor, $def)=@_;

		if(ref($sor) ne 'HASH') {
			return;
		} elsif(ref($def) ne 'HASH') {
			$sor=$def;
			return;
		}

		foreach my $key (keys(%$def)) {
			if(!defined($sor->{$key})) {
				if(ref($def->{$key})) {
					$sor->{$key}=Storable::dclone($def->{$key});
				} else {
					$sor->{$key}=$def->{$key};
				}
			} elsif(ref($sor->{$key}) ne ref($def->{$key})) {
				if(ref($def->{$key})) {
					$sor->{$key}=Storable::dclone($def->{$key});
				} else {
					$sor->{$key}=$def->{$key};
				}
			} else {
				&marry($sor->{$key}, $def->{$key});
			}
		}
	}
	
	sub archive {
		my($attic)=json::read_file($Stashattic);
		my($value, $archive, $next);

		$Stash=json::read_file($Stashfile) unless($Stash);

		$value=$Stash;
		$archive=$attic;
		while(@_>1) {
			$next=pop(@_);

			$value=$value->{$next};

			$archive->{$next}={} unless(exists($archive->{$next}));
			$archive=$archive->{$next};
		}
		$next=pop(@_);

		$archive->{$next}=$value->{$next};
		delete($value->{$next});

		&save;
		json::write_file($attic, $Stashattic);
	}

	sub retrieve {
		my($attic)=json::read_file($Stashattic);
		my($value);

		$value=$attic;
		while(@_) {
			$value=$value->{pop(@_)};
		}

		return($value);
	}

	sub upgrade {
		my($changes)=0;
		my($tmp);

		$Stash=json::read_file($Stashfile) unless($Stash);

		if($OPTIONS{'mapDir'} && !$Stash->{'server'}{'mapDir'}) {
			$Stash->{'server'}{'mapDir'}=$OPTIONS{'mapDir'};
			$changes=1;
		}

		unless(exists($Stash->{'map'})) {
			$Stash->{'map'}={};
			$Stash->{'records'}={};

			foreach my $key (keys(%$Stash)) {
				next if($key=~m/^(server|command|player|map|records)$/);

				if(exists($Stash->{$key}{'records'})) {
					$Stash->{'records'}{$key}=$Stash->{$key}{'records'};
					delete($Stash->{$key}{'records'});
				}
				$Stash->{'map'}{$key}=$Stash->{$key};
				delete($Stash->{$key});

				$changes=1;
			}
		}

		foreach my $map (keys(%{$Stash->{'map'}})) {
			if(exists($Stash->{'map'}{$map}{'door'})) {	##Upgrade doors##
				foreach my $team (values(%{$Stash->{'map'}{$map}{'door'}})) {
					next if(exists($team->{'name'}));
		
					foreach my $key (keys(%{$team->{'keys'}})) {
						$team->{'name'}{$key}=$team->{'keys'}{$key};
						$changes=1;
					}
				}
			}

			if(exists($Stash->{'map'}{$map}{'zones'})) {	##Upgrade zones##
				foreach my $team (values(%{$Stash->{'map'}{$map}{'zones'}})) {
					next if(exists($team->{'name'}));
		
					foreach my $key (keys(%{$team->{'keys'}})) {
						$team->{'name'}{$key}=$team->{'keys'}{$key};
						$changes=1;
					}
				}
			}

			if(exists($Stash->{'map'}{$map}{'ballScore'})) {
				$Stash->{'map'}{$map}{'score'}=
					$Stash->{'map'}{$map}{'ballScore'};
				delete($Stash->{'map'}{$map}{'ballScore'});
			}
		}

		if(exists($Stash->{'xx'}{'global'})) {
			$Stash->{'xx'}={'mods' => $Stash->{'xx'}};
			$changes=1;
		}
		
		if($changes) {
			&save;
			ui::slog('Stash upgraded');
		}
	}

	sub fix_doors {
		my($map, $left, $right)=@_;
		my($changes)=0;

		return unless(exists($Stash->{$map}{'door'}));

		if(exists($Stash->{$map}{'door'}{'doors'})) {
			$Stash->{$map}{'door'}{$left}{'doors'}=$Stash->{$map}{'door'}{'doors'};
			$Stash->{$map}{'door'}{$right}{'doors'}=$Stash->{$map}{'door'}{'doors'};
			delete($Stash->{$map}{'door'}{'doors'});

			$changes=1;
		}
		if(exists($Stash->{$map}{'door'}{'keys'})) {
			$Stash->{$map}{'door'}{$left}{'keys'}=$Stash->{$map}{'door'}{'keys'};
			$Stash->{$map}{'door'}{$right}{'keys'}=$Stash->{$map}{'door'}{'keys'};
			delete($Stash->{$map}{'door'}{'keys'});

			$changes=1;
		}

		if($changes) {
			&save;
			ui::slog('Stash upgraded');
		}
	}

}

=head2 Alti+ overhead

The commands used to interract between users and the server must be supplied
to each new user when they join the server.  These commands are sent in the
same packet which contains the server map list.  This packet is of fixed
lenght, and as such the number of maps must shrink to accomdate the added
commands.  This, however, is more of an art than a science, as the data in
this packet is compressed.  Different choices in map names will compress
differently.  It does this by compressing data which will go in this packet
to see if it looks like it will be sufficient.

=cut

{	package compress;

	my($Compress)=	utils::which('lzma', 'good')	||
				utils::which('gzip', 'ok')	||
				utils::which('bzip2', 'ok');

	unless($Compress) {
		ui::slog('No Compress found (guessing), consider installing lzma (its more accurate)');
	}

	sub guess {
		my($input)=join('', @_);
		my(%tokens)=();
		my($total)=0;

		foreach my $tok (split(m/\W+/, $input)) {
			$tokens{$tok}++;
			$total++;
		}

		return(int(length(join('', keys(%tokens)))/2+$total*1.6));
	}

	sub deflate {
		my($in, $out, $err)=(IO::Handle->new, IO::Handle->new, IO::Handle->new);
		my($output)='';
		my($pid);
		
		#6 tends to be the default, and Altitude seems not to be that good:
		$pid=IPC::Open3::open3($in, $out, $err, $Compress, '-2', '-c');

		print $in @_;
		close($in);

		$output=join('', <$out>);
		close($out);
		close($err);
	
		waitpid($pid, 0);

		return($output);
	}

	sub size_data {
		if($Compress) {
			return(length(&deflate(@_)));
		} else {
			return(&guess(@_));
		}
	}

	sub size_file {
		my($file)=@_;
		my($fh)=IO::Handle->new;
		my(@input);

		open($fh, '<', $file);
		@input=<$fh>;
		close($fh);

		if($Compress) {
			return(length(&deflate(@input)));
		} else {
			return(&guess(@input));
		}
	}
}

=head2 Configuration

B<alti+server> gets it's configuration information from a
variety of places.  Configuration files (either altitude server specific
or B<alti+server> specific) are read in at startup, and used to gather
data for a variety of purposes.  This list of files is used to control
the behavior of B<alti+server>:

=over 8

=item custom_json_commands.txt

This file isn't actually read by B<alti+server>; however, each command
supported by B<altiude_mapqa> must be listed and defined in this file.
This is the file which tells the server process what commands are known
to B<alti+server>.

=item launcher_config.xml

This file contains the information used by the altitude C<server_launcher>
process when the server is initially started.  It contains information
used by B<alti+server> such as a Map list and a command list.  These
are used in the interactive interface to provide command-line completion
and for changing maps periodically.  What is especially nice is that admins
never have to edit the launcher_config.xml to add new maps.  When the
altitude server is restarted, the map directory is automatically searched
for maps; these are added to the F<launcher_config.xml> file for you.

=item filtered_swear_words.txt

A list of naughty words which are often used to harrass other players are
listed in this file.  Harrasment isn't cool!  So, when these words are used,
the server notifies the person who wrote them that a language infraction
has occured.  After too many infractions, the player is kicked by the server.

=back

=cut

{	package config;

	use FindBin qw($Bin $RealBin);

	my($Conffile)	="$INSTALL_ROOT/servers/launcher_config.xml";
	my($Custfile)	="$INSTALL_ROOT/servers/custom_json_commands.txt";
	my($Custfile_o)="$INSTALL_ROOT/servers/custom_json_commands_old.txt";
	my($Filtfile)	="$INSTALL_ROOT/config/filtered_swear_words.txt";

	my(%Admins)=();
	my(%Commands)=();
	my(@Maps)=();
	my(%Mapdb)=();
	my($Harrasment)='noo+b';
	my($Language);
	my($Reserve)=0;
	my($Maplimit)=undef;

	our($Port)=0;
	our($Ping)=500; #reset from launcher_config.xml
	our($Maxp)=14;  #reset from launcher_config.xml

	our(%Launcher)=(
		'goals' => 6,
	);

	our($Clock)=1000;  #Clock is in milliseconds

	our($Uuid)=stash::get('uuid', 'server');

	stash::set('uuid', 'server', $Uuid=utils::uuid) unless($Uuid);
	stash::set('uuid', 'server', $Uuid=utils::uuid) if($Uuid=~m/-0000-/);

	$OPTIONS{'mapDir'}=~s|/+$|| if($OPTIONS{'mapDir'});

	sub option_exists {
		return(exists($OPTIONS{$_[0]}));
	}

	sub option {
		my($key)=@_;
		my($value)=stash::get($key, 'server') // $OPTIONS{$key};

		if(ref($value)) {
			return($value);
		} elsif($value=~m/^(true|yes|t|y)$/i) {
			return(1);
		} elsif($value=~m/^(false|no|f|n)$/i) {
			return(0);
		} else {
			return($value);
		}
	}

	sub option_set {
		my($name, $value)=@_;

		stash::set($name, 'server', $value);
	}

	sub option_del {
		my($name)=@_;

		stash::delete($name, 'server');
	}

	sub _packet_length {
		my($size)=0;
		my($str);

		foreach my $arg (@_) {
			if(ref($arg)) {
				$str=json::encode($arg);
			} else {
				$str=$arg;
			}
			$str=~s/\W//g;
			$size+=length($str);
		}

		return($size);
	}

	sub custom_commands {
		return(sort(keys(%ALTIPLUS)));
	}

	sub custom_command {
		my($name)=@_;
		my($config_size)=&option('configSize');

		if(exists($ALTIPLUS{$name})) {
			if(	exists($ALTIPLUS{$name}{'restrict'}) &&
				$config_size=~m/$ALTIPLUS{$name}{'restrict'}/
			) {
				return(0);
			} else {
				return(
					stash::get($name, 'command')	//
					$ALTIPLUS{$name}{'enabled'}
				);
			}
		} else {
			return(undef);
		}
	}

	sub custom_command_set {
		my($name, $value)=@_;

		if(exists($ALTIPLUS{$name})) {
			stash::set($name, 'command', $value);
			return(1);
		} else {
			return(undef);
		}
	}

	sub custom_command_unset {
		my($name)=@_;

		if(exists($ALTIPLUS{$name})) {
			stash::delete($name, 'command');
			return(1);
		} else {
			return(undef);
		}
	}

	sub _write_custom_commands {
		my($cmd)=Storable::dclone($_[0]);
		my($fh)=IO::Handle->new;
		my($config_size)=&option('configSize');
		my($enabled)=stash::get($cmd->{'name'}, 'command')//$cmd->{'enabled'};
		my($json);

		unless(&option('allowUploads') && &option('superAdmin')!~m/console/) {
			return if($cmd->{'name'} eq 'upload');
			return if($cmd->{'name'} eq 'removeMap');
		}

		if(!$enabled) {
			return;
		} elsif($cmd->{'restrict'} && $config_size=~m/$cmd->{'restrict'}/) {
			return;
		} elsif(&option('configSize')=~m/tiny/i) {
			return if($cmd->{'voteThreshold'}==100 && $cmd->{'name'} ne '!');

			delete($cmd->{'argumentDescriptions'});
			foreach my $arg (@{$cmd->{'arguments'}}) {
				$arg='string' if(ref($arg));
			}
		} elsif(&option('configSize')=~m/small/i) {
			delete($cmd->{'argumentDescriptions'});
			foreach my $arg (@{$cmd->{'arguments'}}) {
				$arg='string' if(ref($arg));
			}
		} else {
			foreach my $arg (@{$cmd->{'arguments'}}) {
				$arg=[sort(@$arg)] if(ref($arg));
			}
		}

		delete($cmd->{'enabled'});
		delete($cmd->{'restrict'});

		$json=json::encode($cmd);
		open($fh, '>>', $Custfile);
		print $fh $json, "\n";
		close($fh);
	}

	sub write_launcher_config {
		my(%config)=@_;
		my($lconfig)=IO::Handle->new;
		my($maplist, $adminlist)=(0, 0);
		my($admins)=config::option('admins');
		my($rotation)=config::option('rotationRE');
		my($update_maps)=config::option('updateMapList');
		my($update_admins)=($admins=~m/[1-9a-f]/);
		my(@xml);

		open($lconfig, '<', $Conffile);
		@xml=<$lconfig>;
		close($lconfig);

		$config{'secretCode'}//=config::option('secretCode');

		$config{'minLevel'}//=List::Util::min(
						config::option('noviceLevel'),
						config::option('aceLevel'));

		foreach my $key (keys(%config)) {
			delete($config{$key}) unless(defined($config{$key}));
		}

		if(config::option('assignRank')) {
			$config{'autoBalanceTeams'}='false';
		}

		return unless($update_maps || $update_admins || %config);

		foreach(@xml) {
			if(m/<AltitudeServerConfig /) {
				foreach my $key (keys(%config)) {
					unless(s/\b$key=".*?"/$key="$config{$key}"/) {
						s/>/ $key="$config{$key}">/;
					}
				}
			}

			if($update_maps) {
				if(m{</mapList>}i) {
					foreach my $map (@Maps) {
						s{^}{        <String value="$map" />\r\n}s;
					}
					$maplist=0;
				}
				if(m{</mapRotationList>}i) {
					foreach my $map (grep(m/($rotation)/, @Maps)) {
						s{^}{        <String value="$map" />\r\n}s;
					}
					$maplist=0;
				}

				if($maplist) {
					$_=''
				}
	
				if(m{<mapList>|<mapRotationList>}i) {
					$maplist=1;
				}
			}

			if($update_admins) {
				if(m{</adminsByVaporID>}i) {
					foreach my $admin (split(m/;/, $admins)) {
						s{^}{        <UUID UUID="$admin" />\r\n}s;
					}
					$adminlist=0;
				}

				if($adminlist) {
					$_=''
				}
	
				if(m{<adminsByVaporID>}i) {
					$adminlist=1;
				}
			}
		}

		rename($Conffile, "$Conffile.bak");
		open($lconfig, '>', $Conffile);
		print $lconfig @xml;
		close($lconfig);
	}

	sub reconcile_option {
		my($config, $key)=@_;
		my($value)=&option($key);

		if($config->{$key} && !defined($value)) {
			config::option_set($key, $config->{$key});
		} elsif(!$config->{$key} && defined($value)) {
			$config->{$key}=$value;
		} elsif($config->{$key} && $value && $config->{$key} ne $value) {
			$config->{$key}=$value;
		}
	}

	sub launcher {
		my($server)=xml::decode($Conffile)->{'servers'};
		my($jdk)=&option('javaHome');
		my($fh)=IO::Handle->new;
		my(@filter)=();
		my($config);
		local($_);

		if($jdk && -d $jdk) {
			$ENV{'INSTALL4J_JAVA_HOME_OVERRIDE'}=$jdk;
		} else {
			delete($ENV{'INSTALL4J_JAVA_HOME_OVERRIDE'});
		}

		if(ref($server) eq 'ARRAY') {
			$config=$server->[0]{'AltitudeServerConfig'};
			ui::slog('!! You have more than one server defined !!');
			ui::slog('!! alti+server only supports 1 server    !!');
			ui::slog('!! Managing only the first instance      !!');
			sleep(1);
		} else {
			$config=$server->{'AltitudeServerConfig'};
		}

		foreach my $admin (@{$config->{'adminsByVaporID'}{'UUID'}}) {
			$Admins{$admin->{'UUID'}}=1;
		}

		$Port=$config->{'port'};
		$Ping=$config->{'maxPing'};
		$Maxp=$config->{'maxPlayerCount'}+1;

		&reconcile_option($config, 'secretCode');

		$Launcher{'goals'}=
			POSIX::ceil($config->{'PlaneBallGameMode'}{'goalsPerRound'}/2);

		$Launcher{'warmup'}={
			'1bd' => $config->{'ObjectiveGameMode'}{'warmupTimeSeconds'},
			'1de' => $config->{'ObjectiveGameMode'}{'warmupTimeSeconds'},
			'1dm' => $config->{'ObjectiveGameMode'}{'warmupTimeSeconds'},
			'ball' => $config->{'PlaneBallGameMode'}{'warmupTimeSeconds'},
			'ffa' => $config->{'FreeForAllGameMode'}{'warmupTimeSeconds'},
			'tbd' => $config->{'BaseDestroyGameMode'}{'warmupTimeSeconds'},
			'tdm' => $config->{'TeamDeathmatchGameMode'}{'warmupTimeSeconds'},
		};

		$Launcher{'roundTime'}={
			'1bd' => $config->{'ObjectiveGameMode'}{'roundTimeSeconds'},
			'1de' => $config->{'ObjectiveGameMode'}{'roundTimeSeconds'},
			'1dm' => $config->{'ObjectiveGameMode'}{'roundTimeSeconds'},
			'ball' => $config->{'PlaneBallGameMode'}{'roundTimeSeconds'},
			'ffa' => $config->{'FreeForAllGameMode'}{'roundTimeSeconds'},
			'tbd' => $config->{'BaseDestroyGameMode'}{'roundTimeSeconds'},
			'tdm' => $config->{'TeamDeathmatchGameMode'}{'roundTimeSeconds'},
		};

		$Launcher{'score'}={
			'ffa' => $config->{'FreeForAllGameMode'}{'scoreLimit'},
			'tdm' => $config->{'TeamDeathmatchGameMode'}{'scoreLimit'},
		};

		%Commands=map(($_->{'ConsoleCommand'} => undef), @{$config->
				{'consoleCommandPermissions'}
				{'AltitudeServerConsoleCommandPermissions'}
			});

		$Commands{'changeMap'}=['map'];
		$Commands{'removeMap'}=['map'];
		$Commands{'kick'}=['player'];
		$Commands{'listBans'}=undef;
		$Commands{'addBan'}=['string', 'string', 'string', 'string'];
		$Commands{'removeBan'}=['string'];
		$Commands{'ban'}=['player', 'string', 'string', 'string'];
		$Commands{'serverWhisper'}=['player', 'string'];

		rename($Custfile, $Custfile_o);

		foreach my $cmd (values(%ALTIPLUS)) {
			if($cmd->{'arguments'} && @{$cmd->{'arguments'}}) {
				$Commands{$cmd->{'name'}}=$cmd->{'arguments'};
			} else {
				$Commands{$cmd->{'name'}}=undef;
			}

			&_write_custom_commands($cmd);
		}

		$Reserve=compress::size_file($Custfile)+10;

		#These work only from console (see %CONSOLE):
		$Commands{'server'}=[
				['list', 'set', 'unset', 'add', 'del'],
				[sort(keys(%OPTIONS))],
				'string',
			];
		$Commands{'script'}=[
				['list', 'reload', 'del'],
				'string',
			];
		$Commands{'command'}=[
				['list', 'enable', 'disable', 'unset'],
				['all', sort(keys(%ALTIPLUS))]
			];
		$Commands{'importDefaults'}=undef;
		$Commands{'stashDisplay'}=['map'];
		$Commands{'stashClearSettings'}=['map'];
		$Commands{'stashClearRecords'}=['map'];
		$Commands{'setPlayerName'}=['player', 'string'];
		$Commands{'linkAccounts'}=['player', 'player'];
		$Commands{'updateNames'}=undef;
		$Commands{'showAdmins'}=undef;
		$Commands{'showModerators'}=undef;
		$Commands{'playerSearch'}=['player'];
		$Commands{'showPlayer'}=['player'];
		$Commands{'showTeams'}=undef;
		$Commands{'showSeen'}=undef;
		$Commands{'showRecent'}=undef;
		$Commands{'showRatings'}=[[@MODES, @TYPES]];
		$Commands{'showPowerups'}=undef;
		$Commands{'chatLeft'}=['string'];
		$Commands{'chatRight'}=['string'];
		$Commands{'chatSpec'}=['string'];
		$Commands{'shutdown'}=undef;

		open($fh, '<', $Filtfile);
		while(<$fh>) {
			chomp;
			s/\s+//g;
			s/er$//;

			next if(m/damn|bollocks/);

			push(@filter, $_);
		}
		close($fh);
		$Language=sprintf('(%s|\b)(%s)+(%s)?s?\b',
				'er|ing?',
				join('|', @filter),
				'a|er|ing?|ed'
			);
	}

	sub add_commands {
		my(%commands)=@_;

		foreach my $cmd (keys(%commands)) {
			$Commands{$cmd}=$commands{$cmd};
		}
	}

	sub read_maps {
		my($lconfig)=IO::Handle->new;
		my($maplist)=0;
		local($_);

		@Maps=();

		open($lconfig, '<', $Conffile);

		while(<$lconfig>) {
			if(m{</mapList>}i) {
				$maplist=0;
			}

			if($maplist) {
				push(@Maps, $1) if(m{<String value="(.*?)" />});
			}

			if(m{<mapList>|<mapRotationList>}i) {
				$maplist=1;
			}
		}

		close($lconfig);
	}

	sub _map_sort {
		$Mapdb{$a}=(-C $a) unless($Mapdb{$a});
		$Mapdb{$b}=(-C $b) unless($Mapdb{$b});

		return( $Mapdb{$a} <=> $Mapdb{$b} );
	}

	sub find_maps {
		my($packet_space)=1450-240-20*$Maxp-$Reserve;
		my($mapdir)=config::option('mapDir');

		ui::slog('Space reserved for maps:', $packet_space);

		@Maps=sort(config::_map_sort <$INSTALL_ROOT/maps/$mapdir/*_*.altx>);

		$Maplimit=@Maps unless($Maplimit);

		if(&option('lobby')) {
			@Maps=grep($_ ne &option('lobby'), @Maps);
		}

		foreach(@Maps) {
			s|^$INSTALL_ROOT/maps/+||;
			s|\.altx$||;
		}

		foreach my $map (splice(@Maps, $Maplimit)) {
			ui::slog('Excluding map due to packet size constraint:', $map);
		}

		while(@Maps && compress::size_data(@Maps)>$packet_space) {
			ui::slog('Excluding map due to packet size constraint:',
				pop(@Maps));
		}
		$Maplimit=@Maps;

		@Maps=List::Util::shuffle(@Maps);

		unless(@Maps) {
			ui::slog('Error: no maps found during startup');
			return;
		}
	}

	sub resize {
		my($diff)=@_;
		$diff-=1450;

		$Reserve+=$diff+5;
		$Maplimit--;
	}

	sub new_maps {
		my($lconfig)=IO::Handle->new;
		my($mapdir)=config::option('mapDir');
		my(%maps)=();
		local($_);

		foreach my $map (@_) {
			$maps{$map}=1 if(file::name_ok($map));
		}

		return(0) unless(%maps);

		open($lconfig, '<', $Conffile);
		while(<$lconfig>) {
			delete($maps{$1}) if(m| <String value="($mapdir.*?)" />|);
		}
		close($lconfig);


		if(%maps) {
			return(1);
		} else {
			return(0);
		}
	}

	sub remove_maps {
		my(@old)=@Maps;

		foreach my $map (@_) {
			@Maps=grep(!m/^\Q$map\E$/, @old);
		}

		if(@old==@Maps) { #Same size?
			return(0);
		} else {
			return(1);
		}
	}

	sub maps {
		return(@Maps);
	}

	sub lobby {
		return(config::option('lobby'));
	}

	sub random_map {
		my($rotation)=config::option('rotationRE');
		my(@candidates)=grep(m/($rotation)/, @Maps);
		my($next)=stash::get('nextMap', 'admin');

		if($next) {
			stash::delete('nextMap', 'admin');
			return($next);
		} else {
			return($candidates[int(rand(@candidates))]);
		}
	}

	sub admin_vid {
		my($vaporid)=@_;
		return(exists($Admins{$vaporid}));
	}

	sub commands {
		my($re)=@_;
		grep(m|^\Q$re|i, keys(%Commands));
	}

	sub arguments {
		my($command)=@_;

		if($Commands{$command}) {
			return(@{$Commands{$command}});
		} else {
			return(undef);
		}
	}

	sub command_help {
		my($p, $command)=@_;
		my($msg)="Syntax: /$command";
		my(@args)=();
		my($choice)=1;
		my($list);

		if($Commands{$command}) {
			foreach my $arg (@{$Commands{$command}}) {
				if(ref($arg) eq 'ARRAY') {
					$msg.=" <choice$choice>";
					push(@args, join(' ', "choice$choice:", @$arg));
					$choice++;
				} elsif($arg eq 'map') {
					$msg.=" <map>";
					$list=join(' ', "map:", @Maps);
					if(length($list)>390) {
						substr($list, 390, 4096, " ...");
					}
					push(@args, $list);
				} elsif($arg eq 'player') {
					$msg.=" <player>";
					push(@args, join(' ', "players:", player::values('nickname')));
				} elsif($arg eq 'vaporId') {
					$msg.=" <vaporId>";
					push(@args, join(' ', "vaporIds:", map(
							"$_->{'nickname'}:$_->{'vaporId'}",
							player::list()))
						);
				} elsif($arg eq 'int') {
					$msg.=" <#>";
				} else {
					$msg.=" <...>";
				}
			}
			chat::whisper($p, $msg);
			foreach my $arg (@args) {
				chat::whisper($p, ' ', $arg);
			}
		}
	}

	sub language {
		local($_)=@_;

		if(config::option('bullyKick') && m/$Language/i) {
			return(1);
		} else {
			return(0);
		}
	}

	sub harrasment {
		local($_)=@_;

		if(config::option('bullyKick') && m/$Harrasment/i) {
			return(1);
		} else {
			return(0);
		}
	}

	sub yelling {
		local($_)=@_;

		if(config::option('bullyKick') && m/^[A-Z\s?!.-]+$/) {
			return(1);
		} else {
			return(0);
		}
	}

}

%ALTIPLUS=(
	'!' => {
		'name'			=> '!',
		'arguments'		=> ['string'],
		'voteThreshold'	=> 100,
		'enabled'			=> 1,
		'restrict'		=> 'normal|small',
	},
	'?' => {
		'name'			=> '?',
		'arguments'		=> ['string'],
		'voteThreshold'	=> 0,
		'enabled'			=> 1,
		'restrict'		=> 'normal|small',
	},
	'l' => {
		'name'			=> 'l',
		'arguments'		=> ['string'],
		'voteThreshold'	=> 0,
		'enabled'			=> 1,
		'restrict'		=> 'normal|small',
	},

	'help' => {
		'name'			=> 'help',
		'arguments'		=> [['map', 'nextMap', 'gravity', 'weapons', 'spawnHealth', 'cameraScale', 'planeScale', 'assignTeam', 'planes', 'score', 'spawnMode', 'changePlane', 'maxPlayers', 'gameType', 'notes', 'powerups', 'portals', 'doors', 'keys', 'diverters', 'oneways', 'zones', 'rank', 'official', 'alti+', 'altitudegame', 'ladder', 'tinyupload', 'url', 'intro', 'records']],
		'voteThreshold'	=> 0,
		'enabled'			=> 1,
		'restrict'		=> 'tiny',
	},

	'upload' => {
		'name'			=> 'upload',
		'arguments'		=> [['official', 'alti+', 'altitudegame', 'ladder', 'tinyupload', 'url'], 'string'],
		'voteThreshold'	=> 100,
		'enabled'			=> config::option('allowUploads'),
	},

	'list' => {
		'name'			=> 'list',
		'arguments'		=> [['map', 'nextMap', 'gravity', 'weapons', 'spawnHealth', 'cameraScale', 'planeScale', 'assignTeam', 'planes', 'score', 'spawnMode', 'changePlane', 'maxPlayers', 'gameType', 'notes', 'powerups', 'portals', 'doors', 'keys', 'diverters', 'oneways', 'zones', 'intro', 'records']],
		'voteThreshold'	=> 0,
		'enabled'			=> 1,
		'restrict'		=> 'tiny',
	},

	'set' => {
		'name'			=> 'set',
		'arguments'		=> [['nextMap', 'gravity', 'weapons', 'spawnHealth', 'cameraScale', 'planeScale', 'assignTeam', 'score', 'spawnMode', 'changePlane', 'maxPlayers', 'gameType', 'intro', 'keys'], 'string'],
		'voteThreshold'	=> 100,
		'enabled'			=> 1,
		'restrict'		=> 'tiny',
	},

	'unset' => {
		'name'			=> 'unset',
		'arguments'		=> [['nextMap', 'gravity', 'weapons', 'spawnHealth', 'cameraScale', 'planeScale', 'assignTeam', 'score', 'spawnMode', 'changePlane', 'maxPlayers', 'gameType', 'intro', 'keys']],
		'voteThreshold'	=> 100,
		'enabled'			=> 1,
		'restrict'		=> 'tiny',
	},

	'add' => {
		'name'			=> 'add',
		'arguments'		=> [['note', 'plane', 'powerup', 'portal', 'door', 'key', 'diverter', 'oneway', 'zone'], 'string'],
		'voteThreshold'	=> 100,
		'enabled'			=> 1,
		'restrict'		=> 'tiny',
	},

	'del' => {
		'name'			=> 'del',
		'arguments'		=> [['note', 'plane', 'powerup', 'portal', 'door', 'key', 'diverter', 'oneway', 'zone', 'record'], 'string'],
		'voteThreshold'	=> 100,
		'enabled'			=> 1,
		'restrict'		=> 'tiny',
	},

	'timer'	=> {
		'name'			=> 'timer',
		'arguments'		=> ['string'],
		'voteThreshold'	=> 0,
		'enabled'			=> 0,
		'restrict'		=> 'tiny',
	},

	'who'	=> {
		'name'			=> 'who',
		'arguments'		=> ['player'],
		'voteThreshold'	=> 0,
		'enabled'			=> 0,
		'restrict'		=> 'tiny',
	},

	'abuse'	=> {
		'name'			=> 'abuse',
		'arguments'		=> ['player', ['chat', 'ban', 'nick', 'rude']],
		'voteThreshold'	=> 0,
		'enabled'			=> 0,
		'restrict'		=> 'tiny',
	},

	'restartServer' => {
		'name'			=> 'restartServer',
		'arguments'		=> [],
		'voteThreshold'	=> 100,
		'enabled'			=> 1,
	},

	'randomMap' => {
		'name'			=> 'randomMap',
		'arguments'		=> [],
		'voteThreshold'	=> 66,
		'enabled'			=> 1,
	},

	'removeMap' => {
		'name'			=> 'removeMap',
		'arguments'		=> ['map'],
		'voteThreshold'	=> 100,
		'enabled'			=> config::option('allowUploads'),
	},

	'rank' => {
		'name'			=> 'rank',
		'arguments'		=> ['string'],
		'voteThreshold'	=> 0,
		'enabled'			=> 0,
		'restrict'		=> 'tiny',
	},

	'prey' => {
		'name'			=> 'prey',
		'arguments'		=> ['player'],
		'voteThreshold'	=> 60,
		'enabled'			=> 0,
	},

	'spawnZone' => {
		'name'			=> 'spawnZone',
		'arguments'		=> ['string'],
		'voteThreshold'	=> 0,
		'enabled'			=> 1,
		'restrict'		=> 'tiny',
	},
	'sz' => {
		'name'			=> 'sz',
		'arguments'		=> ['string'],
		'voteThreshold'	=> 0,
		'enabled'			=> 1,
	},

	'changePlane' => {
		'name'			=> 'changePlane',
		'arguments'		=> [],
		'voteThreshold'	=> 0,
		'enabled'			=> 0,
		'restrict'		=> 'tiny',
	},
	'cp' => {
		'name'			=> 'cp',
		'arguments'		=> [],
		'voteThreshold'	=> 0,
		'enabled'			=> 1,
	},

	'raceMap' => {
		'name'			=> 'raceMap',
		'arguments'		=> ['map'],
		'voteThreshold'	=> 100,
		'enabled'			=> 0,
	},

	'raceStart' => {
		'name'			=> 'raceStart',
		'arguments'		=> [],
		'voteThreshold'	=> 75,
		'enabled'			=> 0,
	},

	'raceCancel' => {
		'name'			=> 'raceCancel',
		'arguments'		=> [],
		'voteThreshold'	=> 75,
		'enabled'			=> 0,
	},

	'raceGoals' => {
		'name'			=> 'raceGoals',
		'arguments'		=> ['string'],
		'voteThreshold'	=> 100,
		'enabled'			=> 0,
	},


	'raceList' => {
		'name'			=> 'raceList',
		'arguments'		=> [],
		'voteThreshold'	=> 0,
		'enabled'			=> 0,
	},

	'raceAdd' => {
		'name'			=> 'raceAdd',
		'arguments'		=> ['player'],
		'voteThreshold'	=> 100,
		'enabled'			=> 0,
	},

	'raceDel' => {
		'name'			=> 'raceDel',
		'arguments'		=> ['player'],
		'voteThreshold'	=> 100,
		'enabled'			=> 0,
	},

	'go' => {
		'name'			=> 'go',
		'arguments'		=> [],
		'voteThreshold'	=> 0,
		'enabled'			=> 0,
	},

	'switch' => {
		'name'			=> 'switch',
		'arguments'		=> [],
		'voteThreshold'	=> 0,
		'enabled'			=> 1,
	},

	'talk' => {
		'name'			=> 'talk',
		'arguments'		=> ['player', 'string'],
		'voteThreshold'	=> 0,
		'enabled'			=> config::option('enableTalk'),
	},

	'mesg' => {
		'name'			=> 'mesg',
		'arguments'		=> [['Yes', 'No', '?']],
		'voteThreshold'	=> 0,
		'enabled'			=> config::option('enableTalk'),
	},

	'sum' => {
		'name'			=> 'sum',
		'arguments'		=> [['crc32', 'md5', 'sha1', 'sha256']],
		'voteThreshold'	=> 0,
		'enabled'			=> 0,
	},

	'logPickups' => {
		'name'			=> 'logPickups',
		'arguments'		=> [],
		'voteThreshold'	=> 0,
		'enabled'			=> 0,
	},

	'restartMap' => {
		'name'			=> 'restartMap',
		'arguments'		=> [],
		'voteThreshold'	=> 0,
		'enabled'			=> 0,
		'restrict'		=> 'tiny',
	},
);


=head2 Patched Server

When B<alti+server> is run on a patched code base, it can take advantage
of the new features.  Features which augment the logging interface may
be detected and affect behavior on-demand.  Other, which are more
in-depth, will be detected during initialization and affect B<alti+server>
at a more systematic level.

Please note that while the F<mods.hjson> file can be in the HJSON format
for the server patches, B<alti+server> only understands pure JSON.  The
file will be maintained in pure JSON, and any manual changes must continue
to adhere to the JSON standard.  It is recommended to use the B<alti+server>
console interface to make changes to these settings, then the server code is
garunteed to keep the format correct.

=cut

{	package xx;

	use version;

	my($Modsfile)="$INSTALL_ROOT/servers/mods.hjson";
	my($Permsfile)="$INSTALL_ROOT/servers/permissions.hjson";

	my($Version)=undef;
	my(@Global)=('mods', 'global');
	my(@Server)=('mods', 'servers');
	my(@Permissions)=('permissions');
	my($Default);
	my(%Path);

	my(%Setup)=(
		'plane'	=> {
			'Loopy'			=> 0,
			'Bomber'			=> 1,
			'Explodet'		=> 2,
			'Biplane'			=> 3,
			'Miranda'			=> 4,
		},
		'red'	=> {
			'Tracker'			=> 0,
			'Double Fire'		=> 1,
			'Acid Bomb'		=> 2,

			'Suppressor'		=> 0,
			'Bombs'			=> 1,
			'Flak Tailgun'		=> 2,

			'Director'		=> 0,
			'Thermobarics'		=> 1,
			'Remote Mine'		=> 2,

			'Dogfighter'		=> 0,
			'Recoilless Gun'	=> 1,
			'Heavy Cannon'		=> 2,

			'Trickster'		=> 0,
			'Laser'			=> 1,
			'Time Anchor'		=> 2,
		},
		'green'	=> {
			'No Green Perk'	=> 0,
			'Rubberized Hull'	=> 1,
			'Heavy Armor'		=> 2,
			'Repair Drone'		=> 3,
			'Flexible Wings'	=> 4,
		},
		'blue'	=> {
			'No Blue Perk'		=> 0,
			'Turbocharger'		=> 1,
			'Ultracapacitor'	=> 2,
			'Reverse Thrust'	=> 3,
			'Ace Instincts'	=> 4,
		},
		'skin'	=> {
			'No Skin'			=> 0,
			'Shark Skin'		=> 1,
			'Zebra Skin'		=> 2,
			'Checker Skin'		=> 3,
			'Flame Skin'		=> 4,
			'Santa Hat'		=> 5,
		},
	);


	sub _datastructures {
		$Server[2]=$config::Port;

		$Default={
			$Global[0]				=> {
				$Global[1]			=> {
					'position_log_time'	=> 0,
					'permissions'		=> {
						'enabled'		=> json::true,
						'fallback'	=> json::true,
						'file_name'	=> 'permissions.hjson',
					},
					'client_commands'	=> [
					],
				},
				$Server[1]				=> {
					$Server[2]			=> {
						'custom_join'		=> {
							'ignore_default'	=> json::false,
						},
						'restrict_level'	=> {
							'enabled'		=> json::false,
							'min'		=> {
								'ace'	=> 0,
								'level'	=> 0,
							},
							'max'		=> {
								'ace'	=> 10,
								'level'	=> 60,
							},
						},
						'whitelist'		=> {
							'enabled'		=> json::false,
							'allow'		=> [
								'00000000-0000-0000-0000-000000000000',
							],
				
						},
					},
				},
			},
			$Permissions[0]				=> {
				'user_groups'				=> {
					'admins'				=> [
								'00000000-0000-0000-0000-000000000000',
					],
					'moderators'			=> [
								'00000000-0000-0000-0000-000000000000',
					],
					'disabled'			=> [],
				},
				'commands'				=> {
					'abuse'				=> [ 'admins', 'moderators' ],
					'assignTeam'			=> [ 'admins', 'moderators' ],
					'balanceTeams'			=> [
								'admins', 'moderators', 'vote'
					],
					'changeMap'			=> [
								'admins', 'moderators', 'vote'
					],
					'raceAdd'				=> [ 'admins', 'moderators' ],
					'raceCancel'			=> [ 'admins', 'moderators' ],
					'raceDel'				=> [ 'admins', 'moderators' ],
					'raceGoals'			=> [ 'admins', 'moderators' ],
					'raceMap'				=> [ 'admins', 'moderators' ],
					'raceStart'			=> [
								'admins', 'moderators', 'vote'
					],
					'testDS'				=> [ 'disabled' ],
					'testEM'				=> [ 'disabled' ],
					'testHM'				=> [ 'disabled' ],
				},
			},
		};

		$Default->{$Permissions[0]}{'user_groups'}{'admins'}=[
			split(m/;+/, config::option('admins'))
		];
		$Default->{$Permissions[0]}{'user_groups'}{'moderators'}=[
			split(m/;+/, config::option('moderators'))
		];

		%Path=(
			'logPositions'		=> [@Global, 'position_log_time'],
			'extendPermissions'	=> [@Global, 'permissions', 'enabled'],
			'aclFallback'		=> [@Global, 'permissions', 'fallback'],
			'admins'			=> [@Permissions, 'user_groups', 'admins'],
			'moderators'		=> [@Permissions, 'user_groups', 'moderators'],
			'acl'			=> [@Permissions, 'commands'],
			'clientCommand'	=> [@Global, 'client_commands'],
			'joinIgnoreDefault'	=> [@Server, 'custom_join', 'ignore_default'],
			'minAce'			=> [@Server, 'restrict_level', 'min', 'ace'],
			'minLevel'		=> [@Server, 'restrict_level', 'min', 'level'],
			'maxAce'			=> [@Server, 'restrict_level', 'min', 'ace'],
			'maxLevel'		=> [@Server, 'restrict_level', 'min', 'level'],
			'levelRestrictions'	=> [@Server, 'restrict_level', 'enabled'],
			'whitelist'		=> [@Server, 'whitelist', 'enabled'],
			'allow'			=> [@Server, 'whitelist', 'allow'],
		);
	}

	sub path {
		my($setting)=@_;

		return(undef) unless(ref($Path{$setting}) eq 'ARRAY');

		return(reverse(@{$Path{$setting}}));
	}

	sub config_reload {
		return unless($Version);

		json::write_file(stash::get('mods', 'xx'), $Modsfile);
		server::send('reloadModConfig');
	}

	sub perms_reload {
		return unless($Version);

		json::write_file(stash::get('permissions', 'xx'), $Permsfile);
		server::send('reloadPermissions');
	}

	sub enabled {
		my($version)=@_;

		if($version) {
			return($version lt $Version);
		} else {
			return($Version);
		}
	}

	sub initialize_mods {
		my($version)=@_;
		my($config)=stash::get('xx');

		unless(config::option('xxEnabled')) {
			return;
		}
		unless($version) {
			server::shutdown();
			db::shutdown();

			ui::slog('!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!');
			ui::slog('! You must upgrade to release 0.1.0 of xx patches !');
			ui::slog('! because it is a rewrite, this Alti+ version is  !');
			ui::slog('! not compatible with this server patch level.    !');
			ui::slog('!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!');

			ui::shutdown;
			exit(1);
		}

		$Version=$version;

		&_datastructures;

		if($config) {
			delete($config->{$Permissions[0]}{'user_groups'}{'admins'});
			delete($config->{$Permissions[0]}{'user_groups'}{'moderators'});
			stash::marry($config, $Default);
		} else {
			$config={};
			if(-r $Modsfile) {
				stash::marry($config->{$Global[0]}, json::read_file($Modsfile));
			} else {
				stash::marry($config->{$Global[0]}, $Default->{$Global[0]});
			}
			if(-r $Permsfile) {
				stash::marry($config->{$Permissions[0]}, json::read_file($Permsfile));
			} else {
				stash::marry($config->{$Permissions[0]}, $Default->{$Permissions[0]});
			}
		}

		stash::set('xx', $config);
		&config_reload;
		&perms_reload;

		config::add_commands(
			'xx'				=> [
				['list', 'set', 'unset', 'add', 'del'],
				[sort(keys(%Path))],
				'string',
			],
			'reloadModConfig'	=> [],
			'reloadPermissions'	=> [],
			'setTime'			=> [
				'int'
			],
			'getTime'			=> [],
			'overrideTdmScore'	=> [
				'int',
				'int'
			],
			'botPlaneSetup'	=> [
				'int',
				'int',
				'int',
				'int',
				'int',
			],
			'botPlaneRandom'	=> [],
		);
	}

	sub config {
		my($name)=@_;
		my($value)=stash::get(&path($name), 'xx');

		if(ref($value)=~m/Boolean/) {
			if($value) {
				return('true');
			} else {
				return('false');
			}
		} else {
			return($value);
		}
	}

	sub config_set {
		my($name, $value)=@_;
		my($current)=stash::get(&path($name), 'xx');

		if(ref($current)=~m/Boolean/ || $value=~m/true|false/) {
			if($value=~m/^false|no/i || !$value) {
				return(stash::set(&path($name), 'xx', json::false));
			} else {
				return(stash::set(&path($name), 'xx', json::true));
			}
		} elsif(ref($current)) {
			return(undef);
		} else {
			return(stash::set(&path($name), 'xx', $value));
		}
	}

	sub config_unset {
		my($name)=@_;
		my($default)=$Default;
		my(@path)=&path($name);

		while(defined($default) && @path) {
			if(ref($default)) {
				$default=$default->{pop(@path)};
			} else {
				$default=undef;
			}
		}

		if(defined($default)) {
			stash::set(&path($name), 'xx', $default);
		} else {
			stash::delete(&path($name), 'xx');
		}
	}

	sub config_add {
		my($name, $value)=@_;
		my($array)=stash::get(&path($name), 'xx');

		return(undef) unless(defined($array));

		if(ref($array) eq 'ARRAY') {
			foreach my $existing (@$array) {
				return(scalar @$array) if($existing eq $value);
			}
			push(@$array, $value);
			stash::save;
		} else {
			return(undef);
		}
	}

	sub config_del {
		my($name, $value)=@_;
		my($array)=stash::get(&path($name), 'xx');
		my($parent);

		if(ref($array) eq 'ARRAY') {
			for(my $i=0; $i<@$array; $i++) {
				while($array->[$i] eq $value) {
					splice(@$array, $i, 1);
				}
			}
			stash::save;
		} else {
			return(undef);
		}
	}

	sub acl_set {
		my($command, @groups)=@_;
		my($acl)=[split(m/[,;|\s]+/, join(',', @groups))];

		stash::set($command, &path('acl'), 'xx', $acl);

		&perms_reload;
	}

	sub acl_unset {
		my($command)=@_;
		my($config)=stash::get('xx');

		return(undef) if($command=~m/test[DEH]M/);

		stash::delete($command, &path('acl'), 'xx');
		stash::marry($config->{$Permissions[0]}, $Default->{$Permissions[0]});

		&perms_reload;
	}

	sub set_time {
		my($change)=@_;
		my($limit, $used)=map::timer();

		return unless(&enabled);

		server::send('setTime', 30 * List::Util::max(0, int($limit-$change)));
	}

	sub setup_bot {
		my($plane)=utils::plane(shift // int(rand(5)));
		my($red)=utils::red(shift // int(rand(3)));
		my($green)=utils::green(shift // int(rand(4)+1));
		my($blue)=utils::blue(shift // int(rand(4)+1));
		my($skin)=utils::skin(shift);

		return unless(&enabled);

		if(!defined($skin)) {
			if(utils::coin_toss) {
				$skin=int(rand(6));
			} else {
				$skin='No Skin';
			}
		}

		$plane=$Setup{'plane'}{$plane}	unless(utils::is_int($plane));
		$red  =$Setup{'red'}{$red}		unless(utils::is_int($red));
		$green=$Setup{'green'}{$green}	unless(utils::is_int($green));
		$blue =$Setup{'blue'}{$blue}		unless(utils::is_int($blue));
		$skin =$Setup{'skin'}{$skin}		unless(utils::is_int($skin));

		server::send('botPlaneSetup', $plane, $red, $green, $blue, $skin);
	}

}


=head2 Backends

Some data can be stored in a database.  B<alti+server> will automatically
enable more liberal data collection and storage when a database backend
is present than it otherwise would.  Without a database backend, data is
stored in standard file formats (json or csv) so it can be accessed easily
when needed.  This is slow, and requires a lot of memory.  As such,
B<alti+server> runs in a lean mode.  With a proper database backend, more
information can be kept and accesed efficiently.

Supported databases are SQLite and PostgreSQL.

=cut

{	package db;

	my($Dbh)=undef;
	my(@connect)=();
	my($Type)=undef;

	sub init {
		if(config::option('db_type')=~m/Pg/i) {
			@connect=(
				'dbi:Pg:dbname='.config::option('db_name'),
				config::option('db_user'),
				utils::get_value(config::option('db_pass')),
				{'PrintError' => config::option('debug')}
			);
			if($Dbh=eval('use DBI; DBI->connect(@connect)')) {
				ui::slog('using DBD::Pg (ok)');
				$Type='pg';
			} else {
				ui::slog('No database libraries, falling back to stash-only mode');
				$Type=undef;
			}
		} elsif(config::option('db_type')=~m/SQLite/i) {
			if(config::option('db_name')=~m|/|) {
				@connect=(
					'dbi:SQLite:dbname='.config::option('db_name'),
					'',
					'',
					{'PrintError' => config::option('debug')}
				);
			} else {
				@connect=(
					'dbi:SQLite:dbname='."$INSTALL_ROOT/servers/".config::option('db_name'),
					'',
					'',
					{'PrintError' => config::option('debug')}
				);
			}

			if($Dbh=eval('use DBI; DBI->connect(@connect)')) {
				ui::slog('using DBD::SQLite (ok)');
				$Type='sqlite';
			} else {
				ui::slog('No database libraries, falling back to stash-only mode');
				$Type=undef;
			}
		}
	}

	sub reconnect {
		my(%attrs)=@_;

		foreach my $attr (keys(%attrs)) {
			$Dbh->{$attr}=$attrs{$attr};
		}

		undef($Dbh);

		&init;
	}

	sub check {
		&reconnect unless($Dbh->ping);
	}

	sub create {
		my(@stmts)=(
			qq{
				CREATE TABLE IF NOT EXISTS info (
					key TEXT PRIMARY KEY,
					value TEXT
				);
			},
	
			qq{
				CREATE TABLE IF NOT EXISTS player (
					vaporid CHAR(36) PRIMARY KEY,
					id INTEGER,
					name TEXT,
					nickname TEXT,
					seen INTEGER,
					ip TEXT,
					block INTEGER
				);
			},

			qq{
				CREATE TABLE IF NOT EXISTS rank (
					id INTEGER,
					type TEXT,
					rating INTEGER,
					differential REAL,
					PRIMARY KEY (id, type)
				);
			},

			qq{
				CREATE TABLE IF NOT EXISTS aliases (
					vaporid CHAR(36),
					nickname TEXT,
					PRIMARY KEY (vaporid, nickname),
					FOREIGN KEY (vaporid) REFERENCES player(vaporid)
				);
			},

			qq{
				CREATE TABLE IF NOT EXISTS records (
					id INTEGER PRIMARY KEY,
					map TEXT,
					record REAL,
					date INTEGER,
					players TEXT
				);
			},

			qq{
				CREATE INDEX IF NOT EXISTS idx_map_records ON records (map);
			},
		);

		foreach my $stmt (@stmts) {
			if($Type eq 'pg') {
				$stmt=~s/INTEGER PRIMARY KEY/SERIAL PRIMARY KEY/;
			}
			$Dbh->do($stmt);
		}
	}

	sub upgrade_v2 {
		my(@stmts)=(
			qq{
				ALTER TABLE player RENAME TO player_orig;
			},
			qq{
				CREATE TABLE player (
					vaporid CHAR(36) PRIMARY KEY,
					id INTEGER,
					name TEXT,
					nickname TEXT,
					seen INTEGER,
					ip TEXT,
					block INTEGER
				);
			},
			qq{
				INSERT INTO player
					(vaporid, name, nickname, seen, ip, block)
				SELECT
					vaporid, name, nickname, seen, ip, block
				FROM player_orig;
			},
			qq{
				DROP TABLE player_orig;
			},
			qq{
				DROP TABLE rank;
			},
			qq{
				CREATE TABLE IF NOT EXISTS rank (
					id INTEGER,
					type TEXT,
					rating INTEGER,
					differential REAL,
					PRIMARY KEY (id, type)
				);
			},
		);
		my($i)=100;
		my($cols);

		$Dbh->begin_work();
		foreach my $stmt (@stmts) {
			$Dbh->do($stmt);
		}
		$Dbh->commit();

		$Dbh->begin_work();
		$cols=$Dbh->selectcol_arrayref(qq{
			SELECT DISTINCT name FROM player WHERE name IS NOT NULL;
		});
		foreach my $name (@$cols) {
			$Dbh->do(qq{UPDATE player SET id=$i WHERE name='$name';});
			$i++;
		}

		$cols=$Dbh->selectcol_arrayref(qq{
			SELECT vaporid FROM player WHERE name IS NULL;
		});
		foreach my $vaporid (@$cols) {
			$Dbh->do(qq{UPDATE player SET id=$i WHERE vaporid='$vaporid';});
			$i++;
		}

		$Dbh->do(qq{INSERT INTO info VALUES ('nextid', $i);});
		$Dbh->commit();
	}

	sub quote {
		local($_)=@_;

		s/'/''/g;

		return($_);
		#return($Dbh->quote($_[0]));
	}

	sub enabled {
		return(defined($Type));
	}

	sub shutdown {
		if($Dbh) {
			$Dbh->disconnect;
			$Dbh=undef;
		}
	}

	sub info {
		my($key)=@_;

		return(undef) unless($key);

		&check;

		return($Dbh->selectrow_array(
			qq{ SELECT value FROM info WHERE key='$key'; }
		));
	}

	sub upgrade {
		my($version);

		return unless(&enabled);

		($version)=&info('version');

		if(!$version) {
			&create;
			$Dbh->do(qq{INSERT INTO info VALUES ('version', 2);});
			$version=2;
		}

		if($version<2) {
			&upgrade_v2;
			$Dbh->do(qq{UPDATE info SET value=2 WHERE key='version';});
		}
	}

	sub type {
		return($Type);
	}

	sub begin {
		$Dbh->begin_work();
	}

	sub commit {
		$Dbh->commit();
	}

	sub query {
		return(undef) unless(&enabled);

		&check;

		return($Dbh->selectall_arrayref(join(' ', @_)));
	}

	sub count {
		my($table, $where)=@_;
		my($count)=undef;

		return(undef) unless(&enabled);
		return(undef) unless($table && $where);

		&check;

		($count)=$Dbh->selectrow_array(
				qq{SELECT COUNT(1) FROM $table WHERE $where;});

		return($count);
	}

	sub select {
		my($table, $where)=@_;
		my(@rows)=();
		my($sth, $row);

		return(undef) unless(&enabled);
		return(undef) unless($table && $where);

		&check;

		ui::slog(qq{ SELECT * FROM $table WHERE $where; })
					if(config::option('debug'));

		$sth=$Dbh->prepare(qq{ SELECT * FROM $table WHERE $where; });
		$sth->execute;

		while($row=$sth->fetchrow_hashref) {
			push(@rows, $row);
		}

		$sth->finish;

		return(@rows);
	}

	sub insert {
		my($table, $set)=@_;
		my(@keys, @values);
		my($keys, $values);

		return(undef) unless(&enabled);
		return(undef) unless($table && ref($set) eq 'HASH' && %$set);

		&check;

		while(my($k, $v)=each(%$set)) {
			push(@keys, $k);
			if($v=~m/^[\d.]+$/) {
				push(@values, $v);
			} else {
				$v=&quote($v);
				push(@values, "'".$v."'");
			}
		}
		$keys=join(', ', @keys);
		$values=join(', ', @values);

		return($Dbh->do(qq{INSERT INTO $table ($keys) VALUES($values);}));
	}

	sub update {
		my($table, $where, $set)=@_;
		my(@pairs);
		my($pairs);

		return(undef) unless(&enabled);
		return(undef) unless($table && $where && ref($set) eq 'HASH' && %$set);

		&check;

		while(my($k, $v)=each(%$set)) {
			if($v=~m/^[\d.]+$/) {
				push(@pairs, "$k=$v");
			} else {
				$v=&quote($v);
				push(@pairs, sprintf("%s='%s'", $k, $v));
			}
		}
		$pairs=join(', ', @pairs);

		return($Dbh->do(qq{UPDATE $table SET $pairs WHERE $where;}));
	}

	sub upsert {
		my($table, $where, $set)=@_;
		my($count);

		return(undef) unless(&enabled);
		return(undef) unless($table && $where && $set);

		&check;

		$count=&count($table, $where);

		if($count<1) {
			&insert($table, $set);
		} elsif($count==1) {
			&update($table, $where, $set);
		} else {
			ui::slog('Use db::update if you want to update multiple rows');
			return(undef);
		}

	}

	sub delete {
		my($table, $where)=@_;
		my($rows);

		return(undef) unless(&enabled);
		return(undef) unless($table && $where);

		&check;

		return($Dbh->do(qq{DELETE FROM $table WHERE $where;}));
	}

	#Table interface:
	sub nextid {
		my($next)=&select('info', qq{key='nextid'});

		if($next) {
			&update('info', qq{key='nextid'}, { 'value' => $next->{'value'}+1 });
			return($next->{'value'});
		} else {
			&insert('info', { 'key' => 'nextid', 'value' => 2 });
			return(1);
		}

	}

	sub recent {
		my(@player)=();
		my($recent)=time()-(5*86400);

		@player=&select('player', qq{ seen>$recent
								ORDER BY seen DESC LIMIT 100 });

		return(@player);
	}

	sub psearch {
		my($search)=lc($_[0]);
		my(@player)=();

		if(utils::is_int($search)) {
			@player=&select('player', qq{ id='$search' });
		} elsif($search=~m/^[\d.:]+$/) {
			@player=&select('player', qq{ ip LIKE '$search%' });
		} else {
			@player=&select('player', qq{
					lower(name)     = '$search' OR
					lower(nickname) = '$search' OR
					lower(vaporid)  = '$search'
				});
			unless(@player and length($search)>2) {
				@player=db::select('player', qq{
						lower(name)     LIKE '$search\%' OR
						lower(nickname) LIKE '$search\%' OR
						lower(vaporid)  LIKE '\%$search'
					});

				unless(@player) {
					@player=db::select('player', qq{
						lower(nickname) LIKE '\%$search\%'
					});
				}
			}
		}

		if(wantarray) {
			return(@player);
		} else {
			return(shift(@player));
		}
	}

	sub player {
		my($p, $update)=@_;
		my($row);

		if($update) {
			&upsert('player', qq{vaporid='$p->{"vaporId"}'}, $update);
		} else {
			($row)=&select('player', qq{vaporid='$p->{"vaporId"}'});
			return($row);
		}
	}

	sub aliases {
		my($p, $alias)=@_;
		my($cols);

		if($alias) {
			&insert('aliases', {
					'vaporid'		=> $p->{'vaporId'},
					'nickname'	=> $alias,
				});
		} else {
			$cols=$Dbh->selectcol_arrayref(qq{
				SELECT nickname FROM aliases WHERE vaporid='$p->{"vaporId"}';
			});

			if(ref($cols) eq 'ARRAY') {
				return(@$cols);
			} else {
				return();
			}
		}
	}

	sub records {
		my($map, $record)=@_;

		if($record) {
			&insert('records', {
					'map'     => $map,
					'record'  => $record->[0],
					'date'    => $record->[1],
					'players' => $record->[2],
				});
		} else {
			return($Dbh->selectall_arrayref(qq{
					SELECT record,date,players
						FROM records
						WHERE map='$map'
						ORDER BY record;
				}));
		}
	}

	sub extra_records {
		my($map)=@_;
		my($cols);

		&check;

		$cols=$Dbh->selectcol_arrayref(qq{
			SELECT id FROM records
				WHERE map='$map'
				ORDER BY record
				LIMIT 16 OFFSET 100;
		});

		if(ref($cols) eq 'ARRAY') {
			return(@$cols);
		} else {
			return();
		}
	}

	sub rank {
		my($p, $type, $value)=@_;
		my($rating)=&select('rank', qq{id='$p->{"id"}' AND type='$type'});
		my($init)=800;

		unless(ref($rating) eq 'HASH') {
			if($p->{'aceRank'}) {
				$init=740+$p->{'level'};
			} else {
				$init=620+3*$p->{'level'};
			}

			$rating={
				'id'           => $p->{'id'},
				'type'         => $type,
				'rating'       => $init,
				'differential' => 0,
			};
			&insert('rank', $rating);
		}

		if($value) {
			$rating->{'rating'}+=int($value);
			$rating->{'differential'}=sprintf("%.1f",
				$rating->{'differential'}+$p->{'stats'}{'differential'});

			$rating->{'rating'}=1 if($rating->{'rating'}<1);

			&update('rank', qq{id='$p->{"id"}' AND type='$type'}, $rating);
		}

		return(@$rating{'rating', 'differential'});
	}
}


=head2 AltBouncer

Keep AltBouncer up-to-date.  If the C<altBouncer> configuration option is
set, then the server will keep track of all users seen and periodically send
them to the AltBouncer system.

=cut

{	package altbouncer;

	my($File)="$INSTALL_ROOT/servers/players_seen_$config::Uuid.xml";
	my($Seenlog)="$INSTALL_ROOT/servers/seen.txt";
	my($Seenlog_o)="$INSTALL_ROOT/servers/seen_old.txt";
	my($Url)='http://tec27.com/altbouncer/uploadaltnames.php';
	my($Curl)=utils::which('curl', 'good', 'forcing AltBouncer support off');
	my(@Args)=qw(-s -F MAX_FILE_SIZE=80000 -m);
	my($Sent)=time();

	my(%Seen)=();

	sub clear {
		%Seen=();
	}

	sub add {
		my($p)=@_;
		my($log)=IO::Handle->new;
		my($time)=time()*1000;

		rename($Seenlog, $Seenlog_o) if(-s $Seenlog > 262144);
		open($log, '>>', $Seenlog);
		print $log join(',', $time, @$p{'vaporId','ip','nickname'}), "\n";
		close($log);

		return unless(config::option('altBouncer'));
		return unless($Curl);
		return if($p->{'demo'});
		return if($p->{'nickname'}=~m/Guest_\d{12}/);

		if($p->{'nickname'} && $p->{'vaporId'}) {
			$Seen{$p->{'nickname'}}{$p->{'vaporId'}}=$time;
		}
	}

	sub count {
		return(scalar(keys(%Seen)));
	}

	sub lookup {
		my($query)=@_;
		my(@players)=();
		my($log)=IO::Handle->new;
		my($time, $vid, $ip, $nick);

		open($log, '<', $Seenlog);

		while(<$log>) {
			($time, $vid, $ip, $nick)=m/^(\d+),([\da-f-]+),([\d.:]+),(.+)$/;

			next unless(	$vid=~m/\b$query\b/	||
						$ip=~m/\b$query\b/	||
						$nick=~m/\b$query/	);

			unshift(@players, {
				'lastPlayedWithTime'	=> $time,
				'vaporID'				=> $vid,
				'ip'					=> $ip,
				'nickname'			=> $nick,
			});
		}

		close($log);

		return(@players);
	}

	sub seen {
		my(@players)=();
		my(%seen)=();
		my($count)=0;

		foreach my $player (&lookup('.*')) {
			unless($seen{$player->{'vaporID'}}++) {
				push(@players, $player);
				last if($count++ >= 100);
			}
		}

		return(@players);
	}

	sub upload {
		my($stage, $upload)=(IO::Handle->new, IO::Handle->new);
		my($rejected)=1;
		my($timeout)=25;
		local($_);

		return unless(keys(%Seen)>10);

		open($stage, '>', $File);
		print $stage xml::encode({
				'PlayedWithList' => {'list' => {'PlayedWith' => [&seen]}}
			});
		close($stage);

		unless(xml::valid($File)) {
			ui::slog('Generated invalid XML file, not uploading');
			&clear;
			return;
		}

		ui::slog($Curl, @Args, $timeout, '-F', "uploadedfile=\@$File", $Url);
		open($upload, '-|', $Curl, @Args, $timeout, '-F', "uploadedfile=\@$File", $Url);

		while(<$upload>) {
			chomp;
			ui::slog($_) if(m/<title>|<h2>|error|fail/i);
			$rejected=0 if(m/<h2>Completed/);
		}

		close($upload);

		$Sent=time();

		if($?) {
			ui::slog('ERROR : CURL EXIT STATUS:', $?>>8, $CURL_RV{$?>>8});
		} elsif($rejected) {
			ui::slog('WARN  : curl upload rejected by AltBouncer');
			&clear;
		} else {
			ui::slog('INFO  : curl upload to AltBouncer successful');
			&clear;
		}
	}
}

=head2 Queue

The B<alti+server> allows tasks to be queued for a future time (in seconds).
The time is a minimum, and not garunteed to be very accurate.  Each time
the main loop is executed, the queue is checked and executed after the
main loop input is completed.  When players are on-line, the pingByPlayer
log entry occurs every 5 seconds; so, your action whould (at least) be executed
within this threshold.  The Queue system also supports running functions
in the background, but only one backgrounded process may run at a time.

=cut

{	package queue;

	use Time::HiRes;

	my(%Queue)=();
	my($Id)=0;
	my($Pread, $Pwrite)=(IO::Handle->new, IO::Handle->new);
	my($Pid, $Bid)=(undef, undef);

	our($Child)=0;

	sub clear {
		%Queue=();
	}

	sub schedule(& $) {
		my($code, $delay)=@_;
		my($time)=Time::HiRes::time+$delay;

		$Id++;

		$Queue{$Id}=[$time, 1, $code];

		return($Id);
	}

	sub background(& $) {
		my($code, $delay)=@_;
		my($time)=Time::HiRes::time+$delay;

		$Id++;

		$Queue{$Id}=[$time, 0, $code];

		return($Id);
	}

	sub delete {
		my($id)=@_;

		delete($Queue{$id});
	}

	sub peek {
		my($now)=Time::HiRes::time;
		my(@tasks)=();

		foreach my $task (values(%Queue)) {
			push(@tasks, $task) if($task->[0]<$now);
		}

		return(@tasks);
	}

	sub execute {
		my($now)=Time::HiRes::time;
		my(@tasks)=();

		if($Pid && waitpid($Pid, POSIX::WNOHANG)) {
			$Pread->blocking(0);
			while(<$Pread>) {
				ui::slog($_);
			}
			close($Pread);
			ui::slog("Task $Bid completed (pid $Pid)");
			$Pid=undef;
			$Bid=undef;
		}

		foreach my $id (sort(keys(%Queue))) {
			if($Queue{$id}[0]<$now) {
				if($Queue{$id}[1]) {
					$Queue{$id}[2]->();

					push(@tasks, $id);
					delete($Queue{$id});
				} else {
					unless($Pid) {
						pipe($Pread, $Pwrite);
		
						if($Pid=fork()) {
							close($Pwrite);
							$Bid=$id;
							ui::slog("Task $Bid started (pid $Pid)");
						} else {
							$Child=1;
							close($Pread);
							ui::redirect($Pwrite);

							if(db::enabled) {
								db::reconnect('InactiveDestroy' => 1);
							}

							$Queue{$id}[2]->();

							close($Pwrite);
							exit(0);
						}

						push(@tasks, $id);
						delete($Queue{$id});
					}
				}
			}
		}

		return(@tasks);
	}

	sub next {
		my($now)=Time::HiRes::time;
		my($left)=300;

		if(%Queue) {
			$left=List::Util::min($left, map($_->[0]-$now, values(%Queue)));

			$left=0.2 if($left<0.2);
		}

		return($left);
	}
}


=head2 Altitude Game Engine

The core of B<alti+server> is the altitude game engine itself.  B<alti+server>
starts the altitude server, watches it's output and log files, and interacts
directly with it to manage the instance.

=cut

{	package server;

	use IO::Select;

	my($Logfile)	="$INSTALL_ROOT/servers/log.txt";
	my($Logfile_o)	="$INSTALL_ROOT/servers/log_old.txt";
	my($Pidfile)	="$INSTALL_ROOT/servers/server_launcher.pid";

	my(%Trigger)=();

	my($Server)=IO::Handle->new;
	my($Log)=IO::Handle->new;

	my($Streams)=IO::Select->new(\*STDIN);
	my($Launcher_pid, $Server_pid, $Tail_pid);

	my($Cu, $Cs)=(0, 0);

	our($Start)=time();

	sub start {
		my(@times);
		my($nimbly)=config::option('updateServer');

		$Streams->remove($Server);

		if($Server_pid && kill('HUP', $Server_pid)) {
			@times=utils::proc_time($Server_pid);
			$Cu+=$times[0];
			$Cs+=$times[1];

			waitpid($Server_pid, 0);
			close($Server);
			$Server_pid=undef;
		}

		rename($Logfile, $Logfile_o);

		chdir($INSTALL_ROOT);

		until(utils::ping($nimbly)) {
			ui::slog('Cannot contact updateServer', $nimbly);
			sleep(60);
		}

		$Launcher_pid=open($Server, '-|:unix', './server_launcher', '-noui');
		$Server->autoflush(1);
		$Streams->add($Server);

		$Start=time();
	}

	sub save_log {
		my($save)=join('-',
			$Logfile, 
			POSIX::strftime("%Y%m%dT%H%M", gmtime(time))
		);
		rename($Logfile, $save);
	}

	sub reopen_log {
		my($pid)=IO::Handle->new;
		my($in)=IO::Handle->new;
		my(@times);

		$Streams->remove($Log);

		if($Tail_pid && kill('HUP', $Tail_pid)) {
			@times=utils::proc_time($Tail_pid);
			$Cu+=$times[0];
			$Cs+=$times[1];

			close($Log);
			waitpid($Tail_pid, POSIX::WNOHANG);
			$Tail_pid=undef;
		}

		open($pid, '<', $Pidfile);
		$Server_pid=<$pid>;
		close($pid);

		close(STDERR);
		$Tail_pid=open($Log, '-|:unix', 'tail', '--pid', $Server_pid, '-F', $Logfile);
		$Log->autoflush(1);
		$Streams->add($Log);
	}

	#This is Linux specific, but then again so is our tail.  Both will need
	#to be fixed to run alti+server on non-linux
	sub check_tail {
		local($_)=readlink("/proc/$Tail_pid/fd/3");

		&reopen_log if(m/log_old.txt/);
	}
	
	sub data { 
		my($wait)=$_[0] || 300;
		my(@streams);
		my($hang)=time()+300;

		if($Launcher_pid && waitpid($Launcher_pid, POSIX::WNOHANG)!=0) {
			waitpid($Tail_pid, POSIX::WNOHANG);
			ui::slog('Java server failure: CRASHED');
			return(0xDEAD);
		}

		@streams=$Streams->can_read($wait);

		if(@streams || time()<$hang) {
			return(@streams);
		} else {
			ui::slog('Java server failure: HUNG');
			return(0xDEAD);
		}
	}

	sub is_log {
		return($_[0]==$Log);
	}

	sub is_output {
		return($_[0]==$Server);
	}

	sub event {
		my($line)=$Log->getline;
		chomp($line);
		log::log($line);
		return(json::decode($line));
	}

	sub output {
		return($Server->getline);
	}

	sub flush {
		my(@lines);

		$Server->blocking(0);
		@lines=$Server->getlines;
		$Server->blocking(1);

		return(join('', @lines));
	}

	sub interrupt {
		if($Tail_pid) {
			kill('CONT', $Tail_pid);
			kill('INT', $Tail_pid);
		}
		if($Server_pid) {
			kill('CONT', $Server_pid);
			kill('INT', $Server_pid);
		}
	}

	sub shutdown {
		kill('HUP', $Tail_pid) if($Tail_pid);
		kill('HUP', $Server_pid) if($Server_pid);

		$Streams->remove($Server, $Log);

		close($Server);
		close($Log);

		waitpid($Server_pid, 0);
		waitpid($Tail_pid, 0);

		$Server_pid=undef;
		$Tail_pid=undef;
	}

	sub uptime {
		return(utils::secs2hrs(utils::delta($^T)));
	}

	sub cpu_secs {
		my($pu, $ps, $cu, $cs)=times;
		my(@times);

		foreach my $pid ($Server_pid, $Tail_pid) {
			@times=utils::proc_time($pid);
			$cu+=$times[0];
			$cs+=$times[1];
		}

		return($pu+$cu+$Cu, $ps+$cs+$Cs);
	}

	sub cpu_hrs {
		return(map(utils::secs2hrs($_), &cpu_secs));
	}

	sub parse_cmd {
		local($_)=@_;
		my(@cmd)=();

		while(s/\s*"(.*?(?<!\\))"\s*|\s*"(.*?)\s*$|\s*(\S+)\s*//) {
			push(@cmd, $1 // $2 // $3);
		}

		return(@cmd);
	}

	sub altiquote {
		local($_)=@_;

		s/\\/\\\\/g;
		s/"/\\"/g;

		if(m/[\s'`]/) {
			return('"'.$_.'"');
		} else {
			return($_);
		}
	}

	sub send {
		my($command)=shift;
		my($pipe)="$INSTALL_ROOT/servers/command.txt";
		my($msg)=IO::Handle->new;
		my($event, @template, $run);

		if(exists($ALTIPLUS{$command})) {
			$event={
				'port'		=> $config::Port,
				'time'		=> (time()-$Start)*1000,
				'source'		=> '00000000-0000-0000-0000-000000000000',
				'group'		=> 'server',
				'admin'		=> 1,
				'superAdmin'	=> 1,
				'type'		=> 'consoleCommandExecute',
				'command'		=> $command,
				'arguments'	=> [],
			};

			@template=@{$ALTIPLUS{$command}{'arguments'}};
			while(@template) {
				if(@template>1) {
					push(@{$event->{'arguments'}}, shift(@_));
				} else {
					push(@{$event->{'arguments'}}, join(' ', @_));
				}
				shift(@template);
			}
	
			$HOOKS{$command}->($event, player::server());
		} else {
			foreach my $arg (@_) {
				$command.=' ';
				$command.=&altiquote($arg);
			}
		
			$run=sprintf("%d,%s,%s", $config::Port, 'console', $command);

			log::command($run);

			open($msg, '>>', $pipe);
			print $msg $run, "\n";
			close($msg);
		}
	}

	sub trigger {
		my($command, $key, @data)=@_;

		&send($command);
		push(@{$Trigger{$command}}, ["$command:$key", @data]);
	}

	sub fake_trigger {
		my($command, $key, $fake_event, @data)=@_;
		queue::schedule { $HOOKS{"$command:$key"}->($fake_event, @data) } 0;
	}

	sub override {
		my($command, $key, @data)=@_;

		push(@{$Trigger{$command}}, ["$command:$key", @data]);
	}

	sub triggers {
		my($command)=@_;

		if(exists($Trigger{$command})) {
			return(shift(@{$Trigger{$command}}));
		} else {
			return();
		}
	}

}


=head2 Maps

Altitude maps are the playing surfaces for each game.  Each one has
different modes, characteristics, and design.  Beyond what is supported
by default with Altitude, Alti+ maps can have additional characterstic
types which alter the normal behavior.

=cut

{	package hull;

	my(@Size)=();
	my(@Regions)=([]);
	my($Grid)=256;

	sub reset {
		@Size=@_;

		@Regions=([]);
		for(my($lg, $rg)=(0,$Grid); $lg<$Size[0]; $lg+=$Grid,$rg+=$Grid) {
			for(my($bg,$tg)=(0,$Grid); $bg<$Size[1]; $bg+=$Grid,$tg+=$Grid) {
				$Regions[$lg/$Grid][$bg/$Grid]=[];
			}
		}
	}

	sub isect {
		my($a1x,$a1y, $a2x,$a2y, $b1x,$b1y, $b2x,$b2y)=@_;
		my($n)=($b1x-$a1x)*($b1y-$b2y) - ($b1y-$a1y)*($b1x-$b2x);
		my($d)=($a2x-$a1x)*($b1y-$b2y) - ($a2y-$a1y)*($b1x-$b2x);
		my($x, $y, $r);

		return() if(-0.01<$d && $d<0.01);

		$r=$n/$d;
		$x=$a1x+$r*($a2x-$a1x);
		$y=$a1y+$r*($a2y-$a1y);

		if($a1x<$a2x) {
			return() if($x<$a1x || $x>$a2x);
		} else {
			return() if($x<$a2x || $x>$a1x);
		}
		if($a1y<$a2y) {
			return() if($y<$a1y || $y>$a2y);
		} else {
			return() if($y<$a2y || $y>$a1y);
		}

		return($x, $y);
	}

	sub bounds {
		my($poly)=@_;
		my($l, $b, $r, $t)=(@Size, 0, 0);

		foreach my $point (@$poly) {
			$l=$point->[0] if($point->[0]<$l);
			$r=$point->[0] if($point->[0]>$r);
			$b=$point->[1] if($point->[1]<$b);
			$t=$point->[1] if($point->[1]>$t);
		}

		return($l, $b, $r, $t);
	}

	sub cross {
		my($poly, $a1x, $a1y, $a2x, $a2y)=@_;
		my($b1x, $b1y, $b2x, $b2y);
		my($px, $py);
		my($cd, $md);

		$md=utils::distance($a1x, $a1y, $a2x, $a2y);

		for(my $i=0; $i<$#$poly; $i++) {
			($b1x, $b1y, $b2x, $b2y)=(@{$poly->[$i]}, @{$poly->[$i+1]});

			if(($px,$py)=&isect($a1x,$a1y, $a2x,$a2y, $b1x,$b1y, $b2x,$b2y)) {
				$cd=utils::distance($a1x, $a1y, $px, $py);
				$md=$cd if($cd<$md);
			}
		}

		return($md);
	}

	sub inside {
		my($poly, $x, $y)=@_;
		my($in)=0;
		my($x1, $y1, $x2, $y2);

		for(my $i=0; $i<$#$poly; $i++) {
			($x1, $y1, $x2, $y2)=(@{$poly->[$i]}, @{$poly->[$i+1]});

			return(1) if(	$y==$y1				&&
						$y==$y2				&&
						($x1<=$x || $x2<=$x)	&&
						($x<=$x2 || $x<=$x1));

			$in^=( $x1==$x2 || $x<=(($y-$y1)*($x2-$x1)/($y2-$y1)+$x1) ) if(
						$y1!=$y2				&&
						($x<=$x1 || $x<=$x2)	&&
						($y1<$y  || $y2<$y)		&&
						($y<=$y2 || $y<=$y1));
		}

		return($in);
	}

	sub zone {
		my($x, $y, $l, $b, $r, $t)=@_;

		if($y<$b) {
			if($x<$l) {
				return(1);
			} elsif($x<=$r) {
				return(2);
			} else {
				return(3);
			}
		} elsif($y<=$t) {
			if($x<$l) {
				return(4);
			} elsif($x<=$r) {
				return(5);
			} else {
				return(6);
			}
		} else {
			if($x<$l) {
				return(7);
			} elsif($x<=$r) {
				return(8);
			} else {
				return(9);
			}
		}
	}

	sub shrink {
		my($poly, $l, $b, $r, $t)=@_;
		my(@new)=();
		my($zpre, $zcur, $znxt);

		push(@new, $poly->[0]);
		$zcur=&zone(@{$poly->[0]}, $l, $b, $r, $t);
		$znxt=&zone(@{$poly->[1]}, $l, $b, $r, $t);
		for(my $i=1; $i<$#$poly; $i++) {
			$zpre=$zcur;
			$zcur=$znxt;
			$znxt=&zone(@{$poly->[$i+1]}, $l, $b, $r, $t);

			if($zcur==5) {
				push(@new, $poly->[$i]);
			} elsif($zpre!=$zcur || $zcur!=$znxt) {
				push(@new, $poly->[$i]);
			}
		}
		push(@new, $poly->[-1]);
		
		return(\@new);
	}

	sub add {
		my($hull)=@_;
		my($x, $y)=($hull->{'x'}, $hull->{'y'});
		my($line)=$hull->{'texturedPoly'}{'hull'};
		my($poly)=[];
		my($lp, $bp, $rp, $tp);

		return unless($hull->{'collidable'} eq 'true');

		$line=~s/![-0-9]+,//;
		while($line=~s/([-.\d]+),([-.\d]+),//) {
			push(@$poly, [$1+$x, $2+$y]);
		}
		push(@$poly, $poly->[0]);

		($lp, $bp, $rp, $tp)=&bounds($poly);

		for(my($lg, $rg)=(0,$Grid); $lg<$Size[0]; $lg+=$Grid,$rg+=$Grid) {
			last if($rp<$lg);
			next if($lp>$rg);

			for(my($bg,$tg)=(0,$Grid); $bg<$Size[1]; $bg+=$Grid,$tg+=$Grid) {
				next if($bp>$tg);
				last if($tp<$bg);

				push(@{$Regions[$lg/$Grid][$bg/$Grid]}, &shrink($poly, $lg, $bg, $rg, $tg));
			}
		}
	}

	sub near {
		my($x)=int($_[0]/$Grid);
		my($y)=int($_[1]/$Grid);

		return(@{$Regions[$x][$y]});
	}

	sub in_wall {
		my($x, $y);

		if(@_==2) {
			($x, $y)=@_;
		} elsif(ref($_[0]) eq 'HASH') {
			if(exists($_[0]{'victimPositionX'})) {
				($x, $y)=@{$_[0]}{'victimPositionX','victimPositionY'};
			} elsif(exists($_[0]{'postionX'})) {
				($x, $y)=@{$_[0]}{'positionX','positionY'};
			} else {
				return(undef);
			}
		} else {
			return(undef);
		}

		foreach my $poly (&near($x, $y)) {
			return($poly) if(&inside($poly, $x, $y));
		}
		return(undef);
	}

	sub hit_wall {
		my($x1,$y1, $x2,$y2);
		my(@polys)=();
		my($mind, $curd);

		if(@_==4) {
			($x1,$y1, $x2,$y2)=@_;
		} elsif(ref($_[0]) eq 'HASH') {
			if(exists($_[0]{'victimPositionX'})) {
				($x1, $y1)=@{$_[0]}{'victimPositionX','victimPositionY'};
				($x2, $y2)=@_[1,2];
			} elsif(exists($_[0]{'postionX'})) {
				($x1, $y1)=@{$_[0]}{'positionX','positionY'};
				($x2, $y2)=@_[1,2];
			} else {
				return(undef);
			}
		} else {
			return(undef);
		}

		$mind=utils::distance($x1,$y1, $x2,$y2);
		push(@polys, &near($x1, $y1));
		if(int($x1/$Grid)!=int($x2/$Grid) || int($y1/$Grid)!=int($y2/$Grid)) {
			push(@polys, &near($x2, $y2));
		}

		foreach my $poly (@polys) {
			if($curd=&cross($poly, $x1,$y1, $x2,$y2)) {
				$mind=$curd if($curd<$mind);
			}
		}

		return($mind);
	}

	sub safe_spawn {
		my($px, $py, $vx, $vy, $nx, $ny);
		my(@angles)=qw(20 -20 40 -40 60 -60 80 -80 100 -100 120 -120 140 -140 160 -160 180);
		my($was, $try);
		my($poly);

		if(@_==4) {
			($px, $py, $vx, $vy)=@_;
			$was=utils::direction($vx, $vy);
		} elsif(@_==3) {
			($px, $py, $was)=@_;
		} elsif(@_==2) {
			($px, $py)=@_;
			$was=0;
		} elsif(ref($_[0]) eq 'HASH') {
			if(exists($_[0]{'victimPositionX'})) {
				($px, $py)=@{$_[0]}{'victimPositionX','victimPositionY'};
				($vx, $vy)=@{$_[0]}{'victimVelocityX','victimVelocityY'};
				$was=utils::direction($vx, $vy);

				if(abs($vx)<3 && abs($vy)<3 && ($poly=&in_wall($px, $py))) {
					foreach my $a (@angles) {
						($nx, $ny)=utils::course($px, $py, $a, 15);
						unless(&inside($poly, $nx, $ny)) {
							($px, $py)=($nx, $ny);
							last;
						}
					}
				} else {
					$px-=$vx;
					$py-=$vy;
				}
			} elsif(exists($_[0]{'positionX'})) {
				($px, $py)=@{$_[0]}{'positionX','positionY'};
				$was=0;
			} else {
				return(0, 0, 0);
			}
		} else {
			return(0, 0, 0);
		}

		$try=$was;
		while(	&in_wall(utils::course($px, $py, $try, 90)) ||
				&in_wall(utils::course($px, $py, $try, 60)) ||
				&in_wall(utils::course($px, $py, $try, 30))
		) {
			if(@angles) {
				$try=utils::angle($was+shift(@angles));
			} else {
				ui::slog("could not find a good angle at $px,$py");
				return($px, $py, utils::angle($was+180));
			}
		}

		return($px, $py, $try);
	}

}


{	package map;

	my($Map)=undef;

	my($Cpu)=0;
	my($Ds)=undef;
	my($Start)=undef;
	my(%Pickups)=();
	my(%Powerups)=();
	my(%Turrets)=();
	my(%Bases)=();
	my(%Goals)=();
	my(@Choices)=();

	our($Xmid, $Ymid)=(0, 0);

	my(%Teams)=(
		2	=> 'spec',	'spec'	=> 2,
		3	=> 'red',		'red'	=> 3,
		4	=> 'blue',	'blue'	=> 4,
		5	=> 'green',	'green'	=> 5,
		6	=> 'yellow',	'yellow'	=> 6,
		7	=> 'orange',	'orange'	=> 7,
		8	=> 'purple',	'purple'	=> 8,
		9	=> 'azure',	'azure'	=> 9,
		10	=> 'pink',	'pink'	=> 10,
		11	=> 'brown',	'brown'	=> 11,
	);
	my($Color_re)=join('|', grep(length>2, keys(%Teams)));

	sub file {
		my($mapdir)=config::option('mapDir');

		if($mapdir) {
			return("$INSTALL_ROOT/maps/$mapdir/$Map->{'map'}.altx");
		} else {
			return("$INSTALL_ROOT/maps/$Map->{'map'}.altx");
		}
	}

	sub definition {
		my($map)=@_;
		my($mapdir)=config::option('mapDir');
		my($debug)=stash::get('debug', 'server');
		my($cache)="$INSTALL_ROOT/maps/cache/$mapdir";
		my($file)=<$cache/$map.altx/*.alte>;
		my(%parser)=(
			'SuppressEmpty'	=> 1,
			'ForceArray'		=> [
								'View',
								'spawnPoints',
								'powerupSpawner',
								'Goal',
								'Turret',
								'Base',
								'String',
								'geometry',
							],
			'ValueAttr'		=> [ 'value', 'index' ],
			'GroupTags'		=> {
				'views'			=> 'View',
				'selectedPowerups'	=> 'String',
				'image'			=> 'path'
			}
		);
		my($ds);

		if(-r $file) {
			$ds=xml::decode($file, %parser);
			if($debug) {
				$debug=Data::Dumper::Dumper($ds);
				$debug=~s/^\$VAR1/$map/;
				$debug=~s/        /  /g;
				ui::slog($debug);
			}
			return($ds);
		} else {
			ui::slog("!!!  I could not find a .alte file in your  !!!");
			ui::slog("!!!  $cache  !!!");
			ui::slog("!!!  Your map cache is broken, this is bad  !!!");
			ui::slog("!!!  I will do my best, but without seeing  !!!");
			ui::slog("!!!  the map definition, I am blind to the  !!!");
			ui::slog("!!!  location of pickups.                   !!!");

			if(-d "$cache/$map.altx") {
				if(-w "$cache/$map.altx") {
					ui::slog("Your cache directory exists, why isn't there .alte file?");
				} else {
					ui::slog("$cache/$map.altx isn't writable");
				}
			} else {
				ui::slog("$cache/$map.altx does not exist");
				if(-d $cache) {
					ui::slog("$cache isn't writable") unless(-w $cache);
				} else {
					ui::slog("$cache does not exist");
				}
			}

			return(undef);
		}
	}

	sub set_type {
		local($_)=@_;

		if(m/(^|_)flag(_|$)/) {
			$Map->{'type'}='flag';
		} elsif(m/(^|_)zone(_|$)/) {
			$Map->{'type'}='zone';
		} elsif(m/(^|_)ra?ce(_|$)/) {
			$Map->{'type'}='race';
		} elsif(m/(^|_)coop(_|$)/) {
			$Map->{'type'}='coop';
		} elsif(m/(^|_)ruin(_|$)/) {
			$Map->{'type'}='ruin';
		} elsif(m/(^|_)mdg(_|$)/) {
			$Map->{'type'}='mdg';
		} elsif(m/(^|_)1lh(_|$)/) {
			$Map->{'type'}='1lh';
		} else {
			$Map->{'type'}='std';
		}

		return($Map->{'type'});
	}

	sub start	{
		return($Map->{'time'});
	}

	sub busy {
		$Map->{'idle'}=time();
	}

	sub idle {
		return(0) unless($Map->{'map'});
		return(utils::delta($Map->{'idle'}));
	}

	sub choices {
		@Choices=@_;
	}

	sub choosen {
		my($choice)=@_;
		my($rv)=undef;

		foreach my $map (@Choices) {
			$rv=$choice if($choice eq $map);
		}

		@Choices=();

		return($rv);
	}

	sub teams {
		if(@_) {
			return(($Map->{'leftTeam'}, $Map->{'rightTeam'})=@_);
		} else {
			return($Map->{'leftTeam'}, $Map->{'rightTeam'});
		}
	}

	sub _value_or_query {
		my($key)=shift;

		if(@_) {
			return(grep($Map->{$key} eq $_, @_)>0);
		} else {
			return($Map->{$key});
		}
	}

	sub name		{ &_value_or_query('map', @_);		}
	sub mode		{ &_value_or_query('mode', @_);		}
	sub type		{ &_value_or_query('type', @_);		}

	sub left		{
		foreach(@_) {
			return(1) if(m/^$Teams{$Map->{'leftTeam'}}$/i);
			return(1) if(m/^(left|<|all|both|\*|0)$/i);
		}
		&_value_or_query('leftTeam', @_);
	}

	sub right		{
		foreach(@_) {
			return(1) if(m/^$Teams{$Map->{'rightTeam'}}$/i);
			return(1) if(m/^(right|>|all|both|\*|1)$/i);
		}
		&_value_or_query('rightTeam', @_);
	}

	sub spec		{
		if(@_) {
			foreach(@_) {
				return(1) if(m/^(spec.*|\^|all|\*|-1|$Teams{'spec'})$/i);
			}
			return(0);
		} else {
			return($Teams{'spec'});
		}
	}

	sub side		{
		my($p)=@_;

		if(&left($p->{'team'})) {
			return('left');
		} elsif(&right($p->{'team'})) {
			return('right');
		} else {
			return(undef);
		}
	}

	sub team_color {
		my($team)=@_;

		if($team=~m/$Color_re/i) {
			return($team);
		} elsif(&left($team)) {
			return($Teams{$Map->{'leftTeam'}});
		} elsif(&right($team)) {
			return($Teams{$Map->{'rightTeam'}});
		} elsif(&spec($team)) {
			return('spec');
		} elsif(utils::is_int($team)) {
			return($Teams{$team});
		} else {
			return('unknown');
		}
	}

	sub team_number {
		my($team)=@_;

		if($team=~m/$Color_re/i) {
			return($Teams{$team});
		} elsif(&left($team)) {
			return($Map->{'leftTeam'});
		} elsif(&right($team)) {
			return($Map->{'rightTeam'});
		} elsif(&spec($team)) {
			return(2);
		} elsif(utils::is_int($team)) {
			return($team);
		} else {
			return(undef);
		}
	}

	sub team_symbol {
		my($team)=@_;

		if(&left($team)) {
			return('<');
		} elsif(&right($team)) {
			return('>');
		} elsif(&spec($team)) {
			return('^');
		} else {
			return('?');
		}
	}

	sub team {
		my($p, $team)=@_;

		return($p->{'team'} == &team_number($team));
	}

	sub timer {
		my($limit)=$Ds->{'levelModeConfig'}{'objectiveGameTimeSeconds'};
		my($used)=time()-$Start;

		if(&mode('ball', 'ffa', 'tbd', 'tdm')) {
			$limit=$config::Launcher{'roundTime'}{&mode};
		}

		if(wantarray) {
			return($limit, $used);
		} else {
			return($limit-$used);
		}
	}

	sub powerup_lookup {
		my($xy)=join(',', @_[0,1]);

		if(exists($Pickups{$xy})) {
			return(@{$Pickups{$xy}});
		} else {
			return(undef);
		}
	}

	sub powerup {
		my($e, @types)=@_;
		my($xy)=join(',', @$e{'positionX','positionY'});

		if(exists($Pickups{$xy})) {
			if(@types) {
				foreach my $type (@types) {
					return($e->{'powerup'}) if($e->{'powerup'}=~m/$type/i);
				}
				return(undef);
			} else {
				return(@{$Pickups{$xy}});
			}
		} elsif(!defined($Ds)) {
			return(undef) if($e->{'velocityX'} || $e->{'velocityY'});
			return(undef) if($e->{'positionX'}=~m/\./);
			return(undef) if($e->{'positionY'}=~m/\./);

			if(@types) {
				foreach my $type (@types) {
					return($e->{'powerup'}) if($e->{'powerup'}=~m/$type/i);
				}
				return(undef);
			} else {
				return($e->{'powerup'});
			}
		} else {
			return(undef);
		}
	}

	sub powerups {
		my(@powerups)=();

		foreach my $coords (keys(%Pickups)) {
			push(@powerups, [$coords, @{$Pickups{$coords}}]);
		}

		return(@powerups);
	}

	sub has_powerup {
		my($type)=@_;

		return($Powerups{$type});
	}

	sub spawn_points {
		my($spawns)=$Ds->{'views'}{'Game'}{'spawnPoints'}[0]{'spawnPoints'};

		if(ref($spawns) eq 'ARRAY') {
			return(@$spawns);
		} else {
			return();
		}
	}

	sub bases {
		my($bases)=$Ds->{'views'}{'Game'}{'Base'}[0]{'Base'};

		if(ref($bases) eq 'ARRAY') {
			return(@$bases);
		} else {
			return();
		}
	}

	sub turrets {
		my($turrets)=$Ds->{'views'}{'Game'}{'Turret'}[0]{'Turret'};

		if(ref($turrets) eq 'ARRAY') {
			return(@$turrets);
		} else {
			return();
		}
	}

	sub register_goal {
		my($obj)=@_;
		my(@goal)=utils::transform($obj->{'transformation'}, -25, 0);
		my(@box)=utils::transform($obj->{'transformation'}, 60, 0);

		$goal[0]+=$obj->{'x'};
		$goal[1]+=$obj->{'y'};

		$box[0]+=$obj->{'x'};
		$box[1]+=$obj->{'y'};

		$Goals{$obj->{'team'}}{'goal'}=[@goal];

		#The goal box is really a circle:
		$Goals{$obj->{'team'}}{'box'}=[@box];
		$Goals{$obj->{'team'}}{'radius'}=utils::distance(@goal, @box);
	}

	sub goalbox {
		my($e)=@_;
		my($x, $y)=@$e{'positionX','positionY'};
		my($left, $right)=(&left(), &right());
		my($box, $radius);
		
		if($box=$Goals{$left}{'box'}) {
			$radius=$Goals{$left}{'radius'};

			if(utils::distance(@$box, $x, $y) < $radius) {
				return('left');
			}
		}

		if($box=$Goals{$right}{'box'}) {
			$radius=$Goals{$right}{'radius'};

			if(utils::distance(@$box, $x, $y) < $radius) {
				return('right');
			}
		}

		return();
	}

	sub going_in {
		my($e)=@_;
		my($cx, $cy)=@$e{'positionX','positionY'};
		my($vx, $vy)=@$e{'velocityX','velocityY'};
		my($team, $goal);
		my($catch, $miss);

		#Extend the travel line by two intervals:
		$vx*=2;
		$vy*=2;

		if($team=&goalbox($e)) {
			if($goal=$Goals{&team_number($team)}{'goal'}) {
				$catch=utils::distance(@$goal, $cx, $cy);
				$miss=utils::distance(@$goal, $cx+$vx, $cy+$vy);

				return(1) if($miss < $catch);
			}
		}

		return(0);
	}

	sub cpu {
		return(List::Util::sum(server::cpu_secs)-$Cpu);
	}

	sub new {
		my($mapref)=@_;
		my($obj);

		$Map=$mapref;
		&set_type($Map->{'map'});
		$Map->{'idle'}=time();

		$Cpu=List::Util::sum(server::cpu_secs);
		$Ds=&definition($Map->{'map'});
		$Start=time();
		%Pickups=();
		%Powerups=();
		%Turrets=();
		%Bases=();
		%Goals=();

		log::start(@$Map{'map', 'mode', 'type'});

		$Xmid=$Ds->{'views'}{'Game'}{'bounds'}{'maxX'}/2;
		$Ymid=$Ds->{'views'}{'Game'}{'bounds'}{'maxY'}/2;

		$obj=$Ds->{'views'}{'Game'}{'Goal'}[0]{'Goal'};
		if(ref($obj) eq 'ARRAY') {
			foreach my $goal (@$obj) {
				&register_goal($goal);
			}
		}

		$obj=$Ds->{'views'}{'Game'}{'powerupSpawner'}[0]{'powerupSpawner'};
		if(ref($obj) eq 'ARRAY') {
			foreach my $pu (@$obj) {
				$Pickups{"$pu->{'x'},$pu->{'y'}"}=$pu->{'selectedPowerups'};

				foreach my $kind (@{$pu->{'selectedPowerups'}}) {
					push(@{$Powerups{$kind}}, "$pu->{'x'},$pu->{'y'}");
				}
			}
		}

		$obj=$Ds->{'views'}{'Game'}{'Turret'}[0]{'Turret'};
		if(ref($obj) eq 'ARRAY') {
			foreach my $tu (@$obj) {
				$Turrets{"$tu->{'x'},$tu->{'y'}"}=$tu->{'team'};
			}
		}

		$obj=$Ds->{'views'}{'Game'}{'Base'}[0]{'Base'};
		if(ref($obj) eq 'ARRAY') {
			foreach my $ba (@$obj) {
				$Bases{"$ba->{'x'},$ba->{'y'}"}=$ba->{'team'};
			}
		}

		hull::reset(@{$Ds->{'views'}{'Game'}{'bounds'}}{'maxX', 'maxY'});
		$obj=$Ds->{'views'}{'Game'}{'geometry'}[0]{'geometry'};
		if(ref($obj) eq 'ARRAY') {
			foreach my $geometry (@$obj) {
				hull::add($geometry);
			}
		}
	}

	sub end {
		ui::slog('INFO  : CPU used by', &name, ':', utils::secs2mins(&cpu));
	}


}

=head2 Players

The B<alti+server> wrapper initiates the altitude game engine to ensure
it has full knowledge of it's state, and the users logged into the server.
Since it manages starts, restarts, and shutdowns. it sees every user login
and logoff.  This is used to keep active player profiles.  Statistics
are kept on players, and information about what team they are on, etc.
is updated with them as the games progress.

=cut

{	package player;

	my(@Players)=();
	my(@Bots)=();
	my(@Admins)=();
	my(@Moderators)=();
	my(%Pdb)=();

	sub init {
		@Players=();
		@Bots=();
		@Admins=();
		@Moderators=();
		%Pdb=();
	}

	sub server {
		return({
			'nickname'	=> 'server',
			'vaporId'		=> '00000000-0000-0000-0000-000000000000',
			'player'		=> -1,
			'team'		=> -1,
			'isBot'		=> 1,
			'superAdmin'	=> 1,
			'moderator'	=> 1,
		});
	}

	sub add {
		my($p)=@_;
		my($sas)=config::option('superAdmins');
		my($mods)=config::option('moderators');
		my($db);

		$p->{'joined'}=1;
		$p->{'alive'}=0;
		$p->{'infractions'}=0;

		if($p->{'nickname'}=~m/^Bot ([1-9]|[1-2][0-9])$/) {
			$p->{'isBot'}=1;
			push(@Bots, $p);
		} else {
			$p->{'isBot'}=0;
			push(@Players, $p);
		}

		if(config::admin_vid($p->{'vaporId'})) {
			push(@Admins, $p);
			$p->{'admin'}=1;
		} else {
			$p->{'admin'}=0;
		}

		if($sas=~m/(^|;)$p->{'vaporId'}(;|$)/) {
			$p->{'superAdmin'}=1;
		} else {
			$p->{'superAdmin'}=0;
		}

		if($mods=~m/(^|;)$p->{'vaporId'}(;|$)/) {
			$p->{'moderator'}=1;
		} else {
			$p->{'moderator'}=0;
		}

		unless($p->{'isBot'}) {
			if(db::enabled) {
				$db=db::player($p);

				foreach my $key ('id', 'name', 'block') {
					$p->{$key}=$db->{$key};
				}
				$p->{'lastSeen'}=$db->{'seen'};
				$p->{'id'}||=db::nextid;

				db::player($p, {
						'vaporid'		=> $p->{'vaporId'},
						'id'			=> $p->{'id'},
						'nickname'	=> $p->{'nickname'},
						'seen'		=> time(),
						'ip'			=> $p->{'ip'},
						'block'		=> $p->{'block'}//0,
					});
		
				db::aliases($p, $p->{'nickname'});
			} else {
				$p->{'block'}=stash::get('block', $p->{'vaporId'}, 'player');
			}
		}

		$Pdb{$p->{'nickname'}}	=
		$Pdb{$p->{'player'}}	=
		$Pdb{$p->{'vaporId'}}	= $p;
	}

	sub name {
		my($p)=@_;

		if($p) {
			return($p->{'name'} || $p->{'nickname'});
		} else {
			return();
		}
	}

	sub rename {
		my($old, $new)=@_;
		my($p)=$Pdb{$old};

		$Pdb{$new}=$p;
		delete($Pdb{$old});

		$p->{'nickname'}=$new;

		db::insert('aliases',
			{ 'vaporid' => $p->{'vaporId'}, 'nickname' => $new });

		db::update('player', qq{ vaporid='$p->{"vaporId"}' },
			{ 'nickname' => $new });
	}

	sub remove {
		my($p)=@_;

		delete($Pdb{$p->{'nickname'}});
		delete($Pdb{$p->{'vaporId'}});
		delete($Pdb{$p->{'player'}});

		for(my $i=0; $i<@Players; $i++) {
			if($Players[$i]==$p) {
				splice(@Players, $i, 1);
				last;
			}
		}

		for(my $i=0; $i<@Admins; $i++) {
			if($Admins[$i]==$p) {
				splice(@Admins, $i, 1);
				last;
			}
		}

		$p->{'joined'}=0;
		$p->{'alive'}=0;
		delete($p->{'player'});
	}

	sub lookup {
		my($player)=@_;

		return(undef) if($player eq '00000000-0000-0000-0000-000000000000');

		if(length($player)>0 && exists($Pdb{$player})) {
			return($Pdb{$player});
		} else {
			return(undef);
		}
	}

	sub infraction {
		my($p, $value)=@_;
		my($count)=config::option('infractions');
		my($nick)=$p->{'nickname'};

		$p->{'infractions'}+=$value;
		if($p->{'infractions'}>$count) {
			if($p->{'admin'}) {
				if($p->{'infractions'}>$count*2) {
					$CONSOLE{'server'}->('del', 'admins', $p->{'vaporId'});
					server::send('restartServer');
					chat::whisper($p, 'Now look what you made me do');
				} else {
					chat::whisper($p, 'Some decorum, please', player::name($p));
				}
				return(int($p->{'infractions'}));
			} else {
				server::send('kick', $nick);
				return(int($p->{'infractions'}));
			}
		} else {
			return(int($p->{'infractions'}));
		}
	}

	sub forgive {
		my($p)=@_;

		if($p->{'infractions'}>1) {
			$p->{'infractions'}--;
		} elsif($p->{'infractions'}>0) {
			$p->{'infractions'}=0;
		}
	}

	sub event_search {
		my($e)=@_;
		my($p);

		$p=	&lookup($e->{'nickname'})	||
			&lookup($e->{'player'})		||
			&lookup($e->{'vaporId'})		||
			&lookup($e->{'source'})		;

		$p=$e if(	!$p					&&
				exists($e->{'nickname'})	&&
				exists($e->{'player'})	&&
				exists($e->{'vaporId'})	);

		return($p);
	}

	sub list {
		my($filter)=@_;

		if(map::left($filter)) {
			return(grep(map::left($_->{'team'}), @Players));
		} elsif(map::right($filter)) {
			return(grep(map::right($_->{'team'}), @Players));
		} elsif(map::spec($filter)) {
			return(grep(map::spec($_->{'team'}), @Players));
		} else {
			return(@Players);
		}
	}

	sub bots {
		my($filter)=@_;

		if(map::left($filter)) {
			return(grep(map::left($_->{'team'}), @Bots));
		} elsif(map::right($filter)) {
			return(grep(map::right($_->{'team'}), @Bots));
		} elsif(map::spec($filter)) {
			return(grep(map::spec($_->{'team'}), @Bots));
		} else {
			return(@Bots);
		}
	}

	sub count {
		return(scalar(&list(@_)));
	}

	sub id {
		my($p)=@_;
		my(@fields)=qw(player vaporId name nickname team);

		return({ map(($_ => $p->{$_}), @fields) });
	}

	sub handicap {
		my($team)=@_;
		my($left)=scalar(grep(map::left($_->{'team'}), @Players));
		my($right)=scalar(grep(map::right($_->{'team'}), @Players));

		return(0) unless($left && $right);

		if(map::left($team)) {
			return($right/$left);
		} elsif(map::right($team)) {
			return($left/$right);
		} else {
			return(0);
		}
	}

	sub none {
		return(@Players==0);
	}

	sub values {
		my($key)=@_;

		return(map($_->{$key}, @Players));
	}

	sub admins {
		return(@Admins);
	}

	sub moderators {
		return(@Moderators);
	}

	sub reset {
		foreach my $player (&list) {
			delete($player->{'team'});
		}
	}

}

=head3 Player names and nicknames

Players can set their nicknames once per day, and they often have clan
designators.  This isn't ideal for keeping records and identifying players.
When a database is used by B<alti+server>, it keeps a record for each
player which has a more permanent name available.  Keeping track of what
this name should be isn't trivial.  Rather than re-invent the wheel, require
players to maintain multiple systems, and have to deal with inconsistencies
across different environments, B<alti+server> defers to ladder.  Names
are pulled from ladder, and changes in ladder are reflected here.

=cut

{	package planeball;

	eval('use HTML::Parser');

	my($Curl)=utils::which('curl', 'good', 'PlaneBall support disabled');
	my($Players)='https://planeball.com/players/';

	my($In)=0;
	my(@Head)=();
	my($Data)={};
	my($Index)=0;
	my($Mode);

	sub _update_db {
		my($data)=@_;
		my($player, $other, $nickname, $update);
		my($id);

		return unless($data->{'Vapor'} && $data->{'AKA'});

		$data->{'AKA'}=~s/^\@//;

		($other)=db::select('player', qq{name='$data->{"AKA"}'});
		($player)=db::select('player', qq{vaporid='$data->{"Vapor"}'});

		if(ref($player) && $player->{'id'}) {
			$id=$player->{'id'};
		} elsif(ref($other) && $other->{'id'}) {
			$id=$other->{'id'};
		} else {
			$id=db::nextid;
		}

		unless($player && $player->{'name'} eq $data->{'AKA'}) {
			$nickname=$player->{'nickname'} || $data->{'Nickname'};
			$update={
				'vaporid'  => $data->{'Vapor'},
				'id'       => $id,
				'name'     => $data->{'AKA'},
				'nickname' => $nickname,
				'block'    => $player->{'block'}//0,
			};

			db::upsert('player', qq{vaporid='$data->{"Vapor"}'}, $update);

			ui::slog("Updated $data->{'Vapor'} ($nickname) to $data->{'AKA'}");
		}
	}

	sub _state {
		my($event, $tag, $attr)=@_;

		if($tag eq 'table' && $attr->{'id'} eq 'table_player_list') {
			if($event eq 'start') {
				$In=1;
			} elsif($event eq 'end') {
				$In=0;
			}
		} elsif($In && $tag eq 'tr') {
			if($event eq 'start') {
				$Index=0;
				$Data={};
			} elsif($event eq 'end') {
				&_update_db($Data) if(%$Data);
			}
		} elsif($In && $tag eq 'th') {
			if($event eq 'start') {
				$Mode='header';
			} elsif($event eq 'end') {
				$Index++;
			}
		} elsif($In && $tag eq 'td') {
			if($event eq 'start') {
				$Mode='data';
			} elsif($event eq 'end') {
				$Index++;
			}
		}
	}

	sub _data {
		my($text)=@_;

		return unless($In);

		if($Mode eq 'header') {
			$Head[$Index]=$text;
		} elsif($Mode eq 'data') {
			$Data->{$Head[$Index]}=$text;
		}
	}

	sub update {
		my($get)=IO::Handle->new;
		my($p)=eval('HTML::Parser->new');

		unless($p) {
			ui::slog('ERROR HTML::Parser perl module not installed');
			return(undef);
		}

		unless($Curl) {
			ui::slog('ERROR curl command-line binary not found');
			return(undef);
		}

		unless(db::enabled) {
			ui::slog('ERROR This function requires a database backend');
			return(undef);
		}

		$In=0;

		$p->report_tags(qw(table tr th td));
		$p->handler('start' => \&_state, 'event, tagname, attr');
		$p->handler('end'   => \&_state, 'event, tagname, attr');
		$p->handler('text'  => \&_data,  'dtext');

		db::begin;

		open($get, '-|', $Curl, '-s', $Players);
		while(<$get>) {
			$p->parse($_);
		}
		close($get);
		$p->eof;

		db::commit;
	}

}

=head2 Server to Player communication

The server will periodically communicate with users about settings, events,
and enhanced game related features.  Communication can be to all users,
teams, or to individual users.  The communication can also be for
debugging or to make funny comments.

=cut

{	package chat;

	my($Delay)=0;

	sub all {
		my($msg)=join(' ', @_);
		server::send('serverMessage', $msg);
	}

	sub allf {
		my($fmt)=shift;
		server::send('serverMessage', sprintf($fmt, @_));
	}

	sub team {
		my($team)=shift;
		my($msg)=join(' ', @_);
		my($any)=0;

		if(ref($team) eq 'HASH' && exists($team->{'team'})) {
			$team=$team->{'team'};
		}

		foreach my $player (player::list($team)) {
			server::send('serverWhisper', $player->{'nickname'}, $msg);
			$any=1;
		}

		ui::chat_log(map::team_symbol($team), 'server', $msg) if($any);
	}

	sub admin {
		my($msg)=join(' ', @_);

		foreach my $admin (player::admins) {
			server::send('serverWhisper', $admin->{'nickname'}, $msg);
		}
	}

	sub moderator {
		my($msg)=join(' ', @_);

		foreach my $admin (player::admins, player::moderators) {
			server::send('serverWhisper', $admin->{'nickname'}, $msg);
		}
	}

	sub whisper {
		my($p)=shift;
		my($msg)=join(' ', @_);

		if($p->{'isBot'}) {
			ui::slog('|', $msg);
		} else {
			ui::chat_log($p->{'nickname'}, 'server', $msg);
			server::send('serverWhisper', $p->{'nickname'}, $msg);
		}
	}

	sub whisperf {
		my($p)=shift;
		my($fmt)=shift;
		my($msg)=sprintf($fmt, @_);

		&whisper($p, $msg);
	}

	sub debug {
		my($debug)=stash::get('debug', 'server');
		my($msg);
		
		if($debug) {
			foreach my $stmt (@_) {
				if(ref($stmt)) {
					if(ref($stmt) eq 'HASH' && exists($stmt->{'nickname'})) {
						$msg.=$stmt->{'nickname'};
					} else {
						$msg.=json::encode($stmt);
					}
				} else {
					$msg.=$stmt;
				}
				$msg.=' ';
			}

			chat::admin($msg);

			ui::chat_log('debug', 'server', $msg);

		}
	}

	sub laud {
		&all(@_) if(config::option('snarkChance')>0);
	}

	sub snark {
		my($p)=shift;
		my($time)=time();

		return if($p->{'isBot'});

		if( config::option('snarkChance')>0 && $time>$p->{'snarkGrace'} ) {
			$p->{'snarkGrace'}=$time+10;
			&all(@_);
		}
	}

	sub laudy {
		my($multiplier)=config::option('snarkChance')/4;

		return(0) unless(int(rand($multiplier))==0);

		return(1);
	}

	sub snarky {
		my($multiplier)=config::option('snarkChance');
		my($time)=time();

		return(0) unless($multiplier>0);
		return(0) unless(int(rand($multiplier * player::count))==0);
		return(0) unless($time>$Delay);

		$Delay=$time+3;
		return(1);
	}
}

=head2 Records

The server can keep track of records on a per-map basis.  Records will be
displayed at the completion of a map and players will be congratulated if
they make the top 5.

=cut

{	package records;

	my(%Helpers); tie %Helpers, 'Tie::RefHash';
	my($Start)=0;
	my($Winner)=undef;
	my($Destroy)=undef;


	sub fmt_record {
		my($place, $record, $date, $players)=@_;

		if($players) {
			return(sprintf('%s : %s  (%s %s)',
					utils::nth($place),
					utils::secs2mins($record),
					utils::date($date),
					$players,
				));
		} elsif($date) {
			return(sprintf('%s : %s  (%s)',
					utils::nth($place),
					utils::secs2mins($record),
					utils::date($date),
				));
		} else {
			return(sprintf('%s : %s',
					utils::nth($place),
					utils::secs2mins($record),
				));
		}
	}

	sub print {
		my(%opt)=(
				'player'	=> undef,
				'delta'	=> undef,
				'short'	=> 0,
				@_
			);
		my($i)=1;
		my($records, $time);
		
		if(db::enabled) {
			$records=db::records(map::name);
			splice(@$records, 5);
		} else {
			$records=stash::get(map::name, 'records');
		}

		return unless(ref($records) eq 'ARRAY');

		foreach my $record (@$records) {
			if(ref($opt{'player'})) {
				if($opt{'short'}) {
					chat::whisper($opt{'player'},
						&fmt_record($i++, $record->[0]));
				} else {
					chat::whisper($opt{'player'},
						&fmt_record($i++, @$record));
				}
			} else {
				if($opt{'short'}) {
					chat::all(&fmt_record($i++, $record->[0]));
				} else {
					chat::all(&fmt_record($i++, @$record));
				}
			}
		}

		if($opt{'delta'}) {
			$time=($opt{'delta'} - $Start)/$config::Clock;
			if(ref($opt{'player'})) {
				chat::whisper($opt{'player'}, 'you',  ':', utils::secs2mins($time));
			} else {
				chat::all('you',  ':', utils::secs2mins($time));
			}
		}
	}

	sub mark {
		my($e)=@_;
		my($i, $i2)=(1, 1);
		my($records);
		
		if(db::enabled) {
			$records=db::records(map::name);
			splice(@$records, 5);
		} else {
			$records=stash::get(map::name, 'records');
		}

		$Start=$e->{'time'};

		return unless(ref($records) eq 'ARRAY');

		foreach my $record (@$records) {
			if(map::mode('1de') && map::type('coop')) {
				if(map::has_powerup('Bomb')) {
					queue::schedule {
						chat::all(&fmt_record($i++, $record->[0]));
					} $record->[0]-3
				}
				queue::schedule {
					chat::all(&fmt_record($i2++, $record->[0]), '(plant)')
				} $record->[0]-24 if($record->[0]>30);
			} else {
				queue::schedule {
					chat::all(&fmt_record($i++, $record->[0]));
				} $record->[0]-3;
			}
		}
	}

	sub destroy {
		my($e, $p)=@_;
		my($team)=$p->{'team'};
		my($assign);

		return unless($e->{'target'} eq 'base');
		return unless(map::left($team) || map::right($team));

		$assign=map::team_number(stash::get('assignTeam', map::name, 'map'));
		return if($assign && $team!=$assign);


		$Destroy=$e->{'time'};
	}

	sub help {
		my($p, $points)=@_;

		return unless($p->{'nickname'});

		unless(exists($Helpers{$p})) {
			foreach my $helper (keys(%Helpers)) {
				if($helper->{'vaporId'} eq $p->{'vaporId'}) {
					$Helpers{$p}=$Helpers{$helper};
					delete($Helpers{$helper});
					last;
				}
			}
		}

		$Helpers{$p}+=$points;
	}

	sub team {
		return(sort({ $Helpers{$b} <=> $Helpers{$a} } player::list(@_)));
	}

	sub enter {
		my($e)=@_;
		my(@types)=split(m/\W+/, config::option('recordsTypes'));
		my($assign)=map::team_number(stash::get('assignTeam', map::name, 'map'));
		my($win)=ball::winner();
		my($min_players)=scalar(map::spawn_points);
		my(@holder)=(time());
		my($place)=1;
		my($save)=1;
		my($etal)={'nickname' => '...'};
		my($records)=[];
		my($time, @nicks);

		return unless(map::type(@types));

		$save=0 if(!defined($assign) && map::type('ruin'));

		$save=0 if(defined($assign) && defined($win) && $assign!=$win);

		$save=0 if(map::mode('tbd', '1de', '1bd') && map::type('coop')
				&& ($e->{'time'}-$Destroy) > 3000);

		$time=sprintf("%0.2f", ($e->{'time'} - $Start)/$config::Clock);

		if(map::mode('tdm', '1dm', '1de', '1bd')) {
			foreach my $player (keys(%Helpers)) {
				&help($player, $player->{'kills'}/$player->{'died'}*20-20)
					if($player->{'died'}>2);
			}
		}

		if($Winner && map::type('race')) {
			if(plus::spawns($Winner)>1) {
				if(player::count() < $min_players) {
					$save=0;
				} else {
					#push(@holder, map::team_color($Winner->{'team'}));
					@nicks=&team($Winner->{'team'});
					push(@holder, join(', ', map(player::name($_), @nicks)));
				}
			} else {
				push(@holder, player::name($Winner));
			}
		} elsif(%Helpers && map::type('coop', 'ruin')) {
			@nicks=sort({ $Helpers{$b} <=> $Helpers{$a} } keys(%Helpers));

			if($time>90 && $Helpers{$nicks[0]}>50 && !map::mode('1de', '1bd')) {
				@nicks=grep($Helpers{$_}>25, @nicks);
			} else {
				@nicks=grep($Helpers{$_}>10, @nicks);
			}

			if(@nicks) {
				splice(@nicks, 5, scalar(@nicks), $etal) if(@nicks>5);
				push(@holder, join(', ', map(player::name($_), @nicks)));
				if($holder[-1]=~m/, (,|$)/) { #DEBUG trailing comma issue
					foreach my $rp (@nicks) {
						ui::slog('record:', $Helpers{$rp}, json::encode($rp));
					}
				}
			}
		}

		if(db::enabled) {
			if($save) {
				foreach my $id (db::extra_records(map::name)) {
					db::delete('records', qq{id=$id});
				}

				db::records(map::name, [$time, @holder]);
				$records=db::records(map::name);

				foreach my $record (@$records) {
					last if($record->[1]==$holder[0]);
					$place++;
				}

				splice(@$records, 5);
			}
		} else {
			$records=stash::get(map::name, 'records');

			if($save) {
				if(ref($records) eq 'ARRAY' && @$records) {
					for(my $i=0; $i<@$records; $i++) {
						if($time<$records->[$i][0]) {
							splice(@$records, $i, 0, [$time, @holder]);
							pop(@$records) if(@$records>5);
							last;
						} else {
							$place++;
						}
					}
					if(@$records<5 && @$records<$place) {
						push(@$records, [$time, @holder]);
					}
				} else {
					$records=[[$time, @holder]];
				}

				if($place && $place<=5) {
					stash::set(map::name, 'records', $records);
				} else {
					$place=0;
				}
			}
		}

		if(@$records) {
			if($save) {
				chat::all('Record Times');
			} elsif(map::type('race')) {
				chat::all("Record Times (minimum $min_players players)");
			} else {
				chat::all("Record Times (winning teams)");
			}
			chat::all('-----------------------');
			&print;

			if($save) {
				log::record(tourney::on() || $place);

				if($place && $place<=5) {
					chat::all('Congratulations, you placed',  utils::nth($place));
				} elsif($place) {
					chat::all(&fmt_record($place, $time, @holder));
				} elsif(map::type('race')) {
					chat::all('win',  ':', utils::secs2mins($time));
				} else {
					chat::all('you',  ':', utils::secs2mins($time));
				}
			}
			chat::all('-----------------------');
		}
	}

	sub delete {
		my($remove)=@_;
		my($found)=0;
		my($map)=map::name;
		my($precision, $records);

		if($remove=~m/0?(\d+):0?(\d+.\d+)/) {
			$remove=$1*60+$2;
			$precision=length($remove=~m/\.(\d+)/);
		}

		if(db::enabled) {
			$found+=db::delete('records', qq{
					map='$map' AND round(record,$precision)=$remove
				});
		} else {
			$records=stash::get($map, 'records');

			return(0) unless(ref($records) eq 'ARRAY');

			for(my $i=0; $i<@$records; $i++) {
				while($remove == $records->[$i][0]) {
					splice(@$records, $i, 1);
					$found=1;
				}
			}
		}

		return($found);
	}

	sub winner {
		my($p)=@_;

		$Winner=$p;
	}

	sub move2db {
		my($records)=stash::get('records');

		return unless(ref($records) eq 'HASH');

		db::begin;

		foreach my $map (keys(%$records)) {
			if(ref($records->{$map}) eq 'ARRAY') {
				foreach my $record (@{$records->{$map}}) {
					db::records($map, $record) if(ref($record) eq 'ARRAY');
				}
			}
		}

		db::commit;

		stash::delete('records');
	}

	sub init {
		$Winner=undef;
		$Destroy=undef;
		%Helpers=();

		&move2db if(db::enabled);
	}

}

=head2 Rankings

B<alti+server> can be configured to rank players players similar to ladder.
These rankings can also be configured to select evenly matched teams.

=cut

{	package rank;

	my($Base)=600;
	my(%Team); tie %Team, 'Tie::RefHash';

	sub _quality_curve { # modified logistic curve)
		my($seconds)=@_;

		return(sprintf('%0.2f', 1/(1+1.01**(abs($seconds)-600))));
	}

	sub scale {
		my($p)=@_;
		my($mode)=map::mode;
		my($goal_ratio)=$config::Launcher{'goals'}/6;
		my($competition)=player::count()/$config::Maxp;
		my($duration, $quality);

		if($config::Launcher{'roundTime'}{$mode}) {
			$duration=$config::Launcher{'roundTime'}{$mode};
		} elsif(map::mode('ball') && map::bases) {
			$duration=$Base*$goal_ratio + $Base/2;
		} elsif(map::mode('ball')) {
			$duration=$Base*$goal_ratio;
		} elsif(map::mode('tbd')) {
			$duration=$Base;
		} elsif(map::mode('1bd', '1de', '1dm')) {
			$duration=$Base/3;
		} elsif(map::mode('ffa', 'tdm')) {
			$duration=$config::Launcher{'score'}{$mode}*15;
		}

		$quality=&_quality_curve($duration - $p->{'stats'}{'played'}/1000);

		return($quality*$competition);
	}

	sub rate {
		my($p)=@_;
		my($stats)=$p->{'stats'};
		my($minute)=$stats->{'played'}/60000;
		my($rate)=0;

		return(0) unless($minute>1);

		#Individual:
		$rate+=$stats->{'base'};
		$rate+=$stats->{'turret'}/3;
		$rate+=$stats->{'capture'};
		$rate+=$stats->{'goals'};
		$rate+=$stats->{'assists'}/$minute;
		$rate+=$stats->{'saves'}/$minute;
		$rate+=$stats->{'interception'}/$minute;
		$rate-=$stats->{'intercepted'}/$minute;
		$rate-=$stats->{'crashes'}/$minute;

		if(map::mode('tbd')) {
			$rate+=$stats->{'powerkill'}/$minute;
			$rate+=$stats->{'kills'}/$minute;
			$rate-=$stats->{'died'}/$minute;
			$rate-=$stats->{'fumble'}/$minute/2;
		} elsif(map::mode('tdm', 'ffa')) {
			$rate+=$stats->{'kills'}/$minute;
			$rate-=$stats->{'died'}/$minute;
		} elsif(map::mode('1bd', '1dm', '1de')) {
			$rate+=$stats->{'powerkill'};
			$rate+=$stats->{'kills'};
			$rate-=$stats->{'died'}/3;
		} elsif(map::mode('ball')) {
			$rate+=$stats->{'powerkill'}/$minute;
			$rate-=$stats->{'fumble'}/$minute;
		}

		#Maximum 5 point individual effort swing
		$rate=utils::mid(-5, $rate, 5);

		#Team:
		if($stats->{'differential'}>0) {
			$rate+=20;
		} elsif($stats->{'differential'}<0) {
			$rate-=19;
		}

		return($rate);
	}

	sub show {
		my($p, $type, $search)=@_;
		my($name, $r, $diff, $better, $i);
		my(%seen)=();

		return unless($search);

		if($search=~m/^(\d+)(st|nd|rd|th)$/) {
			$i=$1-1;

			($search)=db::select('rank', qq{
					type='$type'
					ORDER BY rating DESC,differential DESC
					LIMIT 1 OFFSET $i
				});
			$search=$search->{'id'};
		}

		foreach my $player (db::psearch($search)) {
			$name=$player->{'name'} || $player->{'nickname'};

			next if(exists($seen{$player->{'id'}}));
			$seen{$player->{'id'}}=1;

			($r)=db::select('rank', qq{id='$player->{"id"}' AND type='$type'});

			$diff=$r->{'differential'}-0.001; #Pg floating point sucks

			if($r) {
				$better=db::count('rank', qq{
					type='$type' AND (
						rating>$r->{'rating'} OR (
							rating=$r->{'rating'} AND
							differential>=$diff
						)
					)
				});

				chat::whisperf($p, '%s: %s rating=%d, diff=%+0.1f, rank=%s',
					$name, $type,
					@$r{'rating', 'differential'},
					utils::nth($better),
				);
			} else {
				chat::whisper($p, "$name: no $type rank");
				return;
			}
		}

	}

	sub enter {
		my($p)=@_;
		my($type)=map::type;
		my($rate)=&rate($p);
		my($scale)=&scale($p);
		my($update, $diff);

		$type=map::mode if($type eq 'std');

		$update=$rate * $scale;

		ui::slog(sprintf(join("\n  ", 
				"enter: name=%s, id=%d, type=%s, played=%d,",
				"rate=%.2f, scale=%.2f, update=%.1f, diff=%.2f,",
				"json=%s"
			), (
				$p->{'name'} || $p->{'nickname'},
				$p->{'id'}, $type, $p->{'stats'}{'played'},
				$rate, $scale, $update, $p->{'stats'}{'differential'},
				json::encode($p->{'stats'}),
			)

		));

		if($update) {
			($p->{'rating'}, $diff)=db::rank($p, $type, $update);

			if(config::option('assignRank')) {
				chat::whisperf($p, '%+d : rating=%d, diff=%+0.1f',
					$update, $p->{'rating'}, $diff
				);
			}
		}
	}

	sub join {
		my($p)=@_;
		my($type)=map::type;
		my($diff);

		$type=map::mode if($type eq 'std');

		($p->{'rating'}, $diff)=db::rank($p, $type);
	}

	sub score {
		my($team, $score)=@_;
		my($update)=$score*player::handicap($team);
		my($minimum)=$config::Maxp*0.75;

		#Uncomment when rating goes live:
		#return unless(player::count>$minimum);

		foreach my $player (player::list) {
			next if(map::spec($player));

			if($player->{'team'}==$team) {
				$player->{'stats'}{'differential'}+=$update;
			} else {
				$player->{'stats'}{'differential'}-=$update;
			}
		}
	}

	sub map_change {
		%Team=();
	}

	sub place {
		my($team)=shift;
		
		foreach my $p (@_) {
			$Team{$p}=$team;
		}
	}

	sub members {
		my($team)=@_;

		return(grep($Team{$_} eq $team, keys(%Team)));
	}

	sub rating {
		my($team)=@_;

		return(List::Util::sum(map($_->{'rating'}, &members($team))));
	}

	sub ratesort {
		return(sort({ $a->{'rating'} <=> $b->{'rating'} } @_));
	}

	sub swap {
		my($a, $b)=@_;

		@Team{$a,$b}=@Team{$b,$a};
	}

	sub assign {
		my($p)=@_;
		my(@left)=&ratesort(&members('left'));
		my(@right)=&ratesort(&members('right'));
		my($left)=&rating('left');
		my($right)=&rating('right');
		my($thresh)=400;
		my(@try);
		my($needed, $delta);

		if(@left<@right) {
			&place('left', $p);
			$left+=$p->{'rating'};
		} elsif(@left>@right) {
			&place('right', $p);
			$right+=$p->{'rating'};
		} elsif($left<$right) {
			&place('left', $p);
			$left+=$p->{'rating'};
		} else {
			&place('right', $p);
			$right+=$p->{'rating'};
		}

		if(@left>4) {	#Don't move best player if teams are big enough:
			pop(@left);
			pop(@right);
		}
		if(@left>4) {	#Don't move worst player if teams are big enough
			shift(@left);
			shift(@right);
		}

		$thresh*=1+abs(@left-@right);

		$needed=($left-$right)/2;

		$delta=$needed-($left[0]{'rating'}-$right[0]{'rating'});
		@try=($left[0], $right[0], $delta);

		if($needed < -$thresh || $thresh < $needed) {
			foreach my $l (@left) {
				foreach my $r (@right) {
					$delta=$needed-($l->{'rating'}-$r->{'rating'});
					if(abs($delta)<abs($try[2])) {
						@try=($l, $r, $delta);
					}
				}
			}

			&swap(@try[0,1]);
		}
	}

	sub teams {
		my(@players)=&ratesort(@_);
		my(@teams)=qw(left right);
		my(@rate)=(0, 0);
		my(@left, @right);

		if(!@players) {
			return([], []);
		} elsif(@players==1) {
			return(\@players, []);
		} elsif(@players==2) {
			return([$players[0]], [$players[1]]);
		} elsif(@players>2) {
			&place('left', utils::pluck(@players));
			&place('right', utils::pluck(@players));
		}
		if(@players>4) {
			&place('right', utils::pluck(@players));
			&place('left', utils::pluck(@players));
		}

		@rate=( &rating('left'), &rating('right') );

		for(my $i=0; @players>1; $i=!$i) {
			if($rate[$i]>$rate[!$i]) {
				$rate[$i]+=$players[0]{'rating'};
				&place($teams[$i], shift(@players));
			} else {
				$rate[$i]+=$players[-1]{'rating'};
				&place($teams[$i], pop(@players));
			}
		}

		&assign(@players);

		@left=&members('left');
		@right=&members('right');

		if(utils::coin_toss) {
			return(\@left, \@right);
		} else {
			return(\@right, \@left);
		}
	}

	sub team_check {
		my($p)=@_;

		return(1);
	}

}

=head2 Tournaments

B<alti+server> recognizes that tournaments exist and keeps track of them.
Right now, not much is done with tournaments as there is not much to do.
The one place that tournaments are affected by B<alti+server> is in the
case that a map's C<assignTeam> attribute is in effect.  Under this case,
a tournament is modified (only the current tournament participants) to
ensure players are assigned correctly.

=cut

{	package tourney;

	my(@Left)=();
	my(@Right)=();
	my(%Participants)=();
	my($On)=undef;

	sub on {
		return($On);
	}

	sub clear {
		@Left=();
		@Right=();
		%Participants=();
		$On=undef;
	}

	sub members {
		my($left, $right)=@_;

		@Left=();
		foreach my $vaporid (@$left) {
			push(@Left, $vaporid);
		}

		@Right=();
		foreach my $vaporid (@$right) {
			push(@Right, $vaporid);
		}

		%Participants=();
		foreach my $vaporid (@Left, @Right) {
			$Participants{$vaporid}=1;
		}

		$On=1;
	}

	sub assign {
		my($p, $team)=@_;

		return(undef) unless($On);
		return(undef) unless($Participants{$p->{'vaporId'}});

		if(map::left($team)) {
			server::send('modifyTournament', $p->{'nickname'}, 0);
		} elsif(map::right($team)) {
			server::send('modifyTournament', $p->{'nickname'}, 1);
		} else {
			server::send('modifyTournament', $p->{'nickname'}, -1);
		}

		return(1);
	}
	
}

=head2 Race Tournaments

B<alti+server> supports race tournaments.  You need to ensure that the
C</raceMap>, C</raceCancel>, C</raceAdd>, C</raceDel>, C</raceList>, and
C</go> commands are enabled for these to work.  Admins register players into
races, then set the race map.  Players are instructured to respond with C</go>
when they are ready to begin the race.  Once all the players are ready, the
server switches the map and the race begins.

=cut

{	package race;

	my(%Racers); tie %Racers, 'Tie::RefHash';
	my($Race)=0;
	my($Goals)=0;
	my($Map)=undef;
	my($Start)=undef;
	my($Timedir)=config::option('raceData') || "$INSTALL_ROOT/servers";
	my($Log)=IO::Handle->new;
	my($Logfile)=undef;

	sub init {
		my($racers);

		if($Race==1) {
			1; #pass
		} elsif($Race==2 && $Map eq map::name()) {
			foreach my $status (values(%Racers)) {
				return unless($status==2);
			}

			$racers=join(', ', map($_->{'nickname'}, keys(%Racers)));

			$Race=3;

			queue::schedule {
				chat::all('*** Official race starting now! ***');
				chat::all("Only $racers may participate");
			} 8;
		} else {
			$Race=0;
			$Goals=0;
			$Map=undef;
			$Start=undef;
			%Racers=();
			close($Log);
			$Logfile=undef;
		}
	}

	sub block {
		my($p)=@_;

		unless(exists($Racers{$p}) || $p->{'admin'} || $p->{'moderator'}) {
			server::send('addChatBlock', $p->{'vaporId'},
					'AllChat', 5, 'minute', 'All chat blocked during race');
		}
	}

	sub unblock {
		my($p)=@_;

		unless(exists($Racers{$p}) || $p->{'admin'} || $p->{'moderator'}) {
			server::send('removeChatBlock', $p->{'vaporId'}, 'AllChat');
		}
	}


	sub on {
		return($Race>0);
	}

	sub map {
		return($Map);
	}

	sub mark {
		my($e)=@_;

		$Start=$e->{'time'};
	}

	sub request_go {
		foreach my $p (player::list) {
			if($Racers{$p}) {
				chat::whisper($p, "Type '/go' when read to start $Map");
			} else {
				chat::whisper($p, 'Game reserved for race participants');
				&bench($p);
			}
		}
	}

	sub set_map {
		my($map)=@_;
		my($time)=time();
		my($score)=List::Util::max(@{stash::get('score', $map, 'map')});
		my($date)=POSIX::strftime('%Y%m%dT%H%M%SZ', gmtime($time));

		stash::set('nextMap', 'admin', $map);
		$Map=$map;

		$Logfile="$Timedir/$date-$map.txt";
		open($Log, '>', $Logfile);
		$Log->autoflush(1);

		print $Log "map,$map\n", "time,$time\n";

		foreach my $racer (keys(%Racers)) {
			printf $Log "player,%d,%s,%s\n",
				@$racer{'player','vaporId','nickname'};
		}

		$Race=1;

		unless($Goals) {
			if($score<0) {
				$Goals=abs($score);
			} else {
				$Goals=$config::Launcher{'goals'}-$score;
			}
			print $Log "goals,$Goals\n";
		}
	}

	sub set_goals {
		my($goals)=@_;

		$Goals=$goals;
		print $Log "goals,$goals\n";
	}

	sub start_if_ready {
		my($assign)=stash::get('assignTeam', map::name, 'map');

		foreach my $status (values(%Racers)) {
			return unless($status==2);
		}

		foreach my $player (player::list) {
			if(exists($Racers{$player})) {
				$Racers{$player}=2;
				plus::assign($player, $assign);
			} else {
				&block($player);
				plus::bench($player);
			}
		}

		#server::send('startTournament') if(&count > 1);

		$Race=2;

		server::send('changeMap', $Map);
	}

	sub start_now {
		my($assign)=stash::get('assignTeam', map::name, 'map');

		foreach my $player (player::list) {
			if(exists($Racers{$player})) {
				$Racers{$player}=2;
				plus::assign($player, $assign);
			} else {
				&block($player);
				plus::bench($player);
			}
		}

		#server::send('startTournament') if(&count > 1);

		$Race=2;

		server::send('changeMap', $Map);
	}

	sub finished {
		foreach my $status (values(%Racers)) {
			return(0) unless($status>2);
		}

		return(1);
	}

	sub racers {
		return(%Racers);
	}

	sub list {
		return(keys(%Racers));
	}

	sub count {
		return(scalar(keys(%Racers)));
	}

	sub cancel {
		my($logfile)=$Logfile;

		if($Race) {
			#server::send('stopTournament') if(&count > 1);

			foreach my $player (player::list) {
				&unblock($player);
			}

			chat::all('Pending race canceled.');
			$Map=map::name;
			&init;
			unlink($logfile);
		}
	}

	sub complete {
		my($place)=0;
		my($msg);

		return unless(&finished);

		#server::send('stopTournament') if(&count > 1);

		foreach my $player (player::list) {
			&unblock($player);
		}

		foreach my $r (sort {$Racers{$a}<=>$Racers{$b}} keys(%Racers)) {
			$place++;

			$msg=sprintf('%s : %-16s (%s)',
				utils::nth($place),
				$r->{'nickname'},
				utils::secs2mins($Racers{$r}),
			);

			chat::all($msg);

			print $Log join(',',
					'place',
					$place,
					$r->{'team'},
					$r->{'player'},
					$r->{'nickname'},
					$Racers{$r},
					$msg
				), "\n";
		}

		$Race=0;
		&init;

		queue::schedule {
			chat::all('*** Official race complete! ***');
			chat::all("All players may spawn");
		} 4;
	}

	sub add {
		my($p)=@_;

		unless(exists($Racers{$p})) {
			$Racers{$p}=1;
		}
	}

	sub del {
		my($p)=@_;

		delete($Racers{$p});

		unless(keys(%Racers)) {
			&cancel;
			return;
		}

		if(&finished) {
			&complete;
		}
	}

	sub ready {
		my($p)=@_;

		unless($Race) {
			chat::whisper($p, 'Race vote not active');
			return;
		}

		$Racers{$p}=2;

		&start_if_ready;
	}

	sub checkpoint {
		my($e, $p, $cp)=@_;
		my($time)=($e->{'time'}-$Start)/$config::Clock;

		return unless($Race>1);

		printf $Log "checkpoint,%.3f,%s,%d,%d,%s\n",
				$time, $cp, @$p{'team','player','nickname'};

		if($p->{'stats'}{'checkpoint'} >= $Goals) {
			$Racers{$p}=$time;
			plus::bench($p);
			chat::whisper($p, 'You completed the race in:',
				utils::secs2mins($time));
		}

		if(&finished) {
			&complete;
		}
	}

	sub spawn {
		my($p)=@_;

		return unless($Race);

		printf $Log "spawn,%.3f,%d,%d,%s\n",
				($p->{'spawn'}-$Start)/$config::Clock,
				@$p{'team','player','nickname'};
	}

	sub allowed {
		my($p)=@_;

		return(1) unless($Race);

		if($Racers{$p}==2) {
			return(1);
		} elsif($Racers{$p}>2) {
			chat::whisper($p, 'You finished, wait for others to finish.');
		} else {
			chat::whisper($p, 'You are not in this race, please do not try to spawn');
		}

		return(undef);
	}

}

=head2 Ball Games

B<alti+server> supports standard ball games and keeps track of more information
than a normal game would have.  This is used to laud good play, balance teams,
and provide slightly enhanced game play.

For legacy reasons, TDM game modes which follow the score also use the ball
interface.

=cut

{	package ball;

	my(@Score)=(0, 0);
	my($Team)=map::spec;
	my($Last)=map::spec;
	my($Shot)=0;

	my($Carrier)=undef;
	my($Passer)=undef;

	my(@Relay)=();

	sub new {
		@Score=(0, 0);
		@Relay=();
		$Last=map::spec;
		$Team=map::spec;
	}

	sub reset {
		@Relay=();
		$Last=map::spec;
		$Team=map::spec;
		$Shot=0;
		$Passer=undef;

		if($Carrier) {
			$Carrier->{'carrier'}=0;
			$Carrier=undef;
		}
	}

	sub update_score {
		my($team)=@_;

		if(@_==2) {
			@Score=@_;
		} elsif(map::left($team)) {
			$Score[0]++;
		} elsif(map::right($team)) {
			$Score[1]++;
		}
	}

	sub set_score {
		my($left)=POSIX::floor($_[0]);
		my($right)=POSIX::floor($_[1]);

		if(map::mode('ball')) {
			server::send('overrideBallScore', $left, $right);
		} elsif(map::mode('tdm', '1dm') && xx::enabled) {
			server::send('overrideTdmScore', $left, $right);
		}
	}

	sub score {
		my($p)=@_;

		&update_score($p->{'team'}) if($p);
		&set_score(@Score);

		return(@Score);
	}

	sub team_score {
		my($team)=@_;

		&update_score($team);
		&set_score(@Score);

		return(@Score);
	}

	sub progress {
		my($p, $amount)=@_;
		my($side)=map::side($p);
		my($goals)=$config::Launcher{'goals'};
		my($new)=POSIX::floor($amount*$goals);

		if($side eq 'left') {
			return if($new==$Score[0]);

			$Score[0]=$new;
			rank::score($p->{'team'}, 1);
		} elsif($side eq 'right') {
			return if($new==$Score[1]);

			$Score[1]=$new;
			rank::score($p->{'team'}, 1);
		} else {
			return;
		}
		&set_score(@Score);
	}

	sub shoot {
		my($e)=@_;

		$Shot=$e->{'time'};

		$Passer=$Carrier;

		$Passer->{'carrier'}=0;
		$Carrier=undef;
	}

	sub catch {
		my($e, $p)=@_;
		my($airtime)=$e->{'time'}-$Shot;

		unless($e->{'type'} eq 'powerupPickup' && $e->{'powerup'} eq 'Ball') {
			return(undef);
		}

		$Shot=0;
		$Carrier=$p;

		$Last=$Team;
		$Team=$p->{'team'};

		if($Last == $Team) {
			unless($Passer == $Carrier) {
				if($airtime>900 && $airtime<2200 && chat::snarky) {
					chat::laud("Nice Pass $Passer->{'nickname'}!")
						unless($Passer->{'isbot'});
				}
				push(@Relay, $p);
				$Passer->{'stats'}{'pass'}++;
				$Carrier->{'stats'}{'catch'}++;
			}
		} else {
			$Passer->{'stats'}{'intercepted'}++ if($Passer);
			$Carrier->{'stats'}{'interception'}++;
			@Relay=();
		}

		$Passer=undef;

		return(1);
	}

	sub drop {
		my($v)=@_;

		return unless($v->{'carrier'});

		$v->{'carrier'}=0;
		$Passer=undef;
		$Carrier=undef;
	}

	sub goal {
		my($e, $p)=@_;
		my($airtime);

		&update_score(map::side($p));

		return if($p->{'isBot'});
		return unless(chat::laudy);

		if(map::mode('ball')) {
			$airtime=$e->{'time'}-$Shot;

			if(!$p->{'carrier'} && 3000<$airtime && $airtime<6000) {
				chat::laud("Nice Shot $p->{'nickname'}!");
			}
		}
	}

	sub intercepted {
		if(map::spec($Last) || $Last == $Team) {
			return(undef);
		} else {
			return($Team);
		}
	}

	sub passes {
		return(scalar(@Relay));
	}

	sub winner {
		my($goals)=$config::Launcher{'goals'};
		my($win)=stash::get('score', map::name, 'map');

		if(map::mode('ball')) {
			if($Score[0]>=$goals) {
				return(map::left);
			} elsif($Score[1]>=$goals) {
				return(map::right);
			}
		} elsif(map::mode('tdm', '1dm') && xx::enabled) {
			if($Score[0]>=$win->[0]) {
				return(map::left);
			} elsif($Score[1]>=$win->[1]) {
				return(map::right);
			}
		}

		return(undef);
	}

}

=head2 Altitued Plus Games

An alti+ game requires a lot of extra management.  The B<alti+server> wrapper
provides interfaces for each game.  Functions relating to maps, spawning,
game types, etc.  are available from the server wrapper.  This is the main
purpose of this server code:  to extend the possibilities of Altitude game
play though extended interfaces and server support.

=cut

{	package plus;

	my(%Stats)=();
	my(%Reset)=();
	my(%Restart)=();
	my(%Planes)=();
	my(%Bots)=();
	my($Hunted)=undef;
	my($Active)=0;
	my($Captured)=0;

	sub round {
		ball::new;		#Can ball have multiple rounds?
		#$Hunted=undef;	#Should hunted change per round?

		if(map::type('ruin')) {
			foreach my $team (map::teams) {
				$Stats{$team}{'structure'}{'remaining'}=
					$Stats{$team}{'structure'}{'total'};
			}
		}
	}

	sub active {
		my($old)=$Active;
		$Active=1;
		return($old);
	}

	sub score {
		my($p)=@_;
		my($goals)=$config::Launcher{'goals'};
		my($win)=stash::get('score', map::name, 'map');
		my(@score)=ball::score($p);

		return if(race::on);

		if(map::mode('ball')) {
			if($score[0] >= $goals) {
				$Stats{'winner'}='left';
				records::winner($p);
			}
			if($score[1] >= $goals) {
				$Stats{'winner'}='right';
				records::winner($p);
			}
		} elsif(map::mode('tdm', '1dm') && xx::enabled) {
			if($score[0] >= $win->[0]) {
				$Stats{'winner'}='left';
				records::winner($p);
				xx::set_time(0);
			}
			if($score[1] >= $win->[1]) {
				$Stats{'winner'}='right';
				records::winner($p);
				xx::set_time(0);
			}
		}
	}

	sub game_over {
		return($Stats{'winner'});
	}

	sub angle {
		my($x, $y, $a);

		if(@_==1) {
			$x=0; $y=0;
			$a=lc($_[0]);
		} elsif(@_==2) {
			return(utils::direction(@_));
		} elsif(@_==3) {
			($x, $y, $a)=@_;
			$a=lc($a);
		} else {
			return(utils::direction(@_[2,3]));
		}

		if($a eq 'c' || $a eq 'center') {
			return(utils::direction($map::Xmid-$x, $map::Ymid-$y));
		} elsif($a eq 'h' || $a eq 'hmirror') {
			return(utils::direction($map::Xmid-$x, 0));
		} elsif($a eq 'v' || $a eq 'vmirror') {
			return(utils::direction(0, $map::Ymid-$y));
		} else {
			return(utils::angle($a));
		}
	}

	sub next_bot {
		my(@keys);

		if(%Bots) {
			@keys=keys(%Bots);
		} elsif(%Planes) {
			@keys=keys(%Planes);
		} else {
			return;
		}

		xx::setup_bot(split(m/,/, utils::pluck(@keys))) if(xx::enabled);
	}

	sub any_bot {
		server::send('botPlaneRandom') if(xx::enabled);
	}

	sub build_planes {
		my($planes)=stash::get('planes', map::name, 'map');
		my($bots)=stash::get('bots', map::name, 'map');
		my(%setups)=utils::all_setups;

		%Planes=();
		%Bots=();

		if(ref($planes)) {
			foreach my $planere (keys(%$planes)) {
				next unless($planes->{$planere} eq '+');

				$planere=~s/^,/.*,/;
				$planere=~s/,$/,.*/;
				1 while($planere=~s/,,/,.*,/);

				foreach my $setup (grep(m/$planere/, keys(%setups))) {
					$Planes{$setup}=1;
				}
			}

			unless(%Planes) {
				%Planes=%setups;
			}

			foreach my $planere (keys(%$planes)) {
				next unless($planes->{$planere} eq '-');

				$planere=~s/^,/.*,/;
				$planere=~s/,$/,.*/;
				1 while($planere=~s/,,/,.*,/);

				foreach my $setup (grep(m/$planere/, keys(%setups))) {
					delete($Planes{$setup});
				}
			}
		}

		if(ref($bots)) {
			foreach my $planere (keys(%$bots)) {
				next unless($bots->{$planere} eq '=');

				$planere=~s/^,/.*,/;
				$planere=~s/,$/,.*/;
				1 while($planere=~s/,,/,.*,/);

				foreach my $setup (grep(m/$planere/, keys(%setups))) {
					$Bots{$setup}=1;
				}
			}
		}

		if(%Bots || %Planes) {
			&next_bot;
		}
	}

	sub plane_check {
		my($p)=@_;
		my($planes)=stash::get('planes', map::name, 'map');
		my($setup)=join(',', @$p{'plane','perkRed', 'perkGreen','perkBlue'});

		return(1) unless(%Planes);

		if(exists($Planes{$setup})) {
			return(1);
		} else {
			chat::whisper($p, 'Plane restricitons:', join(', ',
				map($planes->{$_}.utils::simplify($_), sort(keys(%$planes)))
			));
			return(0);
		}
	}

	sub restart_clear {
		%Restart=();
	}

	sub restart_print {
		my($threshold)=int(player::list('both')+1/2);
		my($count);

		if(%Restart) {
			$count=keys(%Restart);
			chat::allf('/restartMap: %d/%d', $count, $threshold);
		}
	}

	sub restart_request {
		my($p)=@_;
		my($threshold)=int(player::list('both')+1/2);
		my($count);

		if(exists($Restart{$p})) {
			$count=keys(%Restart);
			chat::whisperf('/restartMap: %d/%d', $count, $threshold);
		} else {
			$Restart{$p}=1;

			$count=keys(%Restart);

			if($count >= $threshold) {
				server::send('balanceTeams');
				&restart_clear;
			} else {
				chat::allf('/restartMap: %d/%d', $count, $threshold);
			}
		}
	}

	sub spawns {
		my($p)=@_;
		my(@spawns)=map::spawn_points;
		my($zones)=stash::get('zones', $p->{'team'}, 'zones', map::name, 'map');
		my($spawn_zone)=stash::get('spawnMode', map::name, 'map')=~m/zone|near|after/;
		my($mdg)=map::type('mdg');
		my(@points)=();

		if(ref($zones) eq 'HASH' && ($spawn_zone || $mdg)) {
			foreach my $name (keys(%$zones)) {
				next unless($Stats{$p->{'team'}}{'zone'}{$name} // 1);
				next unless($Stats{$p}{$p->{'team'}}{'zone'}{$name} // 1);
				push(@points, $zones->{$name});
			}
		} elsif(@spawns) {
			foreach my $sp (@spawns) {
				#Team 2 is ALL teams.
				if($sp->{'team'}==2 || $sp->{'team'}==$p->{'team'}) {
					push(@points, [@$sp{'x','y','orientation'}]);
				}
			}
		} else {
			ui::slog('There are no spawn points defined for', map::name);
		}

		return(@points);
	}

	sub spawn_previous {
		my($p)=@_;

		if(exists($p->{'stats'}{'spawns'}) && @{$p->{'stats'}{'spawns'}}>1) {
			pop(@{$p->{'stats'}{'spawns'}});
			server::send('overrideSpawnPoint', $p->{'nickname'},
				@{$p->{'stats'}{'spawns'}[-1]}
			);
		} else {
			&spawn_reset($p);
		}
	}

	sub spawn_here {
		my($p, $x, $y, @angle)=@_;
		my($override)=stash::get('spawnAngle', map::name, 'map');
		my($angle)=&angle($x, $y, $override || @angle);
		
		if($x==-1 && $y==-1 && $angle[0]==-1) {
			&spawn_previous($p);
		}

		if(abs($angle)>90) {
			$x=POSIX::ceil($x);
		} else {
			$x=POSIX::floor($x);
		}
		if($angle<0) {
			$y=POSIX::ceil($y);
		} else {
			$y=POSIX::floor($y);
		}

		server::send('overrideSpawnPoint', $p->{'nickname'}, $x, $y, $angle);
		push(@{$p->{'stats'}{'spawns'}}, [$x, $y, $angle]);
	}

	sub spawn_reset {
		my($p)=@_;
		my($start)=stash::get('start', 'zones', $p->{'team'}, 'zones', map::name, 'map');

		if(ref($start) eq 'ARRAY') {
			&spawn_here($p, @$start);
		} else {
			server::send('overrideSpawnPoint', $p->{'nickname'}, 0, 0, 0);
		}
		delete($p->{'stats'}{'spawns'});
	}

	sub spawn_random {
		my($p)=@_;
		my(@spawns)=&spawns;
		my($random)=int(rand(@spawns));

		if(@spawns) {
			&spawn_here($p, @{$spawns[$random]});
		} else {
			&spawn_reset($p);
		}
	}

	sub clear_spawn {
		my($p)=@_;

		$Reset{$p}=1;
	}

	sub check_spawn {
		my($p)=@_;

		if(exists($Reset{$p})) {
			&spawn_previous($p);
			delete($Reset{$p});
			return(1);
		} else {
			return(0);
		}
	}

	sub after {
		my($spawn, $died)=@_;
		my($sa)=&angle(@$spawn);
		my($da)=&angle($died->[0]-$spawn->[0], $died->[1]-$spawn->[1]);
		my($after)=0;
		my($cc, $cw)=(&angle($sa+90), &angle($sa-90));

		if(90>=$sa && $sa>-90) {
			$after=1 if($cc>=$da && $da>=$cw);
		} else {
			if($da>0) {
				$after=1 if($da>=$cw);
			} else {
				$after=1 if($da<=$cc);
			}
		}

		return($after);
	}

	sub spawn_near {
		my($p, $x, $y)=@_;
		my($zones)=stash::get('zones', $p->{'team'}, 'zones', map::name, 'map');
		my($spawn_mode)=stash::get('spawnMode', map::name, 'map');
		my($near, $delta, $try)=(undef, 2**20, 0);

		if($spawn_mode eq 'near' && ref($zones) eq 'HASH' && %$zones) {
			foreach my $zone (sort(keys(%$zones))) {
				$try=utils::distance($x, $y, @{$zones->{$zone}}[0,1]);
				if($try<$delta) {
					$near=$zone;
					$delta=$try;
				}
			}
			&spawn_here($p, @{$zones->{$near}});
		} elsif($spawn_mode eq 'after' && ref($zones) eq 'HASH' && %$zones) {
			foreach my $zone (sort(keys(%$zones))) {
				$try=utils::distance($x, $y, @{$zones->{$zone}}[0,1]);
				if($try<$delta && &after($zones->{$zone}, [$x, $y])) {
					$near=$zone;
					$delta=$try;
				}
			}
			if($near && exists($zones->{$near})) {
				&spawn_here($p, @{$zones->{$near}});
			} else {
				&spawn_reset($p);
			}
		} else {
			&spawn_reset($p);
		}

	}

	sub assign {
		my($p, $team)=@_;

		return if(tourney::assign($p, $team));

		if(map::left($team)) {
			server::send('assignTeam', $p->{'nickname'}, 0);
		} elsif(map::right($team)) {
			server::send('assignTeam', $p->{'nickname'}, 1);
		} else {
			server::send('assignTeam', $p->{'nickname'}, -1);
		}
	}

	sub bench {
		my($p)=@_;

		if(map::mode('ffa')) {
			chat::whisper($p, 'Players cannot be forced to respawn in FFA');
			return;
		} elsif(map::left($p->{'team'})) {
			server::send('assignTeam', $p->{'nickname'}, 0);
		} elsif(map::right($p->{'team'})) {
			server::send('assignTeam', $p->{'nickname'}, 1);
		} else {
			server::send('assignTeam', $p->{'nickname'}, -1);
		}

		$p->{'alive'}=0;
	}

	sub no_repeats {
		my($e, $p, $obj)=@_;
		my($time)=$e->{'time'};
		my($rv)=1;

		$obj=join(',', @$e{'powerup','positionX','positionY'}) unless($obj);

		$rv=0 if(exists($p->{'timer'}{$obj}) && $time<$p->{'timer'}{$obj});
			
		$p->{'timer'}{$obj}=$time+800;

		return($rv);
	}

	sub capture {
		my($e, $p)=@_;
		my($pickup)=join(',', @$e{'positionX','positionY'});
		my($flags)=stash::get($p->{'team'}, 'powerups', map::name, 'map');
		my(@players)=();

		return unless($flags);
		return if( ($e->{'time'}-$Captured) < 4000 );
		return unless(map::mode('ball'));
		return if(&game_over);

		if($flags->{$pickup}) {
			rank::score($p->{'team'}, 1);

			push(@players, player::list);
			push(@players, player::bots) if(xx::enabled);
			foreach my $player (@players) {
				$player->{'stats'}{'played'}+=$e->{'time'}-$player->{'spawn'};
				&bench($player);
			}

			chat::all($p->{'nickname'}, 'captured the flag!');
			$p->{'stats'}{'capture'}++;
			&score($p);
			$Captured=$e->{'time'};
		}
	}

	sub capture_wait {
		my($e)=@_;
		my($wait)=$Captured+3000;

		if($e->{'time'}<$wait) {
			return(1);
		} else {
			return(0);
		}
	}

	sub checkpoint {
		my($e, $p)=@_;
		my($pickup)=join(',', @$e{'positionX','positionY'});
		my($checkpoints)=stash::get($p->{'team'}, 'powerups', map::name, 'map');
		my($count)=$config::Launcher{'goals'};
		my($cp)=$checkpoints && $checkpoints->{$pickup};
		my(@powerups)=();
		my($is_cp)=0;
		my($t_stats, $p_stats);

		return unless(defined($cp));
		return unless(map::mode('ball', 'tdm'));
		return if(&game_over);

		if(map::mode('tdm', '1dm')) {
			$count=List::Util::max(@{stash::get('score', map::name, 'map')});
		}

		#Initialize team stats:
		unless($Stats{$p->{'team'}}{'cp'}) {
			@powerups=utils::uniq(values(%$checkpoints));

			for(my $i=0; $i<$count; $i++) {
				$Stats{$p->{'team'}}{'cp'}[$i]=$powerups[$i%@powerups];
			}
		}

		#Initialize player stats:
		unless($p->{'stats'}{'cp'}) {
			@powerups=utils::uniq(values(%$checkpoints));

			for(my $i=0; $i<$count; $i++) {
				$p->{'stats'}{'cp'}[$i]=$powerups[$i%@powerups];
			}
		}

		$t_stats=$Stats{$p->{'team'}}{'cp'};
		$p_stats=$p->{'stats'}{'cp'};

		if($p_stats->[0] eq $cp) {
			if($t_stats->[0] eq $cp && @$p_stats == @$t_stats) {
				&score($p);
				$p->{'stats'}{'first_cp'}++;
				chat::all($p->{'nickname'}, ': checkpoint', $cp, 'for',
					map::team_color($p->{'team'}));

				shift(@$t_stats);
			} else {
				chat::whisper($p, $cp);
			}

			$p->{'stats'}{'checkpoint'}++;
			race::checkpoint($e, $p, $cp);

			shift(@$p_stats);
			$is_cp=1;
		}

		return($is_cp);
	}

	sub killed {
		my($v)=@_;
		my($assign)=stash::get('assignTeam', map::name, 'map');

		if(map::type('ruin') && $assign) {
			if(map::left($v->{'team'})) {
				ball::team_score('right');
			} elsif(map::right($v->{'team'})) {
				ball::team_score('left');
			}
		}
	}

	sub destroy {
		my($e, $p)=@_;
		my($structure)=$Stats{$p->{'team'}}{'structure'};
		my($progress);

		if(map::mode('tbd') && map::type('std') && $e->{'target'} eq 'base') {
			if($Stats{'base'}) {
				if($e->{'time'}-$Stats{'base'} < 1500) {
					queue::schedule {
						chat::all('A STRANGE GAME');
						chat::all('THE ONLY WINNING MOVE IS NOT TO PLAY');
					} 1;
				}
			} else {
				$Stats{'base'}=$e->{'time'};
			}
		}

		return unless(map::type('ruin'));
		return unless($structure->{'total'});

		$structure->{'remaining'}--;

		$progress=1-$structure->{'remaining'}/$structure->{'total'};
			
		ball::progress($p, $progress);

		if(	$structure->{'remaining'}>0 &&
			$structure->{'remaining'}<=5 &&
			$progress>0.85
		) {
			chat::team($p, $structure->{'remaining'}, 'remaining');
		}
	}

	sub door_open {
		my($p, $door)=@_;
		my($team)=$p->{'team'};
		my($keys)=stash::get('keys', $team, 'door', map::name, 'map');

		if($p->{'has'} && $keys->{$p->{'has'}} eq $door) {
			return(1);
		} else {
			return(
				$Stats{$p}{$team}{'door'}{$door}
				||  $Stats{$team}{'door'}{$door}
			);
		}
	}

	sub zone_open {
		my($p, $zone)=@_;
		my($team)=$p->{'team'};

		return(
			$Stats{$p}{$team}{'zone'}{$zone}
			||  $Stats{$team}{'zone'}{$zone}
		);
	}

	sub key_found {
		my($p, $key)=@_;
		my($team)=$p->{'team'};

		return(
			$Stats{$p}{$team}{'key'}{$key}
			||  $Stats{$team}{'key'}{$key}
		);
	}

	sub zone_init {
		my($p)=@_;
		my($zones)=stash::get('zones', map::name, 'map');
		my($stats);

		if($p) {
			$stats=$Stats{$p};
			return if(exists($stats->{map::left}{'zones'}));
		} else {
			$stats=\%Stats;
		}

		foreach my $team (keys(%$zones)) {
			#Initialize all zones to open:
			foreach my $name (keys(%{$zones->{$team}{'zones'}})) {
				$stats->{$team}{'zone'}{$name}=1;
			}

			#If a zone has a key, close it:
			foreach my $name (values(%{$zones->{$team}{'keys'}})) {
				$stats->{$team}{'zone'}{$name}=0;
			}
		}
	}

	sub key {
		my($e, $p)=@_;
		my($door)=stash::get($p->{'team'}, 'door', map::name, 'map');
		my($zone)=stash::get($p->{'team'}, 'zones', map::name, 'map');
		my($personal)=stash::get('keys', map::name, 'map') & 1;
		my($pickup)=join(',', @$e{'positionX','positionY'});
		my($name, $keys, $color, @list);

		if($door) {
			if(($name=$door->{'doors'}{$pickup}) && &no_repeats($e, $p, $name)) {
				unless(&door_open($p, $door->{'doors'}{$pickup})) {
					&bench($p);
					chat::whisper($p, $door->{'doors'}{$pickup}, 'is locked');

					@list=();
					foreach my $key (keys(%{$door->{'keys'}})) {
						if($door->{'keys'}{$key} eq $door->{'doors'}{$pickup}) {
							unless(&key_found($p, $key)) {
								push(@list, $door->{'name'}{$key});
							}
							foreach my $player (player::list) {
								if($player->{'has'} eq $key) {
									chat::whisper($p, $player->{'name'},
										"has the key ($key)");
								}
							}
						}
					}
					if(@list) {
						chat::whisper($p, 'Keys remaining:', @list);
					}
				}

				return(1);
			} elsif(($name=$door->{'keys'}{$pickup}) && &no_repeats($e, $p, $name)) {
				if(&door_open($p, $door->{'keys'}{$pickup})) {
					return(0);
				}

				if(&key_found($p, $pickup)) {
					return(0);
				} else {
					chat::team($p, $p->{'nickname'}, "found key '$door->{'name'}{$pickup}' for '$door->{'keys'}{$pickup}'");
					if($personal) {
						$Stats{$p}{$p->{'team'}}{'key'}{$pickup}=1;
					} else {
						$Stats{$p->{'team'}}{'key'}{$pickup}=1;
						$p->{'stats'}{'keys'}++;
					}
				}

				$keys=utils::invert(stash::get('keys', $p->{'team'}, 'door', map::name, 'map'));

				@list=();
				foreach my $key (@{$keys->{$door->{'keys'}{$pickup}}}) {
					unless(&key_found($p, $key)) {
						push(@list, $door->{'name'}{$key});
					}
					foreach my $player (player::list) {
						if($player->{'has'} eq $key) {
							chat::whisper($p, $player->{'name'},
								"has the key ($key)");
						}
					}
				}

				if(@list) {
					chat::whisper($p, 'Keys remaining:', @list);
				} else {
					if($personal) {
						$Stats{$p}{$p->{'team'}}{'door'}{$door->{'keys'}{$pickup}}=1;
						chat::whisper($p, 'Door unlocked:', $door->{'keys'}{$pickup});
					} else {
						$Stats{$p->{'team'}}{'door'}{$door->{'keys'}{$pickup}}=1;
						chat::team($p, 'Door unlocked:', $door->{'keys'}{$pickup});
					}
				}
			}
		}

		if($zone && ($name=$zone->{'keys'}{$pickup}) && &no_repeats($e, $p, $name)) {
			if(&zone_open($p, $zone->{'keys'}{$pickup})) {
				return(0);
			}

			if(&key_found($p, $pickup)) {
				return(0);
			} else {
				chat::team($p, $p->{'nickname'}, 'found key',  $zone->{'name'}{$pickup}, 'for', $zone->{'keys'}{$pickup});
				if($personal) {
					$Stats{$p}{$p->{'team'}}{'key'}{$pickup}=1;
				} else {
					$Stats{$p->{'team'}}{'key'}{$pickup}=1;
					$p->{'stats'}{'keys'}++;
				}
			}

			$keys=utils::invert(stash::get('keys', $p->{'team'}, 'zones', map::name, 'map'));

			foreach my $key (@{$keys->{$zone->{'keys'}{$pickup}}}) {
				unless(&key_found($p, $key)) {
					return(0);
				}
			}

			if($personal) {
				$Stats{$p}{$p->{'team'}}{'zone'}{$zone->{'keys'}{$pickup}}=1;
				chat::whisper($p, 'Zone unlocked:', $zone->{'keys'}{$pickup});
			} else {
				$Stats{$p->{'team'}}{'zone'}{$zone->{'keys'}{$pickup}}=1;
				chat::team($p, 'Zone unlocked:', $zone->{'keys'}{$pickup});
			}
		}

		return(0);
	}

	sub note {
		my($e, $p)=@_;
		my($pickup)=join(',', @$e{'positionX','positionY'});
		my($message)=stash::get($pickup, 'notes', map::name, 'map');

		chat::whisper($p, $message) if($message);
	}

	sub divert {
		my($e, $p)=@_;
		my($pickup)=join(',', @$e{'positionX','positionY'});
		my($other)=stash::get($pickup, 'diverters', map::name, 'map');

		return unless($other);

		if($Stats{'diverters'}{$pickup}) {
			chat::whisper($p, 'Wrong diverter');
			&bench($p);
		} else {
			$Stats{'diverters'}{$pickup}=1;
			$Stats{'diverters'}{$other}=0;
		}
	}

	sub teleport {
		my($e, $p)=@_;
		my($pickup)=join(',', @$e{'positionX','positionY'});
		my($portal)=stash::get($pickup, 'portals', map::name, 'map');

		return(0) unless($portal);

		return(0) unless(&no_repeats($e, $p, $portal->[0]));

		&bench($p);
		&spawn_here($p, @$portal[1,2,3]);

		chat::whisper($p, 'Teleporting you to:', $portal->[0]);

		return(1);
	}

	sub most {
		my($text, $stats, $players)=@_;
		my($most)=0;
		my($start)=0;
		my($p);

		for(my $i=0; $i<@$players; $i++) {
			$p=player::lookup($players->[$i]);
			last unless($p->{'isBot'});
			$start++;
		}

		for(my $i=$start; $i<@$players; $i++) {
			if($stats->[$i]>=$stats->[$most]) {
				$p=player::lookup($players->[$i]);
				$most=$i unless($p->{'isBot'});
			}
		}

		if($stats->[$most]>0) {
			$p=player::lookup($players->[$most]);
			chat::all($text, $p->{'nickname'}) unless($p->{'isBot'});
		}
	}

	sub playing {
		my($p)=@_;

		return($Stats{'players'}{'playing'}{$p});
	}

	sub leave {
		my($p)=@_;

		if($Stats{'players'}{'playing'}{$p}) {
			delete($Restart{$p});
			queue::schedule { &restart_print; } 0;

			delete($Stats{'players'}{'playing'}{$p});
			if($Stats{'players'}{'count'}>0) {
				$Stats{'players'}{'count'}--;
			}
			return(1);
		} else {
			return(0);
		}
	}

	sub hunted {
		if(@_) {
			return($_[0] eq $Hunted);
		} else {
			return($Hunted);
		}
	}

	sub prey {
		my($p)=@_;

		if($Hunted==$p) {
			return(1);
		} elsif(!$Hunted || !$Hunted->{'joined'}) {
			$Hunted=$p;
			return(1);
		} else {
			return(0);
		}
	}

	sub cower {
		my($p)=@_;

		$Hunted=undef;
	}

	sub change_hunted {
		my($p)=@_;
		my($map_team)=stash::get('assignTeam', map::name, 'map');

		if($Hunted==$p) {
			return(1);
		} elsif(!$Hunted) {
			$Hunted=$p;
			if(map::left($map_team) && map::left($p->{'team'})) {
				return(1);
			} elsif(map::right($map_team) && map::right($p->{'team'})) {
				return(1);
			} elsif(map::left($map_team)) {
				&assign($p, 'right');
			} else {
				&assign($p, 'left');
			}
		} else {
			if(map::right($map_team)) {
				&assign($Hunted, 'right');
				&assign($p, 'left');
			} else {
				&assign($Hunted, 'left');
				&assign($p, 'right');
			}
			$Hunted=$p;
		}
	}

	sub enter {
		my($p)=@_;
		my($max)=stash::get('maxPlayers', map::name, 'map') || $config::Maxp;

		if(!race::allowed($p)) {
			return(0);
		} elsif($Stats{'players'}{'playing'}{$p}) {  #Already entered
			return(1);
		} elsif($Stats{'players'}{'count'}<$max) {
			queue::schedule { &restart_print; } 0;
			&zone_init($p) if(stash::get('keys', map::name, 'map') & 1);

			$Stats{'players'}{'playing'}{$p}=1;
			$Stats{'players'}{'count'}++;
			return(1);
		} else {
			return(0);
		}
	}

	sub import_defaults {
		my($tmpl)="$INSTALL_ROOT/maps/cache/%s/%s.altx/plus.txt";
		my($plus)=sprintf($tmpl, config::option('mapDir'), map::name);
		my($read)=IO::Handle->new;
		my(@config)=();
		local($_);

		if(-r $plus) {
			open($read, '<', $plus);
			while(<$read>) {
				chomp;
				s|^\s*/?||;

				next unless(m/^(set|unset|add|del)\s/);
				next unless(length()<256);

				s/\bballScore\b/score/;

				push(@config, $_);
			}
			close($read);
		}

		return(@config);
	}

	sub new {
		my(@teams)=map::teams;
		my($assign)=stash::get('assignTeam', map::name, 'map');

		%Stats=();
		%Reset=();
		$Hunted=undef;
		$Active=0;
		$Captured=0;

		player::reset;

		records::init;
		race::init;

		&restart_clear;
		&round;

		&build_planes;

		if(map::type('ruin')) {
			foreach my $mine (0, 1) {
				$Stats{$teams[$mine]}{'structure'}{'total'}=0;
				$Stats{$teams[$mine]}{'structure'}{'remaining'}=0;

				foreach my $structure (map::bases(), map::turrets()) {
					if(($assign && $structure->{'team'}!=$teams[$mine]) ||
						($structure->{'team'}==$teams[!$mine])
					) {
						$Stats{$teams[$mine]}{'structure'}{'total'}++;
						$Stats{$teams[$mine]}{'structure'}{'remaining'}++;
					}
				}
			}
		} elsif(map::type('1lh')) {
			my($health)=stash::get('spawnHealth', map::name, 'map');
			my($weapons)=stash::get('weapons', map::name, 'map');
			my($planes)=stash::get('planes', map::name, 'map');
			my($bip)={'Biplane,Heavy Cannon,,' => '+'};

			stash::set('spawnHealth', map::name, 'map', 1) unless($health);
			stash::set('weapons', map::name, 'map', 2) unless($weapons);
			stash::set('planes', map::name, 'map', $bip) unless($planes);
		}

		if(!stash::get(map::name, 'map') || stash::get('INIT', map::name, 'map')) {
			foreach my $command (&import_defaults) {
				server::send(server::parse_cmd($command));
			}
			stash::delete('INIT', map::name, 'map');
		}

		&zone_init() unless(stash::get('keys', map::name, 'map') & 1);
	}
		
	sub assign_teams {
		my($assign)=stash::get('assignTeam', map::name, 'map');

		if(map::mode('ffa')) {
			1; #team assignments not allowed
		} elsif(map::type('race')) {
			if($assign && race::on) {
				queue::schedule {
					foreach my $racer (race::list) {
						plus::assign($racer, $assign);
					}	
				} $config::Launcher{'warmup'}{map::mode}/4;
			}
		} elsif(map::type('coop')) {
			if($assign) {
				queue::schedule {
					foreach my $player (player::list('both')) {
						plus::assign($player, $assign);
					}
				} $config::Launcher{'warmup'}{map::mode}-4;
			}
		} elsif(!$assign && config::option('assignRank')) {
			queue::schedule {
				my($left, $right)=rank::teams(player::list('both'));

				ui::slog("all       :", join(',', map(player::name($_), player::list())));
				ui::slog("player    :", join(',', map(player::name($_), player::list('both'))));
				ui::slog("left  team:", join(',', map(player::name($_), @$left)));
				ui::slog("right team:", join(',', map(player::name($_), @$right)));

				#while(@$left || @$right) {
				#	plus::assign(shift(@$left), 'left') if(@$left);
				#	plus::assign(shift(@$right), 'right') if(@$right);
				#}
			} $config::Launcher{'warmup'}{map::mode}-3;
		}
	}

}

=head2 Downloading Maps

The B<alti+server> allows admin users access to download maps and restart
the server on-the-fly.  Great care is taken to ensure this can be done in
a secure way.  All file opens either use L<IPC::Open3> or perl's built-in
3+ argument C<open> function.  Additionally, file names and URL's are
reviewed for odd or special characters.

Besides security, a number of functions are available to map makers to
facilitate in map download and verifications.  Map makers have access
to added server commands like C<cksum> for 32-bit checksums, and C<md5>,
C<sha1>, and C<sha256> for stronger checksums.  Also, are download functions
which support scanning the L<http://altitudegame.com/map> web pages for 
easy map downloads.  Maps stored on this server can be downloads simply
with their name.

=cut

{	package file;

	my($Curl)=utils::which('curl', 'good', 'map uploads not possible');

	sub sum {
		my($sum, $file)=@_;
		my($cmd)=IO::Handle->new;
		my($output);

		open($cmd, '-|', $sum, $file);
		chomp($output=$cmd->getline);
		close($cmd);

		$output=~s/\s+\S+$//;

		return($output);
	}

	sub type {
		my($file)=@_;
		my($cmd)=IO::Handle->new;
		my($type);

		open($cmd, '-|', 'file', $file);
		chomp($type=$cmd->getline);
		close($cmd);

		return($type);
	}

	sub update_ctime {
		my($map)=@_;
		my(@st)=stat($map);

		if(chmod($st[2]&0777, $map)) {
			ui::slog('Updated last used time of', $map);
		} else {
			ui::slog('Failed to update the last used time of', $map);
		}
	}

	sub name_ok {
		local($_)=@_;
		my($mapdir)=config::option('mapDir');
		my($modere)=join('|', @MODES, @TYPES);

		s|^$INSTALL_ROOT/maps/$mapdir/*||;
		s|^$mapdir/*||;

		return(0) unless(m/^[\w.?!%:=+-]{5,}$/);
		return(0) unless(m/^($modere)_|^lobby/);
		return(0) if(m/\.\./);

		return(1);
	}

	sub url_ok {
		local($_)=@_;

		return(0) if(m/\.\./);
		if(m|^file:///var/tmp/([\w.?!%:=+-]+\.altx)|) {
			return(0)	unless(&name_ok($1));
		} else {
			return(0) unless(m/^(https?|ftps?):\/\/[\w.-]+\/[\w.;&?!%:\/=+-]*$/i);
		}

		return(1);
	}

	sub download {
		my($in, $out, $err)=(IO::Handle->new, IO::Handle->new, IO::Handle->new);
		my($eout);
		my($pid);

		ui::slog($Curl, @_);

		return(0) unless($Curl);
		return(0) unless(&url_ok($_[-1]));

		$pid=IPC::Open3::open3($in, $out, $err,
			$Curl, '-k', '-s', '--max-filesize', config::option('ulSizeLimit'), @_);

		$_=join('', <$out>);

		while($eout=<$err>) {
			chomp($eout);
			ui::slog($eout);
		}

		close($in);
		close($out);
		close($err);

		waitpid($pid, 0);
		ui::slog('ERROR : CURL EXIT STATUS:', $?>>8, $CURL_RV{$?>>8}) if($?);
	}

	sub altigame_download {
		my($file, $name)=@_;
		my($url)='https://altitudegame.com/map/?p=';
		local($_);

		return(0) unless(&name_ok($file));
		return(0) unless(&name_ok($name));

		foreach my $i (0 .. 25) {
			&download("$url$i");

			if(m|<a +href=".*?" *>\Q$name\E</a>.*?<a +href="(.*?)" *>download</a>|) {
				&download('-L', '-o', $file, $1);

				if(-s $file) {
					return(1);
				} else {
					unlink($file);
					return(0);
				}
			}
		}
		return(0);
	}
}

=head2 Join Timing

Some users take longer to join a server becuase they must first download the
map archive file.  This creates an imbalance in game objective and in teams.
As such, if download times are considered excessive for the game mode or type,
the B<alti+server> will restart the map.  For this to happen, the server
option C<restartMap> must be set to a value greater than 0, more than 1 player
must be downloading the map file, and the server will not wait longer than
the value of C<restartMap> in seconds for downloads to complete.

=cut

{	package dlfmhs;

	my(%Client)=();
	my($Map)=undef;
	my($Time)=undef;
	my($Count)=0;
	my($Max)=0;

	sub change_map {
		my($map)=@_;

		if(config::option('restartMapTime')) {
			%Client=();
			$Map=$map;
			$Time=time();
			$Count=0;
			$Max=0;
		}
	}

	sub prepare {
		my($map)=@_;

		return unless($Time);

		if(utils::delta($Time) > 10) {
			$Map=undef;
			$Time=undef;
		}
	}

	sub request {
		my($client)=@_;

		if($Map) {
			$Client{$client}=1;
			$Count++;
			$Max=$Count if($Max<$Count);
		}
	}

	sub complete {
		my($client)=@_;
		my($delta)=utils::delta($Time);
		my($warmup)=$config::Launcher{'warmup'}{map::mode}+2;
		my($limit)=config::option('restartMapTime')/2;
		my($types)=config::option('restartMapTypes');

		return unless(map::type(split(m/[\s,;|]+/, $types)));

		if(defined(delete($Client{$client}))) {
			$Count--;

			if($Count==1 && $Max>3 && $warmup<$delta && $delta<$limit) {
				chat::all('Downloads complete, restarting map ...');
				queue::schedule {
					server::send('changeMap', $Map);
				} 2;
			}
		}
	}

	sub remove {
		my($client)=@_;

		if(defined(delete($Client{$client}))) {
			$Count--;
			$Max--;
		}
	}

	sub release {
		my($map)=@_;
		my($delta)=utils::delta($Time);
		my($warmup)=$config::Launcher{'warmup'}{map::mode};
		my($limit)=config::option('restartMapTime');
		my($types)=config::option('restartMapTypes');

		return unless(map::type(split(m/[\s,;|]+/, $types)));
		return unless($map eq $Map);
		return unless($Time);

		if($Max>1 && $warmup < $delta && $delta < $limit) {
			chat::all('Map downloads complete, restarting map...');
			server::send('changeMap', $map);
		}

		$Map=undef;
		$Time=undef;
	}

}

=head2 Scripting

The B<alti+server> contains a scripting engine which allows hooks to be
added to events outside of the base B<alti+server> code.  Scripts are
loaded from a directory named F<alti+scripts> located the same directory
as the F<launcher_config.xml> file.  All files in this directory are
automatically loaded.

All scripts are loaded and run in the B<alti+server> runtime, there are
B<ZERO> protections.  This is necessary to ensure scripts can interact
fully with the server code.  A hash named C<%State> should be used to
keep state between calls to hooks.

A script is actually a perl hash definition which contains hooks for
events which will be thrown by the server.  So, your file would look like:

  #pretend people care about having player ID 0:
  my %cool_script = (
      'clientAdd' => sub {
          my($e, $p)=@_;

          chat::whisper($p, 'You beat the bots for the coveted player ID 0!')
              if($p->{'id'}==0);
      },

	 'clientRemove:pre' => sub {
          my($e, $p)=@_;

          chat::all('player ID 0 is free, disconnect and reconnect to get it!')
              if($p->{'id'}==0);
	 },
  );

By default, these hooks
will be executed after the server has internally serviced each hook.
However, you can explicitly set this behavior by placing a C<:pre>
or C<:post> string at the end of your hook name (e.g. C<clientRemove:pre>).

=cut

{	package script;

	use File::Basename;

	my(%State)=();
	my(%Script)=();
	my(@Scripts)=();
	my($Sdir)="$INSTALL_ROOT/servers/alti+scripts";

	mkdir($Sdir, 0750) unless(-d $Sdir);

	sub install {
		my($script)=IO::Handle->new;
		my(%script_hooks)=();
		my($name);
		local($/)=undef;

		foreach my $file (<$Sdir/*>) {
			next unless(-r $file);
			
			$name=basename($file);

			open($script, '<', $file);
			if(%script_hooks=eval(<$script>)) {
				foreach my $hook_key (keys(%script_hooks)) {
					if($hook_key=~m/:/) {
						$Script{$name}{$hook_key}=$script_hooks{$hook_key};
					} else {
						$Script{$name}{"$hook_key:post"}=$script_hooks{$hook_key};
					}
				}
				ui::slog("Loaded script: $name");
			} else {
				ui::slog("Failed to load script $name:", $@);
			}

		}

		@Scripts=sort(keys(%Script));
	}

	sub remove {
		foreach my $script (@_?@_:@Scripts) {
			ui::slog('|', 'Deleted script:', $script);
			delete($Script{$script});
		}

		@Scripts=sort(keys(%Script));
	}

	sub list {
		ui::slog('|', join(',', @Scripts));
	}

	sub pre {
		my($e, $p)=@_;
		my($type)=join(':', $e->{'type'}, 'pre');
		my($command)=join(':', $e->{'command'}, 'pre');

		foreach my $script (@Scripts) {
			if(ref($Script{$script}{$type}) eq 'CODE') {
				$Script{$script}{$type}->($e, $p);
			} elsif(ref($Script{$script}{$command}) eq 'CODE') {
				$Script{$script}{$command}->($e, $p);
			}
		}
	}

	sub post {
		my($e, $p)=@_;
		my($type)=join(':', $e->{'type'}, 'post');
		my($command)=join(':', $e->{'command'}, 'post');

		foreach my $script (@Scripts) {
			if(ref($Script{$script}{$type}) eq 'CODE') {
				$Script{$script}{$type}->($e, $p);
			} elsif(ref($Script{$script}{$command}) eq 'CODE') {
				$Script{$script}{$command}->($e, $p);
			}
		}
	}

}

=head2 Normalized Hook Management

The B<alti+server> makes supporting log hooks easier by normalizing the
hook arguments.  Each hook is called with two arguments: the event data
structure, and the person data structure for the player in question.  Most
hooks would otherwise have to have code to lookup a player from the event
details.  This method eliminates that, and provides for less overall code.

=cut

sub event {
	my($event)=@_;
	my($player)=undef;
	
	unless($config::Clock==1000) {
		$event->{'time'}*=1000/$config::Clock;
	}

	if($event->{'group'} eq 'server') {
		$player=player::server;
	} elsif($event->{'source'} eq '00000000-0000-0000-0000-000000000000') {
		$player=player::server;
	} else {
		$player=player::event_search($event);
	}

	if($event->{'group'} eq 'server') {
		$event->{'admin'}=1;
		$event->{'superAdmin'}=1;
	} elsif($event->{'group'} eq 'Administrator') {
		$event->{'admin'}=1;
		if(config::option('superAdmin') eq 'list') {
			$event->{'superAdmin'}=$player->{'superAdmin'};
		} else {
			$event->{'superAdmin'}=1;
		}
	} else {
		$event->{'admin'}=0;
		$event->{'superAdmin'}=0;
	}

	return($event, $player);
}

=head2 Snarky Server Responses

The B<alti+server> will periodically emit snarky comments about player's
choices of planes, perks, or skins.  This is, of course, as long as the
C<snarkChance> flag is set to a true value in the C<OPTIONS> configuration at
the top of the B<alti+server> code file.  The server will take the value of
C<snarkChance> and multiply it by the number of players.  Then, for each
even which has snarks associated with it, there will be a 1 in that many
chance of a snarky comment being made.

These are not meant to be a large distraction from the game, but instead to
make players chuckle.  The comments should be infrequent.

Setting C<snarkChance> to 0 will also disable server lauds.  These are
congratulations for a pass, nice goal, etc.  If C<snarkChance> is set to
a non-zero value, these laudable activities are mentioned for each occurance.
Frankly, people don't pass enough, this is enabled to try to coax more
and better passing in the game.

=cut

my(%SNARKS)=(
	"%s, pick a nick already!"
			=> { 'nickname'=> 'Guest_' },

	"%s can't aim"
			=> { 'perkRed' => 'Tracker' },

	"%s is toxic"
			=> { 'perkRed' => 'Acid Bomb' },

	"%s likes to drop bombs on your head"
			=> { 'perkRed' => 'Bombs' },

	"I wouldn't fly behind %s"
			=> { 'perkRed' => 'Flak Tailgun' },

	"%s's other vehicle is a DeLorean"
			=> { 'perkRed' => 'Time Anchor' },

	"%s dares you to fly near a wall"
			=> { 'perkRed' => 'Director|Thermobarics' },

	"%s says rat-tat-tat-tat-tat"
			=> { 'perkRed' => 'Recoilless Gun' },

	"%s brought out the big gun"
			=> { 'perkRed' => 'Heavy Cannon' },

	"%s bounces, but recovers well"
			=> { 'perkGreen' => 'Rubberized Hull' },

	"%s can turn on a dime"
			=> { 'perkGreen' => 'Flexible Wings' },

	"%s needs a backup camera"
			=> { 'perkBlue' => 'Reverse Thrust' },

	"%s is an ace"
			=> { 'perkBlue' => 'Ace Instincts' },

	"%s says Grrrr"
			=> { 'skin' => 'Shark Skin' },

	"%s is on fire"
			=> { 'skin' => 'Flame Skin' },

	"%s is trying to hide"
			=> { 'skin' => 'Zebra Skin' },

	"%s, how about a nice game of chess?"
			=> { 'skin' => 'Checker Skin' },

	"%s says Ho Ho Ho!"
			=> { 'skin' => 'Santa Hat' },

	"You know, I have one simple request.  And that is to have sharks with frickin' laser beams attached to their heads!"
			=> { 'skin' => 'Shark Skin', 'perkRed' => 'Laser' },
);

=head2 Levels

The default Altitude level check is equal to any Ace level.  This might not
work for all servers.  B<alti+server> allows you to specify a different
milestone for Ace 0 players vs Ace 1-10 players.  This allows for keeping
games competitive, and also serves to discourage smurfing.

=cut

my(%MILESTONES)=(
	2	=> 'green perk',
	6	=> 'bomber',
	8	=> 'blue perk',
	11	=> 'whale',
	13	=> 'heavy armor',
	16	=> 'bip',
	18	=> 'ultracapacitor',
	21	=> 'all planes',
	24	=> 'double fire',
	27	=> 'dumb bombs',
	30	=> 'repair',
	32	=> 'thermobarics',
	35	=> 'recoiless gun',
	38	=> 'laser',
	41	=> 'rev',
	44	=> 'acid',
	47	=> 'flak gun',
	50	=> 'flexi-wings',
	53	=> 'remote',
	56	=> 'heavy cannon',
	58	=> 'time anchor',
	60	=> 'all perks'
);

=head2 Log Parsing and Hooks

The main interface for B<alti+server> to see what is going on with the
Altitude game engine is the F<log.txt> file.  B<alti+server> reads this
file continuously and interprets the entries.  Hooks are considered to be
any of the following:

=over 8

=item type="x"

These are events generated directly by the Altitude game engine.  They
can be events which happened in a game, notifications about changes, or
the result of a user request.  A hook name of C<x> will be executed
each type an event of type="x" is seen in the log file.

=item command="y" type="consoleCommandExecute"

These are events generated either by players or by the B<alti+server> code
itself.  This is the method by which B<alti+server> supports commands
added to the F<custom_json_commands.txt> file.  Each time a log entry is
made where command="y", the hook named C<y> will be executed.

=item type="x" when triggered by hook "z"

The B<alti+server> contains it's own trigger mechanism.  Not all commands
execute by players, the server, or events thrown by the Altitude game engine
contain enough information to complete a request.  In these cases, the
hook code for C<z> will generate a request for the server to execute an
additional command C<x>.  When C<x> is run, B<alti+server> looks for a hook
named C<x:z>, and runs it instead of the normally defined hook for C<x>.
The triggered code will then complete the original request with information
from both the original hook C<z>, and the new one C<x>.

=back

=head2 Game Extensions

Some of the extensions provided by the B<alti+server> are:

=over 8

=item Messaging

Users can utilize the server to facilitate private communication.  The main
purpose of this is for map makers to offer suggestions to players testing
out a map.  Also, this works well in reverse.  If a player would like to
bring up a point regarding game play private to the map map maker.  In case
of abuse, users can disable this feature.

=item Managed Map Downloads

The server supports 3 methods to download new maps.  People often store maps
on the altitudegame.com/map/ (the original map testing) site; maps can be
downloads from here with just their name.  Another location where maps are
often stored are on the Ladder servers, here maps can also be downloaded
by name.  Finally, for other maps a download method for arbitrary URLs is
supported; this method will not work for javascript enabled downloads.
Conversely, a method also exists to remove maps from the server.

=item Map Specific Settings

Each map can have its own gravity, scale, team enforcement, spawn location,
etc. settings.  Hooks exist for adding/changing/deleting these settings 
on a per-map basis.  Each time a new map loads, these settings are made
by B<alti+server>, so the game can be played as designed each time without
user interaction.

=item Spawn Enhancements

A number of spawn possibilities are created by B<alti+server>.  Players
can spawn normally as always.  However, the additional methods are also
available:
died (players spawn where they last died),
zone (players can manually choose the location where they spawn),
near (players spawn at the nearest defined zone location to where they die),
after (players spawn at the closest passed zone location to where they die),
portal (players use any number of listed health powerups and are respawned in a different location), 
health (players spawn at the location where they pickup their last health),
powerup (players spawn where they picked up their last powerup of any kind).

The C<after> spawn type is very powerful, but must be used with a full
understanding of how it works.  Each spawn zone is a 3-tuple of x-coord,
y-coord, and angle.  Spawn mode C<after> spawns a player at the spawn zone
which is the closest to their location of death AND for which the player
has past the spawn zone.  A player is defined as being past a spawn point
if the spawn point and angle are used to create a perpendicular line to
the spawn angle, and the player is on the part of the map which coincides
with the nose of a plane spawning in that zone.  This method cannot be used
on all maps; ones which generally progress in the same direction (football,
many coop maps, ...) are appropriate for this spawn type.

Additionally, an angle override may be specified.  By appending a comma ','
and one of the following keywords:
center (always spawn facing the center of the map),
hmirror (always spawn facing the map axis),
vmirror (always spawn facing the middle bisect).


=item Plane Limitations

A map can have only specified plane types allowed.  This is helpful in certain
"capture the flag" game types, where by whales can wildly disrupt the inner
core protecting the flag.

=back

=cut

%HOOKS=(
	'!'			=> sub {	#Admin command for configSize='tiny'
		my($e, $p)=@_;
		my($args)=join(' ', @{$e->{'arguments'}});
		my(@params);

		unless($e->{'admin'}) {
			chat::whisper($p, 'You are not an admin');
			return;
		}

		if($args=~s/^\s*(\S+)\s*//) {
			$e->{'command'}=$1;
			$e->{'arguments'}=[];
			@params=config::arguments($e->{'command'});
		} else {
			chat::whisper($p, 'Empty command ignored');
			return;
		}

		while(@params>1) {
			if($args=~s/^\s*(".*?"|".*$|\S+)\s*//) {
				push(@{$e->{'arguments'}}, $1);
				$e->{'arguments'}[-1]=~s/^"//;
				$e->{'arguments'}[-1]=~s/"$//;
				shift(@params);
			} else {
				chat::whisper($p, 'Missing arguments:', $e->{'command'});
				return;
			}
		}
		push(@{$e->{'arguments'}}, $args) if($args);

		if(exists($HOOKS{$e->{'command'}})) {
			$HOOKS{$e->{'command'}}->($e, $p);
		} else {
			chat::whisper($p, 'Invalid command:', $e->{'command'});
		}
	},

	'help'		=> sub {
		my($e, $p)=@_;
		my($type)=@{$e->{'arguments'}};
		my(@lookup);

		if(exists($HOOKS{"help $type"})) {
			$HOOKS{"help $type"}->($e, $p);
			if(config::option('configSize')=~m/small/i) {
				chat::whisper($p, 'Admin commands use `/! cmd ...` syntax');
			}
		} elsif(@lookup=grep(m/help $type.*/i, keys(%HOOKS))) {
			if(@lookup==1) {
				$HOOKS{$lookup[0]}->($e, $p);
			} else {
				config::command_help($p, 'help');
			}
		} else {
			config::command_help($p, 'help');
		}
	},

	'?'			=> sub {
		$HOOKS{'help'}->(@_);
	},

	'list'		=> sub {
		my($e, $p)=@_;
		my($type)=@{$e->{'arguments'}};
		my(@lookup);

		if(exists($HOOKS{"list $type"})) {
			$HOOKS{"list $type"}->($e, $p);
		} elsif(@lookup=grep(m/list $type.*/i, keys(%HOOKS))) {
			if(@lookup==1) {
				$HOOKS{$lookup[0]}->($e, $p);
			} else {
				config::command_help($p, 'list');
			}
		} else {
			config::command_help($p, 'list');
		}
	},

	'l'			=> sub {
		$HOOKS{'list'}->(@_);
	},

	'set'		=> sub {
		my($e, $p)=@_;
		my($type, $args)=@{$e->{'arguments'}};
		my(@args);

		if($type=~m/intro/) {
			@args=($args);
		} else {
			@args=($args=~m/(".*?"|".*$|[^\s,]+)/g);
		}

		return unless($e->{'admin'});

		if(exists($HOOKS{"set $type"})) {
			$HOOKS{"set $type"}->($e, $p, @args);
		} else {
			config::command_help($p, 'set');
		}
	},

	'unset'		=> sub {
		my($e, $p)=@_;
		my($type)=@{$e->{'arguments'}};

		return unless($e->{'admin'});

		if(exists($HOOKS{"unset $type"})) {
			$HOOKS{"unset $type"}->($e, $p);
		} else {
			config::command_help($p, 'unset');
		}
	},

	'add'		=> sub {
		my($e, $p)=@_;
		my($type, $args)=@{$e->{'arguments'}};
		my(@args);

		@args=($args=~m/(".*?"|".*$|[^\s,]+)/g);

		return unless($e->{'admin'});

		if(exists($HOOKS{"add $type"})) {
			$HOOKS{"add $type"}->($e, $p, @args);
		} else {
			config::command_help($p, 'add');
		}
	},

	'timer'		=> sub {
		my($e, $p)=@_;
		my($time)=@{$e->{'arguments'}};
		my($change);

		return unless(xx::enabled);

		if($time eq '') {
			server::send('getTime');
		} elsif($time=~m/^[+-]/) {
			server::trigger('getTime', 'deltaTime', $e, $p);
		} else {
			if($time=~m/(\d+):(\d+)/) {
				$time=$1*60+$2;
			}

			xx::set_time($time);
		}
	},

	'getTime:deltaTime'	=> sub {
		my($e1, $p1, $e2, $p2)=@_;
		my($current)=$e1->{'roundTimeTicks'}/30;
		my($delta)=@{$e2->{'arguments'}};
		my($change, $direction);

		if($delta=~s/^\+//) {
			$direction=-1;
		} elsif($delta=~s/^-//) {
			$direction=1;
		} else {
			ui::slog('invalid attempt to change timer');
			return;
		}

		if($delta=~m/(\d+):(\d+)/) {
			$delta=$1*60+$2;
		}

		xx::set_time($current + $delta*$direction);
	},
	
	'getTime' => sub {
		my($e, $p)=@_;
		my($limit, $used)=map::timer;
		my($timer);

		return unless(exists($e->{'roundTimeTicks'}));

		$timer=$limit - $e->{'roundTimeTicks'}/30;

		chat::whisperf($p, '%d:%02d', $timer/60, $timer%60);
	},

	'del'		=> sub {
		my($e, $p)=@_;
		my($type, $args)=@{$e->{'arguments'}};
		my(@args);

		@args=($args=~m/(".*?"|".*$|[^\s,]+)/g);

		return unless($e->{'admin'});

		if(exists($HOOKS{"del $type"})) {
			$HOOKS{"del $type"}->($e, $p, @args);
		} else {
			config::command_help($p, 'del');
		}
	},

	'who'		=> sub {
		my($e, $p)=@_;
		my($who)=player::lookup($e->{'arguments'}[0]);
		my($name)=$who->{'nickname'};
		my($ip)=$who->{'ip'};
		my(@aliases)=();

		if($who->{'name'}) {
			$name.=" ($who->{'name'})";
		}
		if($who->{'country'}) {
			$ip.="($who->{'country'})";
		}
		if(db::enabled) {
			@aliases=db::select('aliases', qq{vaporid='$who->{"vaporId"}'});
		}
		
		if(@aliases>1) {
			chat::whisperf($p, '%s, IP: %s, AKA: %s', $name, $ip,
				join(', ', map($_->{'nickname'}, @aliases)));
		} else {
			chat::whisperf($p, '%s, IP: %s', $name, $ip);
		}
	},

	'abuse'		=> sub {
		my($e, $p)=@_;
		my($a)=player::lookup($e->{'arguments'}[0]);
		my($type)=$e->{'arguments'}[1];
		my($last)=stash::get('last', $a->{'vaporId'}, 'abuse');
		my($count)=stash::get('count', $a->{'vaporId'}, 'abuse');
		my($today)=sprintf('%.1f', time()/86400);
		my($anick)=$a->{'nickname'};
		my($ip)=$a->{'ip'};
		my(@duration);

		unless($anick) {
			chat::whisper($p, "player $e->{'arguments'}[0] is invalid value");
			return;
		}

		unless($p->{'admin'} || $p->{'moderator'}) {
			chat::whisper($p, 'Only Admins and Moderators may use abuse');
			return;
		}

		$ip=~s/:.*$//;

		if($today-$last > 30) {
			$count-=3;
		} elsif($today-$last > 10) {
			$count-=2;
		} elsif($today-$last > 4) {
			$count-=1;
		} else {
			$count+=1;
		}

		$count=1 if($count<1);

		if($count==1) {
			@duration=qw( 3 hour );
		} elsif($count==2) {
			@duration=qw( 1 day );
		} elsif($count==3) {
			@duration=qw( 3 day );
		} else {
			@duration=qw( 1 week );
		}

		if($type=~m/chat/i) {
			chat::whisper($a, 'Stop abusing chat');
			server::send('addChatBlock', $a->{'vaporId'}, 'AllChat',
				@duration, 'Stop abusing chat');
			server::send('addChatBlock', $ip, 'AllChat',
				@duration, 'Stop abusing chat');
			player::infraction($a, 1);
		} elsif($type=~m/ban/i) {
			server::send('ban', $anick, @duration, 'You are in time out, go to your quiet corner!');
		} elsif($type=~m/nick/i) {
			stash::set('nick', $a->{'vaporId'}, 'abuse', $anick);
			chat::whisper($a, 'If you want to play on this server, change your nickname');
			queue::schedule {
				chat::whisper($a, 'If you do not change your nickname, you will be kicked');
			} 5;
			queue::schedule {
				server::send('kick', $anick);
			} 20;
			player::infraction($a, 2);
		} elsif($type=~m/rude/i) {
			player::infraction($a, 5);
			chat::whisper($a, 'You are being rude, knock it off or get kicked');
		} else {
			chat::whisper($a, '/abuse [chat|ban|nick|rude] [player]');
		}

		stash::set('last', $a->{'vaporId'}, 'abuse', $today);
		stash::set('count', $a->{'vaporId'}, 'abuse', $count);
	},

	'upload'		=> sub {
		my($e, $p)=@_;
		my($type, $args)=@{$e->{'arguments'}};
		my(@args);

		@args=server::parse_cmd($args);

		return unless($e->{'superAdmin'});

		if(exists($HOOKS{"upload $type"})) {
			$HOOKS{"upload $type"}->($e, $p, @args);
		} else {
			config::command_help($p, 'upload');
		}
	},

	'tournamentStart'		=> sub {
		my($e, $p)=@_;

		tourney::members($e->{'team0'}, $e->{'team1'});
	},

	'tournamentModified'	=> sub {
		my($e, $p)=@_;

		tourney::members($e->{'team0'}, $e->{'team1'});
	},

	'tournamentStop'		=> sub {
		tourney::clear;
	},

	'raceMap' => sub {
		my($e, $p)=@_;
		my($map)=@{$e->{'arguments'}};

		ball::set_score(0, 0);

		race::set_map($map);
		chat::whisper($p, "Will start map: $map");
	},

	'raceStart' => sub {
		my($e, $p)=@_;

		ball::set_score(0, 0);

		unless(race::count) {
			foreach my $player (player::list) {
				race::add($player);
			}
		}

		race::set_map(map::name) unless(race::map);

		#race::request_go;
		race::start_now;
	},

	'raceCancel' => sub {
		my($e, $p)=@_;

		race::cancel;
	},

	'raceGoals'	=> sub {
		my($e, $p)=@_;
		my($goals)=@{$e->{'arguments'}};

		race::set_goals($goals);
		chat::whisper($p, "Winning number of goals: $goals");
	},

	'raceList' => sub {
		my($e, $p)=@_;
		my(%racers); tie %racers, 'Tie::RefHash';

		%racers=race::racers;

		foreach my $r (keys(%racers)) {
			if($racers{$r}==1) {
				chat::whisper($p, 'entered :',
					$r->{'nickname'}, $r->{'vaporId'});
			} elsif($racers{$r}==2) {
				chat::whisper($p, 'ready   :',
					$r->{'nickname'}, $r->{'vaporId'});
			} else {
				chat::whisper($p, 'finished:',
					$r->{'nickname'}, $r->{'vaporId'});
			}
		}
	},

	'raceAdd' => sub {
		my($e, $p)=@_;
		my($racer)=player::lookup($e->{'arguments'}[0]);

		ball::set_score(0, 0);

		race::add($racer);
		chat::whisper($p, 'Add:', $racer->{'nickname'}, $racer->{'vaporId'});
	},

	'raceDel' => sub {
		my($e, $p)=@_;
		my($racer)=player::lookup($e->{'arguments'}[0]);

		race::del($racer);
		chat::whisper($p, 'Del:', $racer->{'nickname'}, $racer->{'vaporId'});
	},

	'go' => sub {
		my($e, $p)=@_;

		race::ready($p);
	},

	'switch'	=> sub {
		my($e, $p)=@_;

		if(map::mode('ffa')) {
			chat::whisper($p, '/switch does not function in ffa');
		} elsif($p->{'carrier'}) {
			chat::whisper($p, 'You cannot /switch as a carrier');
		} else {
			plus::assign($p, 'spec');
			chat::whisper($p, 'Spectating, press `t` to join a team');
		}
	},

	'mesg'	=> sub {
		my($e, $p)=@_;
		local($_)=$e->{'arguments'}[0];

		if(m/y(es)?|1/i) {
			$p->{'block'}=0;
			if(db::enabled) {
				db::player($p, {'block' => 0});
			} else {
				stash::delete('block', $p->{'vaporId'}, 'player');
			}
			chat::whisper($p, "Private on-server messaging enabled");
		} elsif(m/no?|0/i) {
			$p->{'block'}=1;
			if(db::enabled) {
				db::player($p, {'block' => 1});
			} else {
				stash::set('block', $p->{'vaporId'}, 'player', 1);
			}
			chat::whisper($p, "Private on-server messaging disabled");
		} else {
			if($p->{'block'}) {
				chat::whisper($p, "Private on-server messaging disabled");
			} else {
				chat::whisper($p, "Private on-server messaging enabled");
			}
		}
	},

	'vote'	=> sub {
		my($e, $p)=@_;
		my($cmd, @args)=@{$e->{'arguments'}};
		our($kicker, $kickee);

		ui::display('','', "$p->{'nickname'} proposed: $cmd @args");

		if(config::option('bullyKick') && $cmd eq 'kick') {
			$kicker=$p;
			$kickee=$args[0];
			player::infraction($kicker, 1);
		}
	},

	'castBallot'	=> sub {
		my($e, $p)=@_;
		my($vote)=shift(@{$e->{'arguments'}});

		ui::display($p->{'nickname'}, 'vote', $vote);
	},

	'kick'	=> sub {
		my($e, $p)=@_;
		my($nick)=shift(@{$e->{'arguments'}});
		our($kicker, $kickee);

		records::help($p, -100);

		if($nick eq $kickee && ref($kicker) eq 'HASH') {
			player::forgive($kicker);
			undef($kicker);
		}
	},

	'talk'	=> sub {
		my($e, $p)=@_;
		my($to)=player::lookup(shift(@{$e->{'arguments'}}));
		my($msg)=join(' ', @{$e->{'arguments'}});

		if(config::language($msg)) {
			chat::whisper($p, "message not sent");
			chat::whisper($p, 'language(', player::infraction($p, 1), ')');
		} elsif(config::harrasment($msg)) {
			player::infraction($p, 0.3);
		} elsif($p->{'nickname'} eq 'server') {
			chat::whisper($to, $msg);
		} elsif(!stash::get('block', $to->{'vaporId'}, 'player')) {
			ui::chat_log($to->{'nickname'}, $p->{'nickname'}, $msg);
			server::send('serverWhisper', $to->{'nickname'}, "$p->{'nickname'}> $msg");
		} else {
			chat::whisper($p, "private messaging is disabled for $to->{'nickname'}");
		}
		
	},

	'help altitudegame'	=> sub {
		my($e, $p)=@_;
		chat::whisper($p, '/upload altitudegame <map>');
		chat::whisper($p, ' map: name is exactly as it appears on the website');
		chat::whisper($p, ' Upload maps FROM http://altitudegame.com/map/');
	},

	'upload altitudegame'	=> sub {
		my($e, $p, $name)=@_;
		my($mapdir)=config::option('mapDir');
		my($maps)="$INSTALL_ROOT/maps/$mapdir";
		my($mapname, $file, $mapconfig);

		$name=~s|^$mapdir/*|| if($mapdir);
		$name=~s|\.altx$||;
		$name=~s|\s+|_|g;

		unless(file::name_ok($name)) {
			chat::whisper($p, "map name $name does not follow standard");
			return(0);
		}

		if($mapdir) {
			$mapname="$mapdir/$name";
		} else {
			$mapname=$name;
		}
		$file="$maps/$mapname.altx";

		if(file::altigame_download($file, $name)) {
			if(-s $file > config::option('ulSizeLimit')) {
				unlink($file);
				chat::whisper($p, "$mapname too big");
			} elsif(file::type($file)!~m/LZMA compressed data/) {
				unlink($file);
				chat::whisper($p, "$mapname is not the right type");
				chat::whisper($p, "maybe redirect failure, or a javascript enabled download");
			} else {
				if(config::new_maps($mapname)) {
					chat::whisper($p,
						"Map added to config, you must /restartServer");

					if($mapconfig=stash::retrieve($mapname, 'map')) {
						stash::set($mapname, 'map', $mapconfig);
					}
				}
				stash::set('INIT', $mapname, 'map', 1);
				chat::all("$mapname updated");
			}
		} else {
			chat::whisper($p, "Could not download $name from altitudegame.com/map/");
		}
	},

	'help official'	=> sub {
		my($e, $p)=@_;
		chat::whisper($p, '/upload official <map>');
		chat::whisper($p, ' map: name of official map');
		chat::whisper($p, ' Upload maps FROM http://maps.altitudegame.com/');
	},

	'upload official'	=> sub {
		my($e, $p, $name)=@_;
		my($mapdir)=config::option('mapDir');
		my($maps)="$INSTALL_ROOT/maps/$mapdir";
		my($url)="http://maps.altitudegame.com/";
		my($mapname, $file, $key, $mapconfig);
		local($_);

		$name=~s|^$mapdir/*|| if($mapdir);
		$name=~s|\.altx$||;
		$name=~s|\s+|_|g;

		unless(file::name_ok($name)) {
			chat::whisper($p, "map name $name does not follow standard");
			return(0);
		}

		if($mapdir) {
			$mapname="$mapdir/$name";
		} else {
			$mapname=$name;
		}
		$file="$maps/$mapname.altx";

		file::download($url);
		unless(($key)=m|<Key>([0-9.]+/$name.altx)</Key>|i) {
			chat::whisper($p, "$name not indexed on maps.altitudegame.com");
			return(0);
		}
		
		file::download('-L', '-o', $file, $url.$key);

		if(-s $file < 1024) {
			unlink($file);
			chat::whisper($p, "Could not find $name on maps.altitudegame.com");
		} elsif(-s $file > config::option('ulSizeLimit')) {
			unlink($file);
			chat::whisper($p, "$mapname too big");
		} elsif(file::type($file)!~m/LZMA compressed data/) {
			unlink($file);
			chat::whisper($p, "$mapname is not the right type, download failure");
		} else {
			if(config::new_maps($mapname)) {
				chat::whisper($p,
					"Map added to config, you must /restartServer");

				if($mapconfig=stash::retrieve($mapname, 'map')) {
					stash::set($mapname, 'map', $mapconfig);
				}
			}
			stash::set('INIT', $mapname, 'map', 1);
			chat::all("$mapname updated");
		}
	},

	'help alti+'	=> sub {
		my($e, $p)=@_;
		chat::whisper($p, '/upload alti+ <map>');
		chat::whisper($p, ' map: name of Alti+ map');
		chat::whisper($p, ' Upload maps FROM https://github.com/biell/alti-maps/raw/master/maps/');
	},

	'upload alti+'	=> sub {
		my($e, $p, $name)=@_;
		my($mapdir)=config::option('mapDir');
		my($maps)="$INSTALL_ROOT/maps/$mapdir";
		my($url)='https://github.com/biell/alti-maps/raw/master/maps/%s.altx';
		my($mapname, $file, $mapconfig);

		$name=~s|^$mapdir/*|| if($mapdir);
		$name=~s|\.altx$||;
		$name=~s|\s+|_|g;

		unless(file::name_ok($name)) {
			chat::whisper($p, "map name $name does not follow standard");
			return(0);
		}

		if($mapdir) {
			$mapname="$mapdir/$name";
		} else {
			$mapname=$name;
		}
		$file="$maps/$mapname.altx";

		file::download('-L', '-o', $file, sprintf($url, $name));

		if(-s $file < 1024) {
			unlink($file);
			chat::whisper($p, "Could not find $name on Alti+ maps github site");
		} elsif(-s $file > config::option('ulSizeLimit')) {
			unlink($file);
			chat::whisper($p, "$mapname too big");
		} elsif(file::type($file)!~m/LZMA compressed data/) {
			unlink($file);
			chat::whisper($p, "$mapname is not the right type");
			chat::whisper($p, "maybe redirect failure, or a javascript enabled download");
		} else {
			if(config::new_maps($mapname)) {
				chat::whisper($p,
					"Map added to config, you must /restartServer");

				if($mapconfig=stash::retrieve($mapname, 'map')) {
					stash::set($mapname, 'map', $mapconfig);
				}
			}
			stash::set('INIT', $mapname, 'map', 1);
			chat::all("$mapname updated");
		}
	},

	'help ladder'	=> sub {
		my($e, $p)=@_;
		chat::whisper($p, '/upload ladder <map>');
		chat::whisper($p, ' map: name is exactly as it when running in ladder');
		chat::whisper($p, ' Upload maps FROM http://maps.planeball.com/');
	},

	'upload ladder'	=> sub {
		my($e, $p, $name)=@_;
		my($mapdir)=config::option('mapDir');
		my($maps)="$INSTALL_ROOT/maps/$mapdir";
		my($url)="http://maps.planeball.com/%s.altx";
		my($mapname, $file, $mapconfig);

		$name=~s|^$mapdir/*|| if($mapdir);
		$name=~s|\.altx$||;
		$name=~s|\s+|_|g;

		unless(file::name_ok($name)) {
			chat::whisper($p, "map name $name does not follow standard");
			return(0);
		}

		if($mapdir) {
			$mapname="$mapdir/$name";
		} else {
			$mapname=$name;
		}
		$file="$maps/$mapname.altx";

		file::download('-L', '-o', $file, sprintf($url, $name));

		if(-s $file < 1024) {
			unlink($file);
			chat::whisper($p, "Could not find $name on maps.planeball.com");
		} elsif(-s $file > config::option('ulSizeLimit')) {
			unlink($file);
			chat::whisper($p, "$mapname too big");
		} elsif(file::type($file)!~m/LZMA compressed data/) {
			unlink($file);
			chat::whisper($p, "$mapname is not the right type");
			chat::whisper($p, "maybe redirect failure, or a javascript enabled download");
		} else {
			if(config::new_maps($mapname)) {
				chat::whisper($p,
					"Map added to config, you must /restartServer");

				if($mapconfig=stash::retrieve($mapname, 'map')) {
					stash::set($mapname, 'map', $mapconfig);
				}
			}
			stash::set('INIT', $mapname, 'map', 1);
			chat::all("$mapname updated");
		}
	},

	'help tinyupload'		=> sub {
		my($e, $p)=@_;
		chat::whisper($p, '/upload tinyupload <key>');
		chat::whisper($p, ' key: 20 digit file_id decimal key');
		chat::whisper($p, ' You only need to enter key after "file_id"');
	},

	'upload tinyupload'		=> sub {
		my($e, $p, $key)=@_;
		my($mapdir)=config::option('mapDir');
		my($maps)="$INSTALL_ROOT/maps/$mapdir";
		my($url)='http://s000.tinyupload.com/';
		my($name, $next, $mapname, $file, $mapconfig);
		local($_);

		return(0) unless(utils::is_int($key));

		file::download("$url?file_id=$key");

		($next, $name)=m|<a href="(download.php.*?)"><b>(\w+).altx</b></a>|i;

		$name=~s|\s+|_|g;

		return(0) unless(file::name_ok($name));
		return(0) unless(file::url_ok("$url$next"));

		if($mapdir) {
			$mapname="$mapdir/$name";
		} else {
			$mapname=$name;
		}
		$file="$maps/$mapname.altx";

		file::download('-L', '-o', $file, "$url$next");

		if($name) {
			if(-s $file > config::option('ulSizeLimit')) {
				unlink($file);
				chat::whisper($p, "$mapname too big");
			} elsif(file::type($file)!~m/LZMA compressed data/) {
				unlink($file);
				chat::whisper($p, "$mapname is not the right type");
				chat::whisper($p, "maybe redirect failure, or a javascript enabled download");
			} else {
				if(config::new_maps($mapname)) {
					chat::whisper($p,
						"Map added to config, you must /restartServer");

					if($mapconfig=stash::retrieve($mapname, 'map')) {
						stash::set($mapname, 'map', $mapconfig);
					}
				}
				stash::set('INIT', $mapname, 'map', 1);
				chat::all("$mapname updated");
			}
		} else {
			chat::whisper($p, "Could not download $name from tinyupload.com");
		}
	},

	'help url'		=> sub {
		my($e, $p)=@_;
		chat::whisper($p, '/upload url <map> <url>');
		chat::whisper($p, ' map: name exactly as you want it to appear in the game');
		chat::whisper($p, ' url: the full URL (incld http://) of the map. Javascript enabled downloads do not work.');
	},

	'upload url'		=> sub {
		my($e, $p, $name, $url)=@_;
		my($mapdir)=config::option('mapDir');
		my($maps)="$INSTALL_ROOT/maps/$mapdir";
		my($mapname, $file, $mapconfig);

		$name=~s|^$mapdir/*|| if($mapdir);
		$name=~s|\.altx$||;
		$name=~s|\s+|_|g;

		return(0) unless(file::name_ok($name));
		return(0) unless(file::url_ok($url));

		if($mapdir) {
			$mapname="$mapdir/$name";
		} else {
			$mapname=$name;
		}
		$file="$maps/$mapname.altx";

		file::download('-L', '-o', $file, $url);

		if(-s $file > config::option('ulSizeLimit')) {
			unlink($file);
			chat::whisper($p, "$mapname too big");
		} elsif(file::type($file)!~m/LZMA compressed data/) {
			unlink($file);
			chat::whisper($p, "$mapname is not the right type");
			chat::whisper($p, "maybe redirect failure, or a javascript enabled download");
		} else {
			if(config::new_maps($mapname)) {
				chat::whisper($p,
					"Map added to config, you must /restartServer");

				if($mapconfig=stash::retrieve($mapname, 'map')) {
					stash::set($mapname, 'map', $mapconfig);
				}
			}
			stash::set('INIT', $mapname, 'map', 1);
			chat::all("$mapname updated");
		}
	},

	#
	## Change map to random map as requested by players/admin
	'randomMap' => sub {
		my($e, $p)=@_;
		my($next)=stash::get('nextMap', 'admin');

		if($next) {
			server::send('changeMap', $next);
			map::choices($next);
			stash::delete('nextMap', 'admin');
		} else {
			server::send('changeMap', config::random_map);
		}
	},

	'removeMap'		=> sub {
		my($e, $p)=@_;
		my($mapdir)=config::option('mapDir');
		my($maps)="$INSTALL_ROOT/maps/$mapdir";
		my($mapname, $file);

		return(0) unless($e->{'superAdmin'});

		$e->{'arguments'}[0]=~s|^$mapdir/*|| if($mapdir);
		$e->{'arguments'}[0]=~s|\.altx$||;
		$e->{'arguments'}[0]=~s|\s+|_|g;

		return(0) unless(file::name_ok($e->{'arguments'}[0]));

		$mapname="$mapdir/$e->{'arguments'}[0]";
		$mapname=~s|^/+||;
		$file="$maps/$mapname.altx";

		if(-r $file) {
			if(map::name($mapname)) {
				server::send('changeMap', config::random_map)
			}

			stash::archive($mapname, 'map');

			unlink($file);

			#Should we be cleaning up the cache and server-unpacked-maps.xml?

			if(config::remove_maps($mapname)) {
				chat::whisper($p,
					"Map removed from config, you must /restartServer");
			}
			chat::all("$mapname deleted");
		}
	},

	'rank'		=> sub {
		my($e, $p)=@_;
		my($search)=@{$e->{'arguments'}};
		my($typere)=join('|', @MODES, @TYPES);
		my($type);

		if($search=~m/help|\?/i) {
			chat::whisper($p, 'Usage: /rank <player> [mode]');
			chat::whisper($p, ' <player> can be an initial name, partial nickname, ending vaporID, server ID number, or place');
			return;
		}

		if($search=~s/\s+($typere)\s*$//i) {
			$type=lc($1);
		} else {
			$type=map::type;
			$type=map::mode if($type eq 'std');
		}

		if($search=~m/me|my|mine/i) {
			$search=$p->{'id'};
		}

		rank::show($p, $type, $search);
	},

	'help map'	=> sub {
		my($e, $p)=@_;
		chat::whisper($p, '/list map');
		chat::whisper($p, 'List the name and settings for the current map');
		chat::whisper($p, 'alti+server version:', $VERSION);
	},

	'list map'	=> sub {
		my($e, $p)=@_;
		my(@settings)=qw(
			gameType
			maxPlayers
			changePlane
			score
			keys
			planes
			assignTeam
			spawnMode
			spawnHealth
			gravity
			weapons
			cameraScale
			planeScale
			intro
		);

		chat::whisper($p, 'Name:', map::name);

		foreach my $setting (@settings) {
			$HOOKS{"list $setting"}->($e, $p)
				if(exists($HOOKS{"list $setting"}));
		}
	},

	'help nextMap'	=> sub {
		my($e, $p)=@_;

		chat::whisper($p, '/list nextMap');
		chat::whisper($p, '/nextMap');
		chat::whisper($p, '/set nextMap <map>');
		chat::whisper($p, '/unset nextMap');
		chat::whisper($p, 'Overrride map votes and default nextMap with <map>');
	},

	'list nextMap'	=> sub {
		my($e, $p)=@_;
		my($next)=stash::get('nextMap', 'admin');

		if($next) {
			chat::whisper($p, 'Next map is', $next);
		} else {
			chat::whisper($p, 'Run /nextMap to see next map');
		}
	},

	'nextMap'	=> sub {
		my($e, $p)=@_;
		my($next)=stash::get('nextMap', 'admin');

		chat::whisper($p, 'Next map override is', $next) if($next);
	},

	'set nextMap'	=> sub {
		my($e, $p, $next)=@_;

		stash::set('nextMap', 'admin', $next);
		chat::whisper($p, 'Next map is now', $next);
	},

	'unset nextMap'	=> sub {
		my($e, $p)=@_;

		stash::delete('nextMap', 'admin');
		chat::whisper($p, 'Next map is now left to server');
	},

	'SelectNextMap'	=> sub {
		my($e, $p)=@_;

		map::choices(@{$e->{'arguments'}});
	},

	'mapLoading'		=> sub {
		my($e, $p)=@_;
		my($mapdir)=config::option('mapDir');
		my($map)="$INSTALL_ROOT/maps/$mapdir/$e->{'map'}.altx";
		my($next)=stash::get('nextMap', 'admin');

		queue::clear;

		if($next && $e->{'map'} ne $next) {
			server::send('changeMap', $next);
			server::override('mapChange', 'skip');
		} else {
			map::busy;

			if(map::choosen($e->{'map'})) {
				#Don't mark it used if there is a quick /vote changeMap :
				queue::schedule { file::update_ctime($map) } 30;
			}
		}

		stash::delete('nextMap', 'admin') if($next);
	},

	'mapChange:skip'	=> sub {
		return;
	},

	'mapChange'	=> sub {
		my($e, $p)=@_;
		my(@records)=split(m/\W+/, config::option('recordsTypes'));
		my(@settings)=qw(
			gameType
			maxPlayers
			changePlane
			score
			keys
			planes
			assignTeam
			spawnMode
			spawnHealth
			gravity
			weapons
			cameraScale
			planeScale
		);

		stash::fix_doors($e->{'map'}, $e->{'leftTeam'}, $e->{'rightTeam'});

		map::new($e);
		plus::new;
		plus::assign_teams;
		rank::map_change;

		foreach my $player (player::list) {
			if($p->{'stats'}{'spawns'}) {
				server::send('overrideSpawnPoint', $player->{'nickname'}, 0, 0, 0);
			}
			$player->{'stats'}={};
			$player->{'timer'}={};
			$player->{'carrier'}=0;
			$player->{'has'}=undef;
			player::forgive($player);
		}

		foreach my $setting (@settings) {
			$HOOKS{"enable $setting"}->($e, $p)
				if(exists($HOOKS{"enable $setting"}));
		}

		chat::all('Server configured for map:', $e->{'map'});

		if(map::type(@records)) {
			queue::schedule {
				records::print('short' => 1);
			} 10;
		}
	},

	'help gravity'	=> sub {
		my($e, $p)=@_;

		chat::whisper($p, '/list gravity');
		chat::whisper($p, '/set gravity <0|1|2|3>');
		chat::whisper($p, '/unset gravity');
		chat::whisper($p, '0=default, 1=disable planes/weapons, 2=disable ball, 3=none');
	},

	'list gravity'	=> sub {
		my($e, $p)=@_;
		my($gravity)=stash::get('gravity', map::name, 'map');
		my(@table)=('0 (default)', '1 (no plane gravity)', '2 (no ball gravity)', '3 (no gravity)');

		chat::whisper($p, 'gravity:', $table[$gravity]);
	},

	'enable gravity'	=> sub {
		my($e, $p)=@_;
		my($gravity)=stash::get('gravity', map::name, 'map');

		if(defined($gravity)) {
			server::send('testGravityMode', $gravity);
		} else {
			server::send('testGravityMode', 0);
		}
	},

	'set gravity'	=> sub {
		my($e, $p, $grav)=@_;

		if($grav==0) {
			stash::delete('gravity', map::name, 'map');
			chat::all('Returning gravity to normal');
			server::send('testGravityMode', 0);
		} elsif($grav<=3) {
			stash::set('gravity', map::name, 'map', $grav);
			server::send('testGravityMode', $grav);
		} else {
			chat::whisper($p, "Invalid gravity value: $grav");
		}
	},

	'unset gravity'	=> sub {
		my($e, $p)=@_;

		stash::delete('gravity', map::name, 'map');
		server::send('testGravityMode', 0);

		chat::all('Returning gravity to normal');
	},

	'help weapons'	=> sub {
		my($e, $p)=@_;

		chat::whisper($p, '/list weapons');
		chat::whisper($p, '/set weapons <0|1|2|3>');
		chat::whisper($p, '/unset weapons');
		chat::whisper($p, '0=default, 1=disable primary, 2=disable secondary, 3=no weapons');
	},

	'list weapons'	=> sub {
		my($e, $p)=@_;
		my($weapons)=stash::get('weapons', map::name, 'map');
		my(@table)=('0 (default)', '1 (secondary only)', '2 (primary only)', '3 (no weapons)');

		chat::whisper($p, 'weapons:', $table[$weapons]);
	},

	'enable weapons'	=> sub {
		my($e, $p)=@_;
		my($weapons)=stash::get('weapons', map::name, 'map');

		if(defined($weapons)) {
			server::send('testDisableWeaponMode', $weapons);
		} else {
			server::send('testDisableWeaponMode', 0);
		}
	},

	'set weapons'	=> sub {
		my($e, $p, $weapons)=@_;

		if($weapons==0) {
			stash::delete('weapons', map::name, 'map');
			chat::all('Returning weapons to normal');
			server::send('testDisableWeaponMode', 0);
		} elsif($weapons<=3) {
			stash::set('weapons', map::name, 'map', $weapons);
			server::send('testDisableWeaponMode', $weapons);
		} else {
			chat::whisper($p, "Invalid weapons value: $weapons");
		}
	},

	'unset weapons'	=> sub {
		my($e, $p)=@_;

		stash::delete('weapons', map::name, 'map');
		server::send('testDisableWeaponMode', 0);

		chat::all('Returning weapons to normal');
	},

	'help spawnHealth'	=> sub {
		my($e, $p)=@_;

		chat::whisper($p, '/list spawnHealth');
		chat::whisper($p, '/set spawnHealth <1-999>');
		chat::whisper($p, '/unset spawnHealth');
		chat::whisper($p, '50=half normal health, 200=double normal health');
	},

	'list spawnHealth'	=> sub {
		my($e, $p)=@_;
		my($health)=stash::get('spawnHealth', map::name, 'map');
		my($msg);

		if(!defined($health) || $health==100) {
			$msg='100 (default)';
		} elsif($health<100) {
			$msg="$health (fragile)";
		} elsif($health>100) {
			$msg="$health (strong)";
		}

		chat::whisper($p, 'spawnHealth:', $msg);
	},

	'enable spawnHealth'	=> sub {
		my($e, $p)=@_;
		my($health)=stash::get('spawnHealth', map::name, 'map');

		if(defined($health)) {
			server::send('testHealthModifier', $health);
		} else {
			server::send('testHealthModifier', 100);
		}
	},

	'set spawnHealth'	=> sub {
		my($e, $p, $health)=@_;

		if($health==100) {
			stash::delete('spawnHealth', map::name, 'map');
			chat::all('Returning spawnHealth to normal');
			server::send('testHealthModifier', 100);
		} elsif(0<$health && $health<1000) {
			stash::set('spawnHealth', map::name, 'map', $health);
			server::send('testHealthModifier', $health);
		} else {
			chat::whisper($p, "Invalid spawnHealth value: $health");
		}
	},

	'unset spawnHealth'	=> sub {
		my($e, $p)=@_;

		stash::delete('spawnHealth', map::name, 'map');
		server::send('testHealthModifier', 100);

		chat::all('Returning spawnHealth to normal');
	},

	'help cameraScale'	=> sub {
		my($e, $p)=@_;

		chat::whisper($p, '/list cameraScale');
		chat::whisper($p, '/set cameraScale <40-300>');
		chat::whisper($p, '/unset cameraScale');
		chat::whisper($p, '50=Zoom in(half normal viewable) 200=Zoom out(twice normal viewable)');
	},

	'list cameraScale'	=> sub {
		my($e, $p)=@_;
		my($scale)=stash::get('cameraScale', map::name, 'map');
		my($msg);

		if(!defined($scale) || $scale==100) {
			$msg='100 (default)';
		} elsif($scale<100) {
			$msg="$scale (zoom in)";
		} elsif($scale>100) {
			$msg="$scale (zoom out)";
		}

		chat::whisper($p, 'cameraScale:', $msg);
	},

	'enable cameraScale'	=> sub {
		my($e, $p)=@_;
		my($scale)=stash::get('cameraScale', map::name, 'map');

		server::send('testCameraViewScale', $scale || 100);
	},

	'set cameraScale'	=> sub {
		my($e, $p, $zoom)=@_;

		$zoom=~s/%$//;
		$zoom=100 if($zoom=~m/default|normal/i);

		if($zoom==100) {
			stash::delete('cameraScale', map::name, 'map');
			chat::all('Returning camera zoom to normal');
			server::send('testCameraViewScale', 100);
		} elsif(40<=$zoom && $zoom<=300) {
			stash::set('cameraScale', map::name, 'map', $zoom);
			server::send('testCameraViewScale', $zoom);
		} else {
			chat::whisper($p, "Invalid camera scale value: $zoom");
		}
	},

	'unset cameraScale'	=> sub {
		my($e, $p)=@_;

		stash::delete('cameraScale', map::name, 'map');
		server::send('testCameraViewScale', 100);

		chat::all('Returning camera zoom to normal');
	},

	'help planeScale'	=> sub {
		my($e, $p)=@_;

		chat::whisper($p, '/list planeScale');
		chat::whisper($p, '/set planeScale <40-300>');
		chat::whisper($p, '/unset planeScale');
		chat::whisper($p, '50=planes are half size, 200=planes are double size');
	},

	'list planeScale'	=> sub {
		my($e, $p)=@_;
		my($scale)=stash::get('planeScale', map::name, 'map');
		my($msg);

		if(!defined($scale) || $scale==100) {
			$msg='100 (default)';
		} elsif($scale<100) {
			$msg="$scale (smaller)";
		} elsif($scale>100) {
			$msg="$scale (bigger)";
		}

		chat::whisper($p, 'planeScale:', $msg);
	},

	'enable planeScale'	=> sub {
		my($e, $p)=@_;
		my($scale)=stash::get('planeScale', map::name, 'map');

		server::send('testPlaneScale', $scale || 100);
	},

	'set planeScale'	=> sub {
		my($e, $p, $zoom)=@_;

		$zoom=~s/%$//;
		$zoom=100 if($zoom=~m/default|normal/i);

		if($zoom==100) {
			stash::delete('planeScale', map::name, 'map');
			chat::all('Returning plane zoom to normal');
			server::send('testPlaneScale', 100);
		} elsif(40<=$zoom && $zoom<=300) {
			stash::set('planeScale', map::name, 'map', $zoom);
			server::send('testPlaneScale', $zoom);
		} else {
			chat::whisper($p, "Invalid plane scale value: $zoom");
		}
	},

	'unset planeScale'	=> sub {
		my($e, $p)=@_;

		stash::delete('planeScale', map::name, 'map');
		server::send('testPlaneScale', 100);

		chat::all('Returning plane zoom to normal');
	},

	'help assignTeam'	=> sub {
		my($e, $p)=@_;

		chat::whisper($p, 'Force players to spawn on a specific team');
		chat::whisper($p, '/list assignTeam');
		chat::whisper($p, '/set assignTeam <left|right|none>');
		chat::whisper($p, '/unset assignTeam');
	},

	'list assignTeam'	=> sub {
		my($e, $p)=@_;
		my($team)=stash::get('assignTeam', map::name, 'map');
		my($color);

		if($team) {
			$color=map::team_color($team);
			chat::whisper($p, 'assignTeam:', $team, "($color)");
		} else {
			chat::whisper($p, 'assignTeam:', 'none');
		}
	},

	'enable assignTeam'	=> sub {
		my($e, $p)=@_;
		my($team)=stash::get('assignTeam', map::name, 'map');
		my($color);

		if(defined($team)) {
			$color=map::team_color($team);
			chat::all('assignTeam:', $team, "($color)");
		}
	},

	'set assignTeam'	=> sub {
		my($e, $p, $side)=@_;

		if($side=~m/^=(\w+)/) {
			stash::set('assignTeam', map::name, 'map', $1);
			chat::all(map::name, 'is configured to force players to', $1);
		} elsif(map::left($side)) {
			stash::set('assignTeam', map::name, 'map', 'left');
			chat::all(map::name, 'is configured to force players left');

			foreach my $m (player::list) {
				plus::assign($m, 'left') if(map::right($m->{'team'}));
			}
		} elsif(map::right($side)) {
			stash::set('assignTeam', map::name, 'map', 'right');
			chat::all(map::name, 'is configured to force players right');

			foreach my $m (player::list) {
				plus::assign($m, 'right') if(map::left($m->{'team'}));
			}
		} elsif($side=~m/none/i) {
			stash::delete('assignTeam', map::name, 'map');
			chat::all('Side enforcement for', map::name, 'is disabled');
		}
	},

	'unset assignTeam'	=> sub {
		my($e, $p)=@_;

		stash::delete('assignTeam', map::name, 'map');

		chat::all('Deleted team assignment');
	},

	'help planes'	=> sub {
		my($e, $p)=@_;

		chat::whisper($p, 'Allow only certain planes to join the game');
		chat::whisper($p, '/list planes');
		chat::whisper($p, '/add plane <+|-|=><Loopy|Bomber|Explodet|Biplane|Miranda> <perk> <...>');
		chat::whisper($p, '/del plane <+|-|=><Loopy|Bomber|Explodet|Biplane|Miranda> <perk> <...>');
		chat::whisper($p, '+ allows, - denys, = sets Bot plane');
	},

	'list planes'	=> sub {
		my($e, $p)=@_;
		my($planes)=stash::get('planes', map::name, 'map');
		my($bots)=stash::get('bots', map::name, 'map');
		my($spec);

		if(ref($planes) eq 'HASH') {
			chat::whisper($p, 'planes:', join('; ',
				map($planes->{$_}.utils::simplify($_), sort(keys(%$planes)))
			));
		} elsif($e->{'command'} eq 'list') {
			chat::whisper($p, 'planes: all');
		}

		if(ref($bots) eq 'HASH') {
			chat::whisper($p, 'bots:', join('; ',
				map($bots->{$_}.utils::simplify($_), sort(keys(%$bots)))
			));
		}
	},

	'enable planes'	=> sub {
		my($e, $p)=@_;
		my($planes)=stash::get('planes', map::name, 'map');
		my($bots)=stash::get('bots', map::name, 'map');

		return unless(defined($planes));

		#convert to new format:
		unless(ref($planes)) {
			foreach my $plane (split(m/\|+/, $planes)) {
				$planes={} unless(ref($planes));
				$planes->{"$plane,,,"}='+';
			}
			stash::set('planes', map::name, 'map', $planes) if(ref($planes));
		}

		if(ref($planes) eq 'HASH') {
			chat::all('planes:', join('; ',
				map($planes->{$_}.utils::simplify($_), sort(keys(%$planes)))
			));

			plus::next_bot;
		} else {
			chat::all('planes: all');
			plus::any_bot;
		}
	},

	'add plane'	=> sub {
		my($e, $p, @plane)=@_;
		my($planes)=stash::get('planes', map::name, 'map');
		my($bots)=stash::get('bots', map::name, 'map');
		my($plane)=1;
		my($tuple);

		if(map::mode('ffa')) {
			chat::whisper($p, 'Plane enforcement is not possible in FFA');
			return;
		}

		#convert to new format:
		unless(ref($planes)) {
			foreach my $plane (split(m/\|+/, $planes)) {
				$planes={} unless(ref($planes));
				$planes->{"$plane,,,"}='+';
			}
			stash::set('planes', map::name, 'map', $planes) if(ref($planes));
		}

		if($plane[0]=~m/all|none/i) {
			stash::delete('planes', map::name, 'map');
			chat::all('Plane enforcement for', map::name, 'is disabled');
			return;
		} elsif($plane[0]=~m/^(=)(\w.+)/) {
			splice(@plane, 0, 1, $1, $2);
			$plane=0;
		} elsif($plane[0]=~m/^([+-])(\w.+)/) {
			splice(@plane, 0, 1, $1, $2);
		} elsif($plane[0]=~m/^\w/) {
			unshift(@plane, '+');
		}

		for(my $i=1; $i<@plane; $i++) {
			$plane[$i]=utils::plane($plane[$i]);
			$plane[$i]=utils::red($plane[$i]);
			$plane[$i]=utils::green($plane[$i]);
			$plane[$i]=utils::blue($plane[$i]);
		}

		$tuple=join(',',
			join('', grep(utils::is_plane($_), @plane)),
			join('', grep(utils::is_red($_), @plane)),
			join('', grep(utils::is_green($_), @plane)),
			join('', grep(utils::is_blue($_), @plane)),
		);

		if($plane) {
			$planes->{$tuple}=$plane[0];
			stash::set('planes', map::name, 'map', $planes) if(ref($planes));
			chat::all(map::name, 'Added plane restriction:', @plane);
		} else {
			$bots->{$tuple}=$plane[0];
			stash::set('bots', map::name, 'map', $bots) if(ref($bots));
			chat::all(map::name, 'Added bot restriction:', @plane);
		}

		plus::build_planes;
	},

	'del plane'	=> sub {
		my($e, $p, @plane)=@_;
		my($planes)=stash::get('planes', map::name, 'map');
		my($bots)=stash::get('bots', map::name, 'map');
		my($plane)=1;
		my($tuple);

		unless(ref($planes) || ref($bots)) {
			chat::whisper($p, 'There are no plane restrictions');
			return;
		}

		if($plane[0]=~m/all|none/i) {
			stash::delete('planes', map::name, 'map');
			chat::all('Plane enforcement for', map::name, 'is disabled');
			return;
		}

		if($plane[0] eq '=') {
			shift(@plane);
			$plane=0;
		}

		if($plane[0] eq '+' || $plane[0] eq '-') {
			shift(@plane);
		}

		if($plane[0]=~s/^=//) {
			$plane=0;
		};
		$plane[0]=~s/^[+-]//;

		$plane[0]=utils::plane($plane[0]);

		for(my $i=1; $i<@plane; $i++) {
			$plane[$i]=utils::red($plane[$i]);
			$plane[$i]=utils::green($plane[$i]);
			$plane[$i]=utils::blue($plane[$i]);
		}

		$tuple=join(',',
			join('', grep(utils::is_plane($_), @plane)),
			join('', grep(utils::is_red($_), @plane)),
			join('', grep(utils::is_green($_), @plane)),
			join('', grep(utils::is_blue($_), @plane)),
		);

		if($plane && exists($planes->{$tuple})) {
			delete($planes->{$tuple});
			if(%$planes) {
				stash::set('planes', map::name, 'map', $planes);
				chat::all(map::name, 'Removed plane restriction:', @plane);
			} else {
				stash::delete('planes', map::name, 'map');
				chat::all('Plane enforcement for', map::name, 'is disabled');
			}
		} elsif(!$plane && exists($bots->{$tuple})) {
			delete($bots->{$tuple});
			if(%$bots) {
				stash::set('bots', map::name, 'map', $bots);
				chat::all(map::name, 'Removed bot restriction:', @plane);
			} else {
				stash::delete('bots', map::name, 'map');
				chat::all('Bot override for', map::name, 'is disabled');
			}
		} else {
			chat::all(map::name, 'Could not find restriction:', @plane);
		}

		plus::build_planes;
	},

	'help score'	=> sub {
		my($e, $p)=@_;

		chat::whisper($p, 'When the map loads, pre-set the initial ball score');
		chat::whisper($p, '/list score');
		chat::whisper($p, '/set score <-#|#> <-#|#>');
		chat::whisper($p, '/unset score');
		chat::whisper($p, 'Negative numbers are an offset from the winning score');
	},

	'list score'	=> sub {
		my($e, $p)=@_;
		my($scores)=stash::get('score', map::name, 'map');

		return unless(map::mode('ball', 'tdm'));

		if($scores) {
			chat::whisper($p, 'score: [', join(',', @$scores), ']');
		} else {
			chat::whisper($p, 'score: [', '0,0', ']');
		}
	},

	'enable score'	=> sub {
		my($e, $p)=@_;
		my($scores)=stash::get('score', map::name, 'map');
		my($goals)=$config::Launcher{'goals'};
		my($l, $r);

		return unless(map::mode('ball', 'tdm', '1dm'));

		if($scores && map::mode('ball') && !race::on) {
			($l, $r)=@$scores;
			$l=$goals+$l if($l<0);
			$r=$goals+$r if($r<0);
			ball::update_score($l, $r);
			ball::set_score($l, $r);
		} elsif(map::mode('tdm', '1dm')) {
			chat::all('score:', @$scores);
		} else {
			ball::update_score(0, 0);
			ball::set_score(0, 0);
		}
	},

	'set score' 	=> sub {
		my($e, $p, $l, $r)=@_;
		my($goals)=$config::Launcher{'goals'};

		return unless(map::mode('ball', 'tdm', '1dm'));

		if(map::mode('ball') && ( $l<=-$goals || $r<=-$goals || $goals<=$l || $goals<=$r )) {
			chat::whisper($p, "Invalid goal #, must be between -$goals and $goals");
		} elsif($l==0 && $r==0) {
			chat::whisper($p, "Initial score returned to normal for next round");
			stash::delete('score', map::name, 'map');
		} elsif(map::mode('tdm', '1dm')) {
			chat::whisper($p, "Winning score set to $l, $r");
			stash::set('score', map::name, 'map', [$l, $r]);
		} else {
			chat::all("Initial score set to [$l, $r]");
			stash::set('score', map::name, 'map', [$l, $r]);

			$l=$goals+$l if($l<0);
			$r=$goals+$r if($r<0);
			ball::update_score($l, $r);
			ball::set_score($l, $r);
		}

	},

	'unset score'	=> sub {
		my($e, $p)=@_;

		if(stash::delete('score', map::name, 'map')) {
			chat::whisper($p, 'Removed initial score');
		} else {
			chat::whisper($p, 'Initial score not set');
		}
	},

	'help maxPlayers'	=> sub {
		my($e, $p)=@_;

		chat::whisper($p, 'Set a map specific max player # smaller than the server default');
		chat::whisper($p, '/list maxPlayers');
		chat::whisper($p, '/set maxPlayers #');
		chat::whisper($p, '/unset maxPlayers');
	},

	'list maxPlayers'	=> sub {
		my($e, $p)=@_;
		my($count)=stash::get('maxPlayers', map::name, 'map');

		chat::whisper($p, 'maxPlayers:', $count || $config::Maxp);
	},

	'set maxPlayers'	=> sub {
		my($e, $p, $count)=@_;

		if($count>0) {
			stash::set('maxPlayers', map::name, 'map', $count);
		} else {
			stash::delete('maxPlayers', map::name, 'map');
		}
	},

	'unset maxPlayers'	=> sub {
		my($e, $p)=@_;

		stash::delete('maxPlayers', map::name, 'map');
	},

	'help spawnMode'	=> sub {
		my($e, $p)=@_;

		chat::whisper($p, 'Change the behavior of how users spawn when they die, or pickup powerups');
		chat::whisper($p, '/list spawnMode');
		chat::whisper($p, '/set spawnMode <default|died|pickup|health|zone|near|after|portal>[,center|hmirror|vmirror]');
		chat::whisper($p, '/unset spawnMode');
	},

	'list spawnMode'	=> sub {
		my($e, $p)=@_;
		my($spawn_mode)=stash::get('spawnMode', map::name, 'map');
		my($spawn_angle)=stash::get('spawnAngle', map::name, 'map');
		my($zones)=stash::get('zones', map::name, 'map');

		if($spawn_mode) {
			$spawn_mode.=" ($spawn_angle)" if($spawn_angle);
			$spawn_mode.=' (checkpoints)' if($zones);
			chat::whisper($p, 'spawnMode:', $spawn_mode);
		}
	},

	'enable spawnMode'	=> sub {
		my($e, $p)=@_;
		my($spawn_mode)=stash::get('spawnMode', map::name, 'map');
		my($spawn_angle)=stash::get('spawnAngle', map::name, 'map');
		my($zones)=stash::get('zones', map::name, 'map');

		if($spawn_mode) {
			$spawn_mode.=" ($spawn_angle)" if($spawn_angle);
			$spawn_mode.=' (checkpoints)' if($zones);
			chat::all('spawnMode:', $spawn_mode);
		}
	},

	'set spawnMode'	=> sub {
		my($e, $p, $spawn, $angle)=@_;
		my($zones)=stash::get('zones', map::name, 'map');

		if($angle=~m/(center|[hv]mirror)/i) {
			stash::set('spawnAngle', map::name, 'map', lc($1));
		}

		if($spawn=~m/default|normal|start/i) {
			chat::all("Player spawn returned to normal");
			stash::delete('spawnMode', map::name, 'map');
			stash::delete('spawnAngle', map::name, 'map');
		} elsif($spawn=~m/die|crash/i) {
			chat::all("Players spawn where died, use '/sz start' to spawn normal");
			stash::set('spawnMode', map::name, 'map', 'died');
		} elsif($spawn=~m/power|pick/i) {
			if($zones) {
				chat::all("Players spawn at checkpoints, use '/sz start' to spawn normal");
			} else {
				chat::all("Players spawn at last powerup, use '/sz start' to spawn normal");
			}
			stash::set('spawnMode', map::name, 'map', 'powerup');
		} elsif($spawn=~m/health/i) {
			chat::all("Players spawn at last health powerup, use '/sz start' to spawn normal");
			stash::set('spawnMode', map::name, 'map', 'health');
		} elsif($spawn=~m/zone/i) {
			chat::all("Spawn zones enabled, use /spawnZone to use them");
			stash::set('spawnMode', map::name, 'map', 'zone');
		} elsif($spawn=~m/near/i) {
			chat::all("Spawn in closest zone enabled, use '/sz start' to spawn normal");
			stash::set('spawnMode', map::name, 'map', 'near');
		} elsif($spawn=~m/after/i) {
			chat::all("Spawn in last past zone enabled, use '/sz start' to spawn normal");
			stash::set('spawnMode', map::name, 'map', 'after');
		} elsif($spawn=~m/portal/i) {
			if(map::mode('ffa')) {
				chat::whisper($p, 'Portals do not work in FFA');
				return;
			}

			chat::all("Spawn portals enabled, use '/sz start' to spawn normal");
			stash::set('spawnMode', map::name, 'map', 'portal');
		}
	},

	'unset spawnMode'	=> sub {
		my($e, $p)=@_;

		if(stash::delete('spawnMode', map::name, 'map')) {
			stash::delete('spawnAngle', map::name, 'map');
			chat::all('Disabled enhanced spawn locations');
		} else {
			chat::whisper($p, 'Enhanced spawn locations not set');
		}
	},

	'help changePlane'	=> sub {
		my($e, $p)=@_;

		chat::whisper($p, 'Specify number of players (or less) to allow mid-map changePlane, 0 disables
		');
		chat::whisper($p, '/list changePlane');
		chat::whisper($p, '/set changePlane [#]');
		chat::whisper($p, '/unset changePlane');
	},

	'list changePlane'	=> sub {
		my($e, $p)=@_;
		my($cp)=stash::get('changePlane', map::name, 'map') // config::option('changePlane');
		my($state)='enabled';

		$state='disabled' if(player::count > $cp);

		chat::whisper($p, "changePlane: $cp ($state)");
	},

	'enable changePlane'	=> sub {
		my($e, $p)=@_;
		my($cp)=stash::get('changePlane', map::name, 'map') // config::option('changePlane');
		my($state)='enabled';

		$state='disabled' if(player::count > $cp);

		chat::all("changePlane: $cp ($state)");
	},

	'set changePlane'	=> sub {
		my($e, $p, $cp)=@_;

		stash::set('changePlane', map::name, 'map', $cp);

		if($cp) {
			chat::all("Changing planes is enabled when players <= $cp");
		} else {
			chat::all('Changing planes is only possible after dying');
		}
	},

	'unset changePlane'	=> sub {
		my($e, $p)=@_;
		my($cp)=config::option('changePlane');

		stash::delete('changePlane', map::name, 'map');

		chat::all('Changing planes is set to default',
				$cp?'(players)':'(disabled)', 'state');
	},

	'help gameType'	=> sub {
		my($e, $p)=@_;

		chat::whisper($p, 'These are Alti+ game times, which are extentions to the mode');
		chat::whisper($p, '/list gameType');
		chat::whisper($p, '/set gameType <mapname|std|coop|race|ruin|flag|zone|mdg|1lh>');
		chat::whisper($p, '/unset gameType');
		chat::whisper($p, 'mapname causes the type to be inferred from the map name');
	},

	'list gameType'	=> sub {
		my($e, $p)=@_;

		chat::whisper($p, 'gameType:', map::type);
	},

	'enable gameType'	=> sub {
		my($e, $p)=@_;
		my($type)=stash::get('gameType', map::name, 'map');

		if($type) {
			chat::all('gameType:', map::set_type($type));
		} else {
			chat::all('gameType:', map::set_type(map::name));
		}
	},

	'set gameType'		=> sub {
		my($e, $p, $type)=@_;

		if($type=~m/normal|file/i) {
			stash::delete('gameType', map::name, 'map');
			map::set_type(map::name);
		} else {
			stash::set('gameType', map::name, 'map', $type);
			map::set_type($type);
		}

		chat::all('gameType:', map::type);
	},

	'unset gameType'		=> sub {
		my($e, $p)=@_;

		if(stash::delete('gameType', map::name, 'map')) {
			chat::whisper($p, 'Removed gameType override');
			chat::all('gameType:', map::set_type(map::name));
		} else {
			chat::whisper($p, 'gameType not set');
		}
	},

	'help intro'	=> sub {
		my($e, $p)=@_;

		chat::whisper($p, 'Set an introductory message for players on a map');
		chat::whisper($p, '/list intro');
		chat::whisper($p, '/set intro <text ...>');
		chat::whisper($p, '/unset intro');
	},

	'list intro'	=> sub {
		my($e, $p)=@_;
		my($intro)=stash::get('intro', map::name, 'map');

		if($intro) {
			chat::whisper($p, $intro);
		} else {
			chat::whisper($p, 'This map does not have an introduction');
		}
	},

	'enable intro'	=> sub {
		my($e, $p)=@_;
		my($intro)=stash::get('intro', map::name, 'map');

		if($intro) {
			foreach my $msg (split(m/\s*;+\s*/, $intro)) {
				chat::all($msg);
			}
		}
	},

	'set intro'		=> sub {
		my($e, $p, @text)=@_;
		my($text)=join(' ', @text);

		if($text) {
			stash::set('intro', map::name, 'map', $text);
			chat::all($text);
		} else {
			stash::delete('intro', map::name, 'map');
			chat::whisper($p, 'Removed map introduction');
		}

	},

	'unset intro'		=> sub {
		my($e, $p)=@_;

		stash::delete('intro', map::name, 'map');
		chat::whisper($p, 'Removed map introduction');
	},

	'help records'	=> sub {
		my($e, $p)=@_;

		chat::whisper($p, 'Manage map records');
		chat::whisper($p, '/list records');
		chat::whisper($p, '/del record <time>');
		chat::whisper($p, '/set record <none|round|plant>');
		chat::whisper($p, '/unset record');
	},

	'list records'	=> sub {
		my($e, $p)=@_;

		records::print('player' => $p, 'delta' => $e->{'time'});
	},

	'del record'	=> sub {
		my($e, $p, $record)=@_;

		if(records::delete($record)) {
			chat::whisper($p, "Record $record deleted");
		} else {
			chat::whisper($p, "Failed to delete record: $record");
		}
	},

	'help portals'	=> sub {
		my($e, $p)=@_;

		chat::whisper($p, 'Portals allow users to be transported from a pickup to another location');
		chat::whisper($p, '/list portals');
		chat::whisper($p, '/add portal <name> <px>,<py> <sx>,<sy>,<sa>');
		chat::whisper($p, '/del portal <name>');
	},

	'list portals'	=> sub {
		my($e, $p)=@_;
		my($portals)=stash::get('portals', map::name, 'map');
		my($spawn_mode)=stash::get('spawnMode', map::name, 'map');
		my($any)=0;

		foreach my $portal (sort(keys(%$portals))) {
			chat::whisperf($p, '%s: %s -> %d,%d @%s',
					$portals->{$portal}[0],
					$portal,
					@{$portals->{$portal}}[1,2,3]
				);
			$any=1;
		}

		chat::whisper($p, 'No spawn portals defined') unless($any);
	},

	'add portal'	=> sub {
		my($e, $p, $portal, $px, $py, $sx, $sy, $sa)=@_;

		if(map::mode('ffa')) {
			chat::whisper($p, 'Portals cannot function in FFA games');
			return;
		}

		stash::set("$px,$py", 'portals', map::name, 'map',
			[$portal => $sx, $sy, $sa]);
		chat::all('Added portal:', $portal);
	},

	'del portal'	=> sub {
		my($e, $p, $remove, $rest)=@_;
		my($portals)=stash::get('portals', map::name, 'map');

		$remove=join(',', $remove, $rest) if($rest);

		foreach my $portal (keys(%$portals)) {
			if($portal eq $remove) {
				stash::delete($portal, 'portals', map::name, 'map');
				chat::all('Deleted portal:', $portal);
			} elsif($portals->{$portal}[0] eq $remove) {
				stash::delete($portal, 'portals', map::name, 'map');
				chat::all('Deleted portal:', $portal);
			} else {
				chat::whisper($p, 'No portal at or named:', $remove);
			}
		}
	},

	'help doors'	=> sub {
		my($e, $p)=@_;

		chat::whisper($p, 'Doors disable planes to pass through a pickup until all keys are found');
		chat::whisper($p, '/list doors');
		chat::whisper($p, '/add door <name> <team> <dx>,<dy>');
		chat::whisper($p, '/del door <name> <team>');
	},

	'list doors'	=> sub {
		my($e, $p)=@_;
		my($any)=0;
		my(@teams)=();
		my(@keys)=();
		my($sep)=':';
		my($doors, $keys, $names, $status);

		if($e->{'admin'} || map::spec($p->{'team'})) {
			@teams=(map::left, map::right);
		} elsif(map::left($p->{'team'})) {
			@teams=(map::left);
		} elsif(map::right($p->{'team'})) {
			@teams=(map::right);
		}
		foreach my $team (@teams) {
			$doors=utils::invert(stash::get('doors', $team, 'door', map::name, 'map'));
			$keys=utils::invert(stash::get('keys', $team, 'door', map::name, 'map'));
			$names=stash::get('name', $team, 'door', map::name, 'map');

			if(@teams==2) {
				if(map::left($team)) {
					$sep='<';
				} else {
					$sep='>';
				}
			}

			if($doors) {
				foreach my $door (sort(keys(%$doors))) {
					if(plus::door_open($p, $door)) {
						$status='(open)';
					} else {
						$status='(locked)';
					}
					if(exists($keys->{$door})) {
						foreach my $key (@{$keys->{$door}}) {
							if(plus::key_found($p, $key)) {
								push(@keys, '('.$names->{$key}.':'.$key.')');
							} else {
								push(@keys, $names->{$key}.':'.$key);
							}
						}
						chat::whisper($p, $door, $sep, @{$doors->{$door}},
							'<=', @keys, $status);
						delete($keys->{$door});
						$any=1;
					}
				}
			}

			if($keys) {
					foreach my $key (sort(keys(%$keys))) {
					chat::whisper($p, 'orphaned key', $key ,':', @{$keys->{$key}});
					$any=1;
				}
			}
		}

		chat::whisper($p, 'No doors defined') unless($any);
	},

	'add door'	=> sub {
		my($e, $p, $name, $team, $dx, $dy)=@_;

		if(map::mode('ffa')) {
			chat::whisper($p, 'Doors cannot function in FFA games');
			return;
		}

		$team='*' unless($team);

		if(map::left($team)) {
			stash::set("$dx,$dy", 'doors', map::left, 'door', map::name, 'map', $name);
			chat::all('Added left door:', $name, "($dx,$dy)");
		}

		if(map::right($team)) {
			stash::set("$dx,$dy", 'doors', map::right, 'door', map::name, 'map', $name);
			chat::all('Added right door:', $name, "($dx,$dy)");
		}
	},

	'del door'	=> sub {
		my($e, $p, $name, $team)=@_;
		my($any)=0;
		my($doors);

		$team='*' unless($team);

		if(map::left($team)) {
			$doors=stash::get('doors', map::left, 'door', map::name, 'map');

			if($doors) {
				foreach my $door (keys(%$doors)) {
					if($doors->{$door} eq $name) {
						stash::delete($door, 'doors', map::left, 'door', map::name, 'map');
						chat::all('Deleted left door:', $name, "($door)");
						$any=1;
					}
				}
			}
		}

		if(map::right($team)) {
			$doors=stash::get('doors', map::right, 'door', map::name, 'map');

			if($doors) {
				foreach my $door (keys(%$doors)) {
					if($doors->{$door} eq $name) {
						stash::delete($door, 'doors', map::right, 'door', map::name, 'map');
						chat::all('Deleted right door:', $name, "($door)");
						$any=1;
					}
				}
			}
		}

		unless($any) {
			chat::whisper($p, 'No door named:', $name);
		}
	},

	'help keys'	=> sub {
		my($e, $p)=@_;

		chat::whisper($p, 'Keys unlock doors and zones, see /help doors or /help zones');
		chat::whisper($p, '/list keys');
		chat::whisper($p, '/add key <name> <door|zone> <team> <kx>,<ky>');
		chat::whisper($p, '/add key <name> <door> <team> <powerup>');
		chat::whisper($p, '/del key <name|door|zone> <team>');
		chat::whisper($p, '/set keys <team|personal>');
		chat::whisper($p, '/unset keys');
	},

	'list keys'	=> sub {
		my($e, $p)=@_;
		my($keys)=stash::get('keys', map::name, 'map');
		my(@flags)=();
		my($locked)=	stash::get('keys', map::left, 'door', map::name, 'map')	||
					stash::get('keys', map::right, 'door', map::name, 'map')	||
					stash::get('keys', map::left, 'zones', map::name, 'map')	||
					stash::get('keys', map::right, 'zones', map::name, 'map');

		if(defined($keys)) {
			push(@flags, 'personal') if($keys & 1);

			@flags=('team') unless(@flags);

			chat::whisper($p, 'keys:', @flags);
		} elsif($locked) {
			chat::whisper($p, 'keys:', 'team');
		}
	},

	'enable keys'	=> sub {
		my($e, $p)=@_;
		my($keys)=stash::get('keys', map::name, 'map');
		my(@flags)=();
		my($locked)=	stash::get('keys', map::left, 'door', map::name, 'map')	||
					stash::get('keys', map::right, 'door', map::name, 'map')	||
					stash::get('keys', map::left, 'zones', map::name, 'map')	||
					stash::get('keys', map::right, 'zones', map::name, 'map');

		if(defined($keys)) {
			push(@flags, 'personal') if($keys & 1);

			@flags=('team') unless(@flags);

			chat::all('keys:', @flags);
		} elsif($locked) {
			chat::all('keys:', 'team');
		}
	},

	'set keys'	=> sub {
		my($e, $p, $flag)=@_;
		#We can OR these later if we add more flags.

		if($flag=~m/0|team/i) {
			stash::set('keys', map::name, 'map', 0);
			chat::whisper($p, 'Keys are team-wide as of the next map load');
		} elsif($flag=~m/1|personal|single/) {
			stash::set('keys', map::name, 'map', 1);
			chat::whisper($p, 'Keys will be personal on next map load');
		}
	},

	'unset keys'	=> sub {
		my($e, $p)=@_;

		stash::delete('keys', map::name, 'map');
		chat::whisper($p, 'Keys are team-wide as of the next map load');
	},

	'add key'		=> sub {
		my($e, $p, $name, $opens, $team, $kx, $ky)=@_;
		my($powerup);
		my($doors);

		if(utils::is_powerup($kx)) {
			$powerup=utils::powerup($kx);
		} else {
			$powerup="$kx,$ky";
		}

		$team='*' unless($team);

		if(map::left($team)) {
			$doors=utils::invert(stash::get('doors', map::left, 'door', map::name, 'map'));
			if(exists($doors->{$opens})) {
				stash::set($powerup, 'keys', map::left, 'door', map::name, 'map', $opens);
				stash::set($powerup, 'name', map::left, 'door', map::name, 'map', $name);
				chat::all('Added left key', $name, 'for door', $opens, "($powerup)");
			} elsif(stash::get($opens, 'zones', map::left, 'zones', map::name, 'map')) {
				stash::set($powerup, 'keys', map::left, 'zones', map::name, 'map', $opens);
				stash::set($powerup, 'name', map::left, 'zones', map::name, 'map', $name);
				chat::all('Added left key', $name, 'for zone', $opens, "($powerup)");
			} else {
				chat::whisper($p, 'You must define the left door or zone first');
			}
		}

		if(map::right($team)) {
			$doors=utils::invert(stash::get('doors', map::right, 'door', map::name, 'map'));
			if(exists($doors->{$opens})) {
				stash::set($powerup, 'keys', map::right, 'door', map::name, 'map', $opens);
				stash::set($powerup, 'name', map::right, 'door', map::name, 'map', $name);
				chat::all('Added right key', $name, 'for door', $opens, "($powerup)");
			} elsif(stash::get($opens, 'zones', map::right, 'zones', map::name, 'map')) {
				stash::set($powerup, 'keys', map::right, 'zones', map::name, 'map', $opens);
				stash::set($powerup, 'name', map::right, 'zones', map::name, 'map', $name);
				chat::all('Added right key', $name, 'for zone', $opens, "($powerup)");
			} else {
				chat::whisper($p, 'You must define the right door or zone first');
			}
		}
	},

	'del key'	=> sub {
		my($e, $p, $name, $team)=@_;
		my($any)=0;
		my($keys);

		$team='*' unless($team);

		if(map::left($team)) {
			$keys=stash::get('name', map::left, 'door', map::name, 'map');
			if($keys) {
				foreach my $key (keys(%$keys)) {
					if($keys->{$key} eq $name) {
						stash::delete($key, 'keys', map::left, 'door', map::name, 'map');
						stash::delete($key, 'name', map::left, 'door', map::name, 'map');
						chat::all('Deleted key:', $name, "($key)");
						$any=1;
					}
				}
			}

			$keys=stash::get('keys', map::left, 'door', map::name, 'map');
			if($keys) {
				foreach my $key (keys(%$keys)) {
					if($keys->{$key} eq $name) {
						stash::delete($key, 'keys', map::left, 'door', map::name, 'map');
						stash::delete($key, 'name', map::left, 'door', map::name, 'map');
						chat::all('Deleted key for door:', $name, "($key)");
						$any=1;
					}
				}
			}

			$keys=stash::get('name', map::left, 'zones', map::name, 'map');
			if($keys) {
				foreach my $key (keys(%$keys)) {
					if($keys->{$key} eq $name) {
						stash::delete($key, 'keys', map::left, 'zones', map::name, 'map');
						stash::delete($key, 'name', map::left, 'zones', map::name, 'map');
						chat::all('Deleted key:', $name, "($key)");
						$any=1;
					}
				}
			}

			$keys=stash::get('keys', map::left, 'zones', map::name, 'map');
			if($keys) {
				foreach my $key (keys(%$keys)) {
					if($keys->{$key} eq $name) {
						stash::delete($key, 'keys', map::left, 'zones', map::name, 'map');
						stash::delete($key, 'name', map::left, 'zones', map::name, 'map');
						chat::all('Deleted key for zone:', $name, "($key)");
						$any=1;
					}
				}
			}
		}

		if(map::right($team)) {
			$keys=stash::get('name', map::right, 'door', map::name, 'map');
			if($keys) {
				foreach my $key (keys(%$keys)) {
					if($keys->{$key} eq $name) {
						stash::delete($key, 'keys', map::right, 'door', map::name, 'map');
						stash::delete($key, 'name', map::right, 'door', map::name, 'map');
						chat::all('Deleted key:', $name, "($key)");
						$any=1;
					}
				}
			}

			$keys=stash::get('keys', map::right, 'door', map::name, 'map');
			if($keys) {
				foreach my $key (keys(%$keys)) {
					if($keys->{$key} eq $name) {
						stash::delete($key, 'keys', map::right, 'door', map::name, 'map');
						stash::delete($key, 'name', map::right, 'door', map::name, 'map');
						chat::all('Deleted key for door:', $name, "($key)");
						$any=1;
					}
				}
			}

			$keys=stash::get('name', map::right, 'zones', map::name, 'map');
			if($keys) {
				foreach my $key (keys(%$keys)) {
					if($keys->{$key} eq $name) {
						stash::delete($key, 'keys', map::right, 'zones', map::name, 'map');
						stash::delete($key, 'name', map::right, 'zones', map::name, 'map');
						chat::all('Deleted key:', $name, "($key)");
						$any=1;
					}
				}
			}

			$keys=stash::get('keys', map::right, 'zones', map::name, 'map');
			if($keys) {
				foreach my $key (keys(%$keys)) {
					if($keys->{$key} eq $name) {
						stash::delete($key, 'keys', map::right, 'zones', map::name, 'map');
						stash::delete($key, 'name', map::right, 'zones', map::name, 'map');
						chat::all('Deleted key for door:', $name, "($key)");
						$any=1;
					}
				}
			}
		}

		unless($any) {
			chat::whisper($p, 'No keys for door or zone named:', $name);
		}
	},

	'help diverters'	=> sub {
		my($e, $p)=@_;

		chat::whisper($p, 'Diverters alternate access to parts of a map');
		chat::whisper($p, '/list diverters');
		chat::whisper($p, '/add diverter <x1>,<y1> <x2>,<y2>');
		chat::whisper($p, '/del diverter <x1>,<y1>');
		chat::whisper($p, 'only binary diverters are supported');
	},

	'list diverters'	=> sub {
		my($e, $p)=@_;
		my($divs)=stash::get('diverters', map::name, 'map');
		my(%seen)=();

		foreach my $diverter (keys(%$divs)) {
			unless(exists($seen{$diverter})) {
				chat::whisper($p, $diverter, ':', $divs->{$diverter});
				$seen{$divs->{$diverter}}=1;
			}
		}
	},

	'add diverter'	=> sub {
		my($e, $p, $x1, $y1, $x2, $y2)=@_;

		stash::set("$x1,$y1", 'diverters', map::name, 'map', "$x2,$y2");
		stash::set("$x2,$y2", 'diverters', map::name, 'map', "$x1,$y1");
	},

	'del diverter'	=> sub {
		my($e, $p, $x1, $y1)=@_;
		my($divs)=stash::get('diverters', map::name, 'map');

		stash::delete($divs->{"$x1,$y1"}, 'diverters', map::name, 'map');
		stash::delete("$x1,$y1", 'diverters', map::name, 'map');
	},

	'help oneways'	=> sub {
		my($e, $p)=@_;

		chat::whisper($p, 'Ensure anyone picking up a powerup is traveling in a direction');
		chat::whisper($p, '/list oneways');
		chat::whisper($p, '/add oneway <x>,<y> <direction>');
		chat::whisper($p, '/del oneway <x>,<y>');
	},

	'list oneways'	=> sub {
		my($e, $p)=@_;
		my($oneway)=stash::get('oneways', map::name, 'map');

		foreach my $powerup (keys(%$oneway)) {
			chat::whisper($p, $powerup, ':', $oneway->{$powerup});
		}
	},

	'add oneway'	=> sub {
		my($e, $p, $x, $y, $direction)=@_;

		stash::set("$x,$y", 'oneways', map::name, 'map', lc($direction));
	},

	'del oneway'	=> sub {
		my($e, $p, $x, $y)=@_;

		stash::delete("$x,$y", 'oneways', map::name, 'map');
	},

	'help zones'	=> sub {
		my($e, $p)=@_;

		chat::whisper($p, 'Zones are used by spawnType zone and near for spawn locations');
		chat::whisper($p, '/list zones');
		chat::whisper($p, '/add zone <name> <team> <x>,<y>,<a>');
		chat::whisper($p, '/del zone <name> <team>');
	},

	'list zones'	=> sub {
		my($e, $p)=@_;
		my($spawn_mode)=stash::get('spawnMode', map::name, 'map');
		my($any)=0;
		my(@teams)=();
		my(@keys)=();
		my($sep)=':';
		my($zones, $keys, $names, $status);

		if($e->{'admin'} || map::spec($p->{'team'})) {
			@teams=(map::left, map::right);
		} elsif(map::left($p->{'team'})) {
			@teams=(map::left);
		} elsif(map::right($p->{'team'})) {
			@teams=(map::right);
		}
		foreach my $team (@teams) {
			$zones=stash::get('zones', $team, 'zones', map::name, 'map');
			$keys=utils::invert(stash::get('keys', $team, 'zones', map::name, 'map'));
			$names=stash::get('name', $team, 'door', map::name, 'map');

			if(@teams==2) {
				if(map::left($team)) {
					$sep='<';
				} else {
					$sep='>';
				}
			}

			if($zones) {
				foreach my $zone (sort(keys(%$zones))) {
					if(plus::zone_open($p, $zone)) {
						$status='(open)';
					} else {
						$status='(closed)';
					}
					if(exists($keys->{$zone})) {
						foreach my $key (@{$keys->{$zone}}) {
							if(plus::key_found($p, $key)) {
								push(@keys, '('.$names->{$key}.':'.$key.')');
							} else {
								push(@keys, $names->{$key}.':'.$key);
							}
						}
						chat::whisperf($p, "%s $sep %d,%d @%s <= %s",
							$zone, @{$zones->{$zone}}, "@keys $status"
						);
					} elsif($spawn_mode eq 'powerup') {
						chat::whisperf($p, "%s $sep %d,%d @%s (%s)",
							$zone,
							@{$zones->{$zone}},
							join(', ', map::powerup_lookup(@{$zones->{$zone}}))
						);
					} else {
						chat::whisperf($p, "%s $sep %d,%d @%s",
							$zone, @{$zones->{$zone}});
					}
					delete($keys->{$zone});
					$any=1;
				}
			}

			foreach my $key (sort(keys(%$keys))) {
				chat::whisper($p, 'orphaned key', $key ,':', @{$keys->{$key}});
				$any=1;
			}
		}

		if($spawn_mode=~m/powerup|zone|near|after/) {
			chat::whisper($p, 'No spawn zones defined') unless($any);
		} else {
			chat::whisper($p, 'spawnMode is not set to use zones');
		}
	},

	'add zone'	=> sub {
		my($e, $p, $zone, $team, $sx, $sy, $sa)=@_;

		$team='*' unless($team);

		if(map::left($team)) {
			stash::set($zone, 'zones', map::left, 'zones', map::name, 'map', [$sx, $sy, $sa]);
			chat::all('Added left zone:', $zone, "($sx,$sy)");
		}

		if(map::right($team)) {
			stash::set($zone, 'zones', map::right, 'zones', map::name, 'map', [$sx, $sy, $sa]);
			chat::all('Added right zone:', $zone, "($sx,$sy)");
		}
	},

	'del zone'	=> sub {
		my($e, $p, $zone, $team)=@_;

		$team='*' unless($team);

		if(map::left($team)) {
			if(stash::delete($zone, 'zones', map::left, 'zones', map::name, 'map')) {
				chat::all('Deleted left zone:', $zone);
			} else {
				chat::whisper($p, 'No left zone', $zone);
			}
		}

		if(map::right($team)) {
			if(stash::delete($zone, 'zones', map::right, 'zones', map::name, 'map')) {
				chat::all('Deleted right zone:', $zone);
			} else {
				chat::whisper($p, 'No right zone', $zone);
			}
		}
	},

	'help notes'		=> sub {
		my($e, $p)=@_;

		chat::whisper($p, 'Specify a message to display to players who access a powerup');
		chat::whisper($p, '/list notes');
		chat::whisper($p, '/add note <x>,<y> <message text>');
		chat::whisper($p, '/del note <x>,<y>');
		chat::whisper($p, 'Note, only admins can see message texts with /list notes');
	},

	'list notes'		=> sub {
		my($e, $p)=@_;
		my($msgs)=stash::get('notes', map::name, 'map');

		if($msgs && %$msgs) {
			if($e->{'admin'}) {
				foreach my $msg (keys(%$msgs)) {
					chat::whisper($p, $msg, ':', $msgs->{$msg});
				}
			} else {
				chat::whisper($p, keys(%$msgs));
			}
		} else {
			chat::whisper($p, 'No messages attached to powerups');
		}
	},

	'add note'			=> sub {
		my($e, $p, $x, $y, @msg)=@_;

		stash::set("$x,$y", 'notes', map::name, 'map', join(' ', @msg));
		chat::whisper($p, "Message set for powerup at $x,$y");
	},

	'del note'			=> sub {
		my($e, $p, $x, $y)=@_;

		if(stash::delete("$x,$y", 'notes', map::name, 'map')) {
			chat::whisper($p, "Message at $x,$y deleted");
		} else {
			chat::whisper($p, "Could not find message at $x,$y to delete");
		}
	},

	'help powerups'	=> sub {
		my($e, $p)=@_;

		chat::whisper($p, 'Mark a powerup special to the game type (e.g. flag or race)');
		chat::whisper($p, '/list powerups');
		chat::whisper($p, '/add powerup <name> <team> <x>,<y>');
		chat::whisper($p, '/del powerup <name> <team> <x>,<y>');
	},

	'list powerups'	=> sub {
		my($e, $p)=@_;
		my($powerups)=stash::get('powerups', map::name, 'map');
		my($any)=0;
		my($groups);

		if($e->{'admin'}) {
			$groups=utils::invert($powerups->{map::left});
			foreach my $key (sort(keys(%$groups))) {
				chat::whisper($p, '<', $key, ':', @{$groups->{$key}});
				$any=1;
			}

			$groups=utils::invert($powerups->{map::right});
			foreach my $key (sort(keys(%$groups))) {
				chat::whisper($p, '>', $key, ':', @{$groups->{$key}});
				$any=1;
			}
		} else {
			$groups=utils::invert($powerups->{$p->{'team'}});
			foreach my $key (sort(keys(%$groups))) {
				chat::whisper($p, $key, ':', @{$groups->{$key}});
				$any=1;
			}
		}

		chat::whisper($p, 'No special powerups defined') unless($any);
	},

	'add powerup'	=> sub {
		my($e, $p, $powerup, $team, $px, $py)=@_;
		my(@powerups)=();
		my($color);

		$team='*' unless($team);

		if(map::left($team)) {
			$color=map::team_color('left');
			stash::set("$px,$py", map::left, 'powerups', map::name, 'map', $powerup);
			chat::all("Added left ($color) powerup:", $powerup, "($px,$py)");
		}

		if(map::right($team)) {
			$color=map::team_color('right');
			stash::set("$px,$py", map::right, 'powerups', map::name, 'map', $powerup);
			chat::all("Added right ($color) powerup:", $powerup, "($px,$py)");
		}
	},
	
	'del powerup'	=> sub {
		my($e, $p, $team, $px, $py)=@_;
		my($powerup);
		my($color);

		$team='*' unless($team);

		if(map::left($team)) {
			$color=map::team_color('left');
			$powerup=stash::get("$px,$py", map::left, 'powerups', map::name, 'map');
			if(stash::delete("$px,$py", map::left, 'powerups', map::name, 'map')) {
				chat::all("Deleted left ($color) powerup:", $powerup, "($px,$py)");
			} else {
				chat::whisper($p, 'No left powerup at', "$px,$py");
			}
		}

		if(map::right($team)) {
			$color=map::team_color('right');
			$powerup=stash::get("$px,$py", map::right, 'powerups', map::name, 'map');
			if(stash::delete("$px,$py", map::right, 'powerups', map::name, 'map')) {
				chat::all("Deleted right ($color) powerup:", $powerup, "($px,$py)");
			} else {
				chat::whisper($p, 'No right powerup at', "$px,$py");
			}
		}
	},
	
	'prey'		=> sub {
		my($e, $p)=@_;
		my($nick)=@{$e->{'arguments'}};
		my($prey)=player::lookup($nick);

		plus::change_hunted($prey);
	},

	'spawnZone'	=> sub {
		my($e, $p)=@_;
		my($zone)=@{$e->{'arguments'}};
		my($coords)=stash::get($zone, 'zones', $p->{'team'}, 'zones', map::name, 'map');
		my($spawn_mode)=stash::get('spawnMode', map::name, 'map');

		if($p->{'carrier'}) {
			chat::whisper($p, 'You cannot /spawnZone as a carrier');
		} elsif($zone=~m/^start$/i) {
			if($p->{'alive'}) {
				if(map::mode('ffa')) {
					chat::whisper($p, 'Next spawn will be in', $zone);
				} else {
					plus::bench($p);
				}
			}
			plus::spawn_reset($p);
		} elsif($p->{'admin'} && $zone=~m/^here$/i) {
			server::trigger('logPlanePositions', 'spawnHere', $e, $p);
		} elsif($spawn_mode ne 'zone') {
			chat::whisper($p, "Zone spawning not allowed in mode: $spawn_mode");
		} elsif(ref($coords) eq 'ARRAY') {
			if(plus::zone_open($p, $zone)) {
				if($p->{'alive'}) {
					if(map::mode('ffa')) {
						chat::whisper($p, 'Next spawn will be in', $zone);
					} else {
						plus::bench($p);
					}
				}
				plus::spawn_here($p, @$coords);
			} else {
				chat::whisper($p, "Zone '$zone' is not yet open");
			}
		} else {
			chat::whisper($p, "No zone named '$zone'");
		}
	},

	'sz'			=> sub {
		$HOOKS{'spawnZone'}->(@_);
	},

	'logPlanePositions:spawnHere'	=> sub {
		my($e1, $p1, $e2, $p2)=@_;

		queue::schedule {
			server::trigger(	'logPlanePositions',
							'logPlanePositions:spawnHere',
							$e1, $p1, $e2, $p2)
		} 0.5;
	},

	'logPlanePositions:logPlanePositions:spawnHere'	=> sub {
		my($e1, $p1, $e2, $p2, $e3, $p3)=@_;
		my(@pos1)=split(m/,/, $e2->{'positionByPlayer'}{$p3->{'player'}});
		my(@pos2)=split(m/,/, $e1->{'positionByPlayer'}{$p3->{'player'}});

		plus::spawn_here($p3, @pos1, $pos2[0]-$pos1[0], $pos2[1]-$pos1[1]);
		chat::whisper($p3, '/spawnZone here registered');
	},

	'changePlane'	=> sub {
		my($e, $p)=@_;
		my($cp)=stash::get('changePlane', map::name, 'map') // config::option('changePlane');

		if($p->{'carrier'}) {
			chat::whisper($p, 'You cannot /changePlane as a carrier');
		} elsif(player::count > $cp) {
			chat::whisper($p, 'Too many players to /cp or /changePlane');
		} else {
			server::trigger('logPlanePositions', 'changePlane', $e, $p);
		}
	},

	'cp'			=> sub {
		$HOOKS{'changePlane'}->(@_);
	},

	'logPlanePositions:changePlane'	=> sub {
		my($e1, $p1, $e2, $p2)=@_;

		if($p2->{'carrier'}) {
			chat::whisper($p2, 'You cannot /changePlane as a carrier');
		} else {
			queue::schedule {
				server::trigger(	'logPlanePositions',
								'logPlanePositions:changePlane',
								$e1, $p1, $e2, $p2)
			} 0.5;
		}
	},

	'logPlanePositions:logPlanePositions:changePlane'	=> sub {
		my($e1, $p1, $e2, $p2, $e3, $p3)=@_;
		my(@pos1)=split(m/,/, $e2->{'positionByPlayer'}{$p3->{'player'}});
		my(@pos2)=split(m/,/, $e1->{'positionByPlayer'}{$p3->{'player'}});

		if($p3->{'carrier'}) {
			chat::whisper($p3, 'changePlane aborted, you are a carrier');
		} else {
			plus::bench($p3);
			plus::spawn_here($p3, @pos1, $pos2[0]-$pos1[0], $pos2[1]-$pos1[1]);
			plus::clear_spawn($p3);
		}
	},

	'sum'		=> sub {
		my($e, $p)=@_;
		my($name)=@{$e->{'arguments'}};
		my($map)=map::file;
		my(%sums)=(
			'crc32'	=> 'cksum',
			'md5'	=> 'md5sum',
			'sha1'	=> 'sha1sum',
			'sha256'	=> 'sha256sum',
		);
		my($sum)=$sums{lc($name)};

		unless($sum) {
			chat::whisper($p, "Invalid digest name: $sum");
			chat::whisper($p, "Choose from: crc32 md5 sha1 sha256");
			return(0);
		}

		if(-r $map && file::name_ok($map)) {
		chat::whisper($p, map::name, ':', file::sum($sum, $map));
		}
	},

	'sessionStart'		=> sub {
		my($e)=@_;
		my(@time)=($e->{'date'}=~m/(\d+) (\w+) (\d+) (\d+):(\d+):(\d+):(\d+)/);
		my(%month)=qw(Jan 0  Feb 1  Mar 2  Apr 3  May 4  Jun 5  Jul 6  Aug 7  Sep 8  Oct 9  Nov 10  Dec 11);

		tourney::clear;

		$time[0]-=1900;
		$time[1]=$month{$time[1]};

		$server::Start=POSIX::mktime(@time[5,4,3,2,1,0])+$time[6]/1000;
	},

	'serverPatches'	=> sub {	#LewisH server patch add-on
		my($e)=@_;

		xx::initialize_mods($e->{'version'});
	},

	'clientAdd'		=> sub {
		my($e, $p)=@_;
		my($anick)=stash::get('nick', $e->{'vaporId'}, 'abuse');
		my($name);

		#                       PlayerId|VaporID
		if($e->{'nickname'}=~m/^(\d{1,2}|[0-9a-f-]{36})$/) {
			chat::whisper($e, 'Invalid nickname for this server.');
			queue::schedule {
				server::send('kick', $e->{'nickname'});
			} 5;
			return(undef);
		} elsif($e->{'vaporId'}=~m/[^0-]/ && $e->{'nickname'}=~m/^Bot \d\d?/) {
			chat::whisper($e, 'Invalid nickname for this server.');
			queue::schedule {
				server::send('kick', $e->{'nickname'});
			} 5;
			return(undef);
		} elsif($anick) {
			if($e->{'nickname'}=~m/\Q$anick\E/) {
				chat::whisper($e, 'Change your nickname if you want to play here.');
				queue::schedule {
					server::send('kick', $e->{'nickname'});
				} 5;
			} else {
				stash::delete('nick', $e->{'vaporId'}, 'abuse');
			}
			return(undef);
		}

		return unless($e && $p);

		$p->{'stats'}={};
		$p->{'spawn'}=undef;

		player::add($p);

		return if($p->{'isBot'});

		rank::join($p);

		altbouncer::add($p);

		if($p->{'name'} && $p->{'name'} ne $p->{'nickname'}) {
			$name="$p->{'nickname'}($p->{'name'})";
		} else {
			$name=$p->{'nickname'};
		}

		if($p->{'country'}=utils::geoip($p->{'ip'})) {
			ui::display('', '', "< $name entered from $p->{'country'} >");
		} else {
			ui::display('', '', "< $name entered >");
		}

		foreach my $statement (split(m/;/, config::option('motd'))) {
			chat::whisper($p, $statement);
		}

		if(length($p->{'name'})>1 && length($p->{'nickname'})>1) {
			unless(utils::like($p->{'name'}, $p->{'nickname'})) {
				queue::schedule {
					if($p && $p->{'joined'}) {
						chat::moderator("$p->{'nickname'} is $p->{'name'}");
					}
				} 10;
			}
		}

		race::block($p) if(race::on);
	},

	'clientNicknameChange'	=> sub {
		my($e, $p)=@_;

		player::rename($e->{'oldNickname'}, $e->{'newNickname'});

		altbouncer::add($p);

		if(chat::laudy) {
			chat::whisper($p, 'Oh', $p->{'nickname'},
				', you will always be', $p->{'vaporId'}, 'to me.');
		}
	},

	'clientRemove'		=> sub {
		my($e, $p)=@_;
		my($reason)='';
		my($name);

		if($p->{'name'} && $p->{'name'} ne $p->{'nickname'}) {
			$name="$p->{'nickname'}($p->{'name'})";
		} else {
			$name=$p->{'nickname'};
		}

		records::help($p, -10);

		race::del($p);
		plus::leave($p);
		player::remove($p);

		return if($p->{'isBot'});

		if($p->{'spawn'}) {
			$p->{'stats'}{'played'}+=$e->{'time'} - $p->{'spawn'};
		} else {
			$p->{'stats'}{'played'}+=0;
		}

		rank::enter($p);

		map::busy;

		if(exists($e->{'reason'}) && $e->{'reason'} ne 'Client left.') {
			$reason=$e->{'reason'};
			$reason=~s/\..*$//s;
			ui::display('', '', "< $name $e->{'message'} ($reason)>");
		} else {
			ui::display('', '', "< $name $e->{'message'} >");
		}
	},

	'balanceTeams'		=> sub {
		ball::reset;
	},

	'teamChange'		=> sub {
		my($e, $p)=@_;
		my($map_team)=stash::get('assignTeam', map::name, 'map');
		my($minlvl)=0;
		my(@badge)=();
		my(@found)=();
		my($zones, $doors, $keys, $planes, $intro);
		
		if($p->{'isBot'}) {
			$p->{'team'}=$e->{'team'};
			return;
		}

		$p->{'alive'}=0;

		#Make sure players are the correct level for their aceRank:
		if($p->{'aceRank'}==0) {
			$minlvl=config::option('noviceLevel');
			@badge=('on this server');
		} else {
			$minlvl=config::option('aceLevel');
			@badge=('at Ace', $p->{'aceRank'});
		}
		if($p->{'level'} < $minlvl) {
			$p->{'team'}=$e->{'team'};

			return if(map::spec($e->{'team'}));

			plus::assign($p, 'spec');
			player::infraction($p, 2);

			if(exists($MILESTONES{$minlvl})) {
				chat::whisper($p, 'You must unlock',
					$MILESTONES{$minlvl}, 'to play', @badge);
			} else {
				chat::whisper($p, 'You must reach level',
					$minlvl, 'to play', @badge);
			}

			return;
		}

		#Display the intro after users join (first teamChange to spec):
		unless($p->{'stats'}{'intro'}) {
			$intro=stash::get('intro', map::name, 'map');

			queue::schedule { $HOOKS{'list planes'}->($e, $p); } 3;

			if($intro) {
				foreach my $msg (split(m/\s*;+\s*/, $intro)) {
					queue::schedule { chat::whisper($p, $msg) } 5;
				}
			} elsif(map::type('flag')) {
				chat::whisper($p, '** Capture opposing flag to score points **');
			} elsif(map::type('race')) {
				chat::whisper($p, '** This is a race, 1st to cross the finish line wins **');
			} elsif(map::type('ruin')) {
				chat::whisper($p, '** Destroy all structures **');
			} elsif(map::type('mdg')) {
				chat::whisper($p, '** Asymmetric game play, 1 vs many **');
			} elsif(map::type('1lh')) {
				chat::whisper($p, '** 1 hit kills **');
			}

			$p->{'stats'}{'intro'}=1;
		}

		#Keep track of players and allow access only as necessary:
		if(map::spec($e->{'team'})) {
			if(map::spec($p->{'team'})) {
				$p->{'team'}=$e->{'team'};
				return;
			} else {
				plus::spawn_reset($p) unless(map::type('coop'));

				$p->{'team'}=$e->{'team'};

				plus::leave($p);
				plus::cower($p) if(plus::hunted($p));
	
				return;
			}
		} elsif(plus::enter($p)) {
			if($p->{'team'} != $e->{'team'}) {
				$p->{'team'}=$e->{'team'};
				plus::spawn_reset($p);

				#Print door informationt to the player
				$doors=utils::invert(stash::get('doors', $p->{'team'}, 'door', map::name, 'map'));
				$keys=utils::invert(stash::get('keys', $p->{'team'}, 'door', map::name, 'map'));
				foreach my $door (sort(keys(%$doors))) {
					if(plus::door_open($p, $door)) {
						chat::whisper($p, "$door open");
					} else {
						@found=();
						foreach my $key (sort(@{$keys->{$door}})) {
							if(plus::key_found($p, $key)) {
								push(@found, stash::get($key, 'name', $p->{'team'}, 'door', map::name, 'map'));
							}
						}
						if(@found) {
							chat::whisper($p, "$door keys found:", join(', ', @found));
						}
					}
				}
			}
		} else {
			plus::assign($p, 'spec');
			$p->{'team'}=-1;
			player::infraction($p, 0.2);

			return;
		}

		#Ensure players are on the correct team:
		if(map::type('mdg') && plus::prey($p)) {
			if(map::right($map_team)) {
				$zones=stash::get('zones', map::left, 'zones', map::name, 'map');
			} else {
				$zones=stash::get('zones', map::right, 'zones', map::name, 'map');
			}
			if(ref($zones) eq 'HASH' && %$zones) {
				plus::spawn_random($p);
			}
			if(map::right($map_team) && map::right($p->{'team'})) {
				plus::assign($p, 'left');
			} elsif(map::left($p->{'team'})) {
				plus::assign($p, 'right');
			}
		} elsif(map::right($map_team) && map::left($p->{'team'})) {
			plus::assign($p, 'right');
			return;
		} elsif(map::left($map_team) && map::right($p->{'team'})) {
			plus::assign($p, 'left');
			return;
		} elsif(!rank::team_check($p) && map::left($p->{'team'})) {
			plus::assign($p, 'right');
			return;
		} elsif(!rank::team_check($p) && map::right($p->{'team'})) {
			plus::assign($p, 'left');
			return;
		} else {
			plus::spawn_reset($p);
		}
	},

	'spawn'	=> sub {
		my($e, $p)=@_;
		my($map_team)=stash::get('assignTeam', map::name, 'map');
		my($zones)=stash::get('zones', $p->{'team'}, 'zones', map::name, 'map');
		my(@records)=split(m/\W+/, config::option('recordsTypes'));
		my($match);

		$p->{'team'}=$e->{'team'};
		$p->{'stats'}{'turret'}=0;

		@$p{'plane','perkRed','perkGreen','perkBlue','skin'}=
			@$e{'plane','perkRed','perkGreen','perkBlue','skin'};

		if($p->{'isBot'}) {
			$p->{'team'}=$e->{'team'};
			plus::next_bot if(xx::enabled);
			return;
		} elsif(plus::capture_wait($e)) {
			plus::bench($p);
		} elsif(plus::enter($p)) {
			$p->{'team'}=$e->{'team'};
		} else {
			plus::assign($p, 'spec');
			$p->{'team'}=-1;
			player::infraction($p, 0.2);
			plus::spawn_reset($p);

			return;
		}

		unless(plus::plane_check($p)) {
			plus::bench($p);
		}

		#Ensure players are on the correct team:
		if(map::type('mdg') && plus::prey($p)) {
			if(ref($zones) eq 'HASH' && %$zones) {
				plus::spawn_random($p);
			}
			if(map::right($map_team) && map::right($p->{'team'})) {
				plus::assign($p, 'left');
			} elsif(map::left($p->{'team'})) {
				plus::assign($p, 'right');
			}
		} elsif(map::right($map_team) && map::left($p->{'team'})) {
			plus::assign($p, 'right');
			return;
		} elsif(map::left($map_team) && map::right($p->{'team'})) {
			plus::assign($p, 'left');
			return;
		}

		plus::check_spawn($p);

		unless(plus::active) {
			if(map::name eq config::lobby) {
				server::send('changeMap', config::random_map);
			} else {
				records::mark($e) if(map::type(@records));
				race::mark($e);
			}
		}

		$p->{'alive'}=1;
		$p->{'spawn'}=$e->{'time'};

		race::spawn($p);

		if(	$p->{'perkGreen'} eq 'Rubberized Hull'	&&
			$p->{'perkBlue'}  eq 'Reverse Thrust'	&&
			$p->{'plane'}     =~ m/Loopy|Miranda/	&&
			map::type('coop', 'race')
		) {
			log::note(player::name($p), 'spawned with rev/rubber:',
				$p->{'nickname'}, $p->{'vaporId'});
		}

		if(chat::snarky) {
			foreach my $snark (List::Util::shuffle(keys(%SNARKS))) {
				$match=1;
				foreach my $test (keys(%{$SNARKS{$snark}})) {
					$match&=($e->{$test}=~m/\Q$SNARKS{$snark}{$test}/);
				}
				if($match) {
					chat::snark($p, sprintf($snark, $p->{'nickname'}));
					last;
				}
			}
		}
	},

	'playerInfoEv'	=> sub {	#LewisH server patch add-on (xx patches)
		my($e, $p)=@_;
		my($minlvl)=config::option('aceLevel');

		return if($p->{'isBot'});
		return if($e->{'leaving'});

		return if($e->{'level'}==1	&&
				$e->{'aceRank'}==0	&&
				$e->{'perkGreen'}=~m/No Green Perk/	&&
				$e->{'perkBlue'}=~m/No Blue Perk/
			);

		@$p{'plane','perkRed','perkGreen','perkBlue'}=
			@$e{'plane','perkRed','perkGreen','perkBlue'};

		if($e->{'level'}==60 && $p->{'level'}==59) {
			chat::whisper($p, 'Congratulations, you made it to level 60!');
			if($minlvl>1) {
				chat::whisper($p, "Don't ACE up, or you can't play.");
				chat::whisper($p, "Server minimum level is: $minlvl.");
			}

			@$p{'aceRank','level'}=@$e{'aceRank','level'};
		} elsif($e->{'level'} != $p->{'level'}) {
			if($e->{'aceRank'}>$p->{'aceRank'} && $p->{'level'}<$minlvl) {
				chat::whisper($p, "Congratulations on Acing up, but now you don't meet the minimum level requirement.");
				plus::assign($p, 'spec');
			}
			@$p{'aceRank','level'}=@$e{'aceRank','level'};
		}

		plus::plane_check($p); #Notify only, don't enforce until spawn
	},

	'goal'	=> sub {
		my($e, $p)=@_;
		my($a)=player::lookup($e->{'assister'});
		my($a2)=player::lookup($e->{'secondaryAssister'});
		my($spawn_mode)=stash::get('spawnMode', map::name, 'map');

		$p->{'stats'}{'goals'}++;
		$a->{'stats'}{'assists'}++;
		$a2->{'stats'}{'assists'}++;

		foreach my $player (player::list) {
			$player->{'stats'}{'played'}+=$e->{'time'}-$player->{'spawn'};
		}

		records::help($p, 20);

		ball::goal($e, $p);

		rank::score($p->{'team'}, 1);

		if($spawn_mode && $spawn_mode!~m/default|normal|start/) {
	 		foreach my $player (player::list) {
				plus::spawn_reset($player);
			}
		}

		if(chat::laudy) {
			if(ball::passes>3) {
				chat::laud('Nice teamwork', map::team_color($p->{'team'}));
			} elsif(ball::passes>2) {
				chat::laud('Good passing', map::team_color($p->{'team'}));
			}
		}

		ball::reset;
	},

	'ballLost'		=> sub {
		my($spawn_mode)=stash::get('spawnMode', map::name, 'map');

		ball::reset;

		if($spawn_mode=~m/near|after/) {
	 		foreach my $player (player::list) {
				plus::spawn_reset($player);
			}
		}
	},
	
	'overrideBallScore'	=> sub {
		my($e, $p)=@_;

		if($e->{'group'} eq 'Administrator') {
			ball::update_score( @{$e->{'arguments'}} );
		}
	},
	
	'overrideTdmScore'	=> sub {
		my($e, $p)=@_;

		if($e->{'group'} eq 'Administrator') {
			ball::update_score( @{$e->{'arguments'}} );
		}
	},
	
	'logPickups'		=> sub {
		my($e, $p)=@_;

		$p->{'logPickups'}^=1;

		if($p->{'logPickups'}) {
			chat::whisper($p, 'Pickup logging enabled');
		} else {
			chat::whisper($p, 'Pickup logging disabled');
		}
	},

	'powerupUse'	=> sub {
		my($e, $p)=@_;
		my($powerup)=$e->{'powerup'};
		my($diff)=$e->{'time'} - $p->{$powerup}{'time'};

		if(0<$diff && $diff<2000) {
			$p->{$powerup}{'count'}++;
		} else {
			$p->{$powerup}{'time'}=$e->{'time'};
			$p->{$powerup}{'count'}=1;
		}

		if($powerup eq 'Ball') {
			ball::shoot($e);
		} elsif($powerup eq 'Bomb') {
			$p->{'carrier'}=0;
			if($p->{'Bomb'}{'count'} > 8) {
				chat::snark($p, "$p->{'nickname'} bombs with extreme prejudice");
				$p->{'Bomb'}{'count'}=0;
			}
		} elsif($powerup eq 'Demolition Charge') {
			$p->{'carrier'}=0;
			records::help($p, 2);
		} elsif($powerup eq 'Homing Missile') {
			if($p->{'Homing Missile'}{'count'} > 12) {
				chat::snark($p, 'Hwacha');
				$p->{'Homing Missile'}{'count'}=0;
			}
		}

		$p->{'has'}=undef;
	},

	'powerupPickup'	=> sub {
		my($e, $p)=@_;
		my($spawn_mode)=stash::get('spawnMode', map::name, 'map');
		my($zones)=stash::get('zones', $p->{'team'}, 'zones', map::name, 'map');
		my($spawn)=$p->{'stats'}{'spawns'}[-1];
		my($pickup)=join(',', @$e{'positionX','positionY'});
		my(@fake_event)=();

		#Don't repeat this specific powerup for 0.8 seconds
		return unless(plus::no_repeats($e, $p));

		plus::capture($e, $p) if(map::type('flag'));

		if(map::type('race') && plus::checkpoint($e, $p)) {
			server::trigger('logPlanePositions', 'checkpoint', $e, $p)
		}

		plus::divert($e, $p);

		if(	ball::catch($e, $p)				&&
			ball::intercepted				&&
			map::goalbox($e) eq map::side($p)	&&
			map::going_in($e)
		) {
			$p->{'stats'}{'saves'}++;
			chat::snark($p, 'Nice Save', $p->{'nickname'}) if(chat::snarky);
		}

		if(map::powerup($e, 'Ball', 'Bomb', 'Demolition Charge')) {
			$p->{'carrier'}=1;
			records::help($p, 2) if(map::type('coop'));
		}

		$p->{'has'}=$e->{'powerup'} unless($e->{'powerup'} eq 'Health');

		return if($p->{'isBot'});

		if($e->{'powerup'} eq 'Ball') {
			$p->{'carrier'}=1;
			$p->{$e->{'powerup'}}{'time'}=0;
		} elsif($e->{'powerup'} eq 'Bomb') {
			$p->{'carrier'}=1;
			if($e->{'velocityX'} && $e->{'velocityY'} && chat::snarky) {
				chat::snark($p, 'Nice catch', $p->{'nickname'});
			}
		}

		if($p->{'logPickups'} && map::powerup($e)) {
			chat::whisper($p, $pickup,':',join(', ', map::powerup($e)));
		}

		plus::note($e, $p);

		return if(plus::key($e, $p));

		if(plus::teleport($e, $p)) {
			if($spawn_mode!~m/died|crash|powerup|health|portal/) {
				plus::clear_spawn($p);
			}
			return;
		}

		if($e->{'playerVelX'} && $e->{'playerVelY'}) { #LewisH velocity patch
			@fake_event=(
				{
					'type'			=> 'logPlanePositions',
					'port'			=> $e->{'port'},
					'time'			=> $e->{'time'}+1,
					'positionByPlayer'	=> {
						$e->{'player'}	=> join(',',
							$e->{'positionX'}+$e->{'playerVelX'},
							$e->{'positionY'}+$e->{'playerVelY'},
						),
					},
				}, player::server
			);
		}

		if(stash::get($pickup, 'oneways', map::name, 'map')) {
			#Don't repeat any oneway for 0.8 seconds
			if(plus::no_repeats($e, $p, 'oneway')) {
				if(@fake_event) {
					server::fake_trigger('logPlanePositions', 'oneway',
							@fake_event, $e, $p);
				} else {
					queue::schedule {
						server::trigger('logPlanePositions', 'oneway', $e, $p)
					} 1;
				}
			}
		} elsif($spawn_mode eq 'health') {
			chat::debug($spawn, $e->{'positionX'}, $e->{'positionY'});
			if(map::powerup($e, 'Health') && (
					!$spawn ||
					$e->{'positionX'}!=$spawn->[0] ||
					$e->{'positionY'}!=$spawn->[1]
				)
			) {
				server::trigger('logPlanePositions', 'powerup', $e, $p);
			}
		} elsif($spawn_mode eq 'powerup') {
			chat::debug($spawn, $e->{'positionX'}, $e->{'positionY'});
			if(map::powerup($e) && (
					!$spawn ||
					$e->{'positionX'}!=$spawn->[0] ||
					$e->{'positionY'}!=$spawn->[1]
				)
			) {
				if($zones) {
					foreach my $zone (keys(%$zones)) {
						if(	$e->{'positionX'}==$zones->{$zone}[0] &&
							$e->{'positionY'}==$zones->{$zone}[1]
						) {
							plus::spawn_here($p, @{$zones->{$zone}});
							chat::whisper($p, $zone);
						}
					}
				} else {
					server::trigger('logPlanePositions', 'powerup', $e, $p);
				}
			}
		}
	},

	'powerupAutoUse'	=> sub {
		$HOOKS{'powerupPickup'}->(@_);
	},

	'logPlanePositions:checkpoint' => sub {
		my($e1, $p1, $e2, $p2)=@_;
		my($pos)=$e1->{'positionByPlayer'};
		my($x, $y)=split(m/,/,$pos->{$p2->{'player'}});
		my($portals)=stash::get('portals', map::name, 'map');
		my($delta);

		foreach my $player (keys(%$pos)) {
			next if($player==$p2->{'player'});

			$delta=utils::distance($x, $y, split(m/,/, $pos->{$player}));

			plus::checkpoint($e2, player::lookup($player)) if($delta<60);
		}

		unless($portals->{join(',', @$e2{'positionX','positionY'})}) {
			#Turn x and y into velocity for angle calculation:
			$x-=$e2->{'positionX'};
			$y-=$e2->{'positionY'};
			plus::spawn_here($p2, $e2->{'positionX'}, $e2->{'positionY'}, $x, $y);
		}
	},

	'logPlanePositions:powerup'	=> sub {
		my($e1, $p1, $e2, $p2)=@_;
		my($x, $y)=split(m/,/,$e1->{'positionByPlayer'}{$p2->{'player'}});

		#Turn x and y into velocity for angle calculation:
		$x-=$e2->{'positionX'};
		$y-=$e2->{'positionY'};

		plus::spawn_here($p2, $e2->{'positionX'}, $e2->{'positionY'}, $x, $y);
	},

	'logPlanePositions:oneway' 	=> sub {
		my($e1, $p1, $e2, $p2)=@_;
		my($x1, $y1)=split(m/,/,$e1->{'positionByPlayer'}{$p2->{'player'}});
		my($x2, $y2)=@$e2{'positionX','positionY'};
		my($allowed)=plus::angle($x2, $y2, stash::get("$x2,$y2", 'oneways', map::name, 'map'));
		my($direction)=plus::angle($x2, $y2, $x1-$x2, $y1-$y2);
		my($wrong_way)=0;

		if($allowed>90 && $direction<0) {
			$wrong_way=1 if(plus::angle($x2, $y2, $allowed+90)<$direction);
		} elsif($allowed<=-90 && $direction>0) {
			$wrong_way=1 if(plus::angle($x2, $y2, $allowed-90)>$direction);
		} elsif($direction<($allowed-90) || ($allowed+90)<$direction) {
			$wrong_way=1;
		}

		if($wrong_way) {
			plus::bench($p2);
			plus::spawn_here($p2, $x2, $y2, $allowed);
			if($x1>0 && $x2>0) { #alive
				chat::whisper($p2, 'Wrong way!');
			}
		}
	},

	'kill'	=> sub {
		my($e, $p)=@_;
		my($v)=player::lookup($e->{'victim'});
		my($spawn_mode)=stash::get('spawnMode', map::name, 'map');
		my($assign)=stash::get('assignTeam', map::name, 'map');
		my($is_crash)=0;
		my($angle);

		$is_crash=1 if($e->{'player'}==-1 && $e->{'source'} eq 'plane');

		if($p) {
			if(map::mode('tdm', '1dm')) {
				if(map::type('race')) {
					ball::score;
				} else {
					ball::goal($e, $p);
					rank::score($p->{'team'}, 1);
				}
			}
		}

		if($v) {
			$v->{'alive'}=0;
			ball::drop($v);
		}

		if($p && !$p->{'isBot'} && $p->{'team'}!=$v->{'team'}) {
			$p->{'stats'}{'powerkill'}++ if($v->{'carrier'});
			$p->{'stats'}{'kills'}++;
			$p->{'stats'}{'kill'}{$v->{'nickname'}}++ unless($v->{'isBot'});

			if(map::type('mdg')) {
				if(plus::prey($p)) {
					records::help($p, 5);
				} else {
					records::help($p, 10);
				}
			} elsif(map::type('ruin') && $assign) {
				records::help($p, 5);
			} elsif(map::mode('1de', '1bd')) {
				records::help($p, 5);
			} elsif(map::mode('tdm', '1dm', 'ffa')) {
				records::help($p, 4);
			} elsif(map::type('race')) {
				records::help($p, 3);
			} else {
				records::help($p, 2);
			}
		}

		if($v && !$v->{'isBot'}) {
			$v->{'stats'}{'fumble'}++ if($v->{'carrier'});
			$v->{'stats'}{'played'}+=$e->{'time'}-$v->{'spawn'};
			$v->{'stats'}{'died'}++;

			if($is_crash) {
				$v->{'stats'}{'crashes'}++;

				if(	$v->{'perkGreen'} eq 'Rubberized Hull'	&&
					$v->{'perkBlue'}  eq 'Reverse Thrust'	&&
					$v->{'plane'}     =~ m/Loopy|Miranda/	&&
					map::type('std', 'coop', 'race')
				) {
					log::note(player::name($v), 'crashed with rev/rubber:',
						json::encode($e), json::encode($v));

					if(hull::in_wall($e)) {
						ui::slog(player::name($v), 'crashed inside wall!');
					}
				}
			}

			plus::killed($v);
			plus::check_spawn($v);

			if($spawn_mode eq 'died' || $spawn_mode eq 'crash') {
				if($is_crash) {
					plus::spawn_here($v, hull::safe_spawn($e));
				} else {
					plus::spawn_here($v, 
						$e->{'victimPositionX'}, $e->{'victimPositionY'},
						$e->{'victimVelocityX'}, $e->{'victimVelocityY'});
				}
			} elsif($spawn_mode=~m/near|after/) {
				plus::spawn_near($v,
					$e->{'victimPositionX'}, $e->{'victimPositionY'});
			}
		}

		return unless($p && $v);
		return if($p->{'isBot'} || $v->{'isBot'});
		return unless($e->{'source'} eq 'plane');

		if(map::type('mdg')) {
			if(map::mode('ball')) {
				if($is_crash) {
					'crash';
				} elsif($p->{'team'} == $v->{'team'}) {
					'friendly fire';
				} else {
					plus::score($p);
				}
			}
		}

		if(List::Util::max(map(abs, @$e{'victimVelocityX', 'victimVelocityY'})) > 18) {
			chat::snark($v, "$v->{'nickname'} says Ouch!!");
		}

		if($p->{'team'} == $v->{'team'}) {
			records::help($p, -4);
			chat::snark($v, "$v->{'nickname'} was killed by friendly fire");
		} elsif($e->{'multi'}>5) {
			chat::snark($p, "$p->{'nickname'} says Booyah!!");
		} elsif($e->{'streak'}>10 && $e->{'streak'}%2) {
			chat::snark($p, "$p->{'nickname'}: $e->{'streak'}");
		} elsif(($v->{'stats'}{'died'}%10)==0 && player::count>4) {
			if($p->{'stats'}{'kill'}{$v->{'nickname'}} > $v->{'stats'}{'died'}/(player::count()/4)) {
				if(chat::snarky) {
					chat::snark($v, "$p->{'nickname'} must really like killing $v->{'nickname'}");
				}
			}
		}
	},

	'structureDamage'	=> sub {
		my($e, $p)=@_;

		if($e->{'target'} eq 'base') {

			records::help($p, $e->{'xp'}-5);

			if(map::mode('1de', '1bd')) {
				$p->{'stats'}{'base'}+=4;

				rank::score($p->{'team'}, 4);
			} else {
				$p->{'stats'}{'base'}+=$e->{'xp'}/30;

				rank::score($p->{'team'}, $e->{'xp'}/30);
			}
		} else {
			records::help($p, 1);
		}
	},

	'structureDestroy'	=> sub {
		my($e, $p)=@_;

		$p->{'stats'}{$e->{'target'}}++;

		if($e->{'target'} eq 'base') {
			records::help($p, 10);
		} else {
			records::help($p, 2);
		}

		plus::destroy($e, $p);
		records::destroy($e, $p);

		if( ($p->{'stats'}{$e->{'target'}} % 35)==0 ) {
			chat::snark($p, "$p->{'nickname'} is tearing down the house");
		}
	},

	'demolitionChargePlanted'	=> sub {
		my($e, $p)=@_;
		my($timer, $used)=map::timer;

		if(map::type('coop')) {
			records::help($p, 10);
			server::trigger('logPlanePositions', 'demolitionChargePlanted', $e, $p);
		}

		if($timer && $timer-$used<25) {
			server::send('timer', 25);
		}
	},

	'logPlanePositions:demolitionChargePlanted'	=> sub {
		my($e1, $p1, $e2, $p2)=@_;
		my($pos)=$e1->{'positionByPlayer'};
		my(@ref)=split(m/,/, $pos->{$p2->{'player'}});
		my(@cur);

		return if($ref[0] == -1);

		foreach my $playerid (keys(%$pos)) {
			@cur=split(m/,/, $pos->{$playerid});

			next if($cur[0] == -1);

			records::help(player::lookup($playerid),
				List::Util::max(1, 10-utils::distance(@ref, @cur)/100)
			);
		}
	},

	'pingSummary'	=> sub {
		my($e, $p)=@_;
		my(%pings)=%{$e->{'pingByPlayer'}};
		my($player);

		foreach my $player_id (keys(%pings)) {
			$player=player::lookup($player_id);
			$player->{'ping'}=$pings{$player_id};

			if($player->{'alive'} && map::type('coop')) {
				records::help($player, 1);
			}
		}

		return unless(chat::snarky);
		return if($config::Ping<100);

		foreach my $player_id (List::Util::shuffle(keys(%pings))) {
			if($pings{$player_id}>=$config::Ping) {
				$player=player::lookup($player_id);
				chat::snark($player, $player->{'nickname'}, 'is laggy');
				last;
			}
		}
	},

	'chat'		=> sub {
		my($e, $p)=@_;
		my($bully_kick)=config::option('bullyKick');
		my($to)='*';

		#race::ready($p) if(race::on && $e->{'message'}=~m/^\s*go\s*$/i);

		if($e->{'team'}) {
			$to=map::team_symbol($p->{'team'});
		}

		if($e->{'blocked'}) {
			$to='!';

			$e->{'message'}=~m/^(.{1,10})/;
			chat::whisper($p, 'Message (', $1, ') not delivered');
		}

		ui::chat_log($to, $p->{'nickname'}, $e->{'message'});

		if(config::language($e->{'message'})) {
			chat::whisper($p, 'language(', player::infraction($p, 1), ')');
		} elsif(config::harrasment($e->{'message'})) {
			player::infraction($p, 0.3);
		} elsif($e->{'blocked'} && $bully_kick) {
			player::infraction($p, 0.1);
		} elsif(config::yelling($e->{'message'}) && $bully_kick) {
			player::infraction($p, 0.2);

			$p->{'stats'}{'yelling'}++;
			if($p->{'stats'}{'yelling'}%6 == 0) {
				chat::whisper($p, 'stop yelling');
			} elsif($p->{'stats'}{'yelling'}>20) {
				server::send('addChatBlock', $p->{'vaporId'}, 'AllChat',
					'2', 'minute', 'stop yelling in chat');
				$p->{'stats'}{'yelling'}/=2;
			}
		}
	},

	'serverMessage'	=> sub {
		my($e, $p)=@_;
		my($msg)=join(' ', @{$e->{'arguments'}});

		ui::chat_log('*', 'server', $msg);
	},

	'objectiveGameStart'	=> sub {
		my($e, $p)=@_;

		map::teams($e->{'leftTeam'}, $e->{'rightTeam'});
		plus::new;
	},

	'objectiveGameEnd' 		=> sub {
		my($e, $p)=@_;

		if($e->{'timeSeconds'}<=5) {
			if(map::idle > config::option('timeIdleChange')/4) {
				server::send('changeMap', config::lobby) if(config::lobby);
			}
		} else {
			plus::restart_clear;
			queue::clear;
			records::enter($e);
			log::finish;
		}
	},

	'roundEnd'	=> sub {
		my($e)=@_;
		my(%stats)=%{$e->{'participantStatsByName'}};
		my(%award)=%{$e->{'winnerByAward'}};
		my($pls)=$e->{'participants'};
		my($ratio)=[];
		my($cps)=[];
		my($saves)=[];
		my($keys)=[];
		my($player, $n);

		queue::clear;

		if(config::option('awards') && player::count>2) {
			if($stats{'Crashes'} && List::Util::max(@{$stats{'Crashes'}})>8) {
				plus::most('Training Wheels Award: ', $stats{'Crashes'}, $pls);
			}
			if($stats{'Deaths'} && !map::type('race')) {
				plus::most('Kenny McCormick Award: ', $stats{'Deaths'}, $pls);
			}
			if($stats{'Damage Dealt'} && !map::type('race') && !(map::type('std') && map::mode('ball'))) {
				plus::most('Sledge Hammer Award: ', $stats{'Damage Dealt'}, $pls);
			}
			if($stats{'Damage Received'} && !map::type('race')) {
				plus::most('Tank Award: ', $stats{'Damage Received'}, $pls);
			}
	
			if($stats{'Kills'} && $stats{'Deaths'} && !map::type('coop')) {
				for(my $i=0; $i<@$pls; $i++) {
					$stats{'Deaths'}->[$i]=1 unless($stats{'Deaths'}->[$i]);
					$ratio->[$i]=$stats{'Kills'}->[$i]/$stats{'Deaths'}->[$i];
				}
				plus::most('Best Ratio: ', $ratio, $pls);
			}

			if(map::type('race')) {
				for(my $i=0; $i<@$pls; $i++) {
					$player=player::lookup($pls->[$i]);
					$cps->[$i]=$player->{'stats'}{'first_cp'} if($player);
				}
				plus::most('Front Runner: ', $cps, $pls);
			}

			if(map::mode('ball')) {
				for(my $i=0; $i<@$pls; $i++) {
					$player=player::lookup($pls->[$i]);
					$saves->[$i]=$player->{'stats'}{'saves'} if($player);
				}
				plus::most('Savior Award: ', $saves, $pls);
			}

			if('key finder stats') {
				for(my $i=0; $i<@$pls; $i++) {
					$player=player::lookup($pls->[$i]);
					$keys->[$i]=$player->{'stats'}{'keys'} if($player);
				}
				plus::most('Key Master: ', $keys, $pls);
			}

			foreach my $v (player::list) {
				$n=$v;
				foreach my $p (player::list) {
					$n=$p if(	$p->{'stats'}{'kill'}{$v->{'nickname'}} >
					 		$n->{'stats'}{'kill'}{$v->{'nickname'}}	);
				}

				chat::whisper($v, 'Your Nemisis:', $n->{'nickname'})
					if($n->{'stats'}{'kill'}{$v->{'nickname'}}>2);
			}
		}

		foreach my $p (player::list) {
			$p->{'stats'}{'played'}+=$e->{'time'} - $p->{'spawn'};

			rank::enter($p);

			log::player($p);
		}

		if(map::mode('ball', 'tbd', 'tdm', 'ffa')) {
			queue::schedule { records::enter($e) } 2;
		}

		queue::schedule { log::finish } 2;

		map::end;

		#This is a good time to do other stuff:
		if(altbouncer::count > 250) {
			queue::background { altbouncer::upload } 0;
			altbouncer::clear;
		}
	},

	'restartMap'	=> sub {
		my($e, $p)=@_;
		my(@alive)=();

		if(map::type('coop')) {
			foreach my $player (player::list('both')) {
				if($player->{'alive'} && !$player->{'isBot'}) {
					push(@alive, $player);
				}
			}

			if($p->{'admin'} || $p->{'moderator'}) {
				if(map::mode('1de', '1dm', '1bd')) {
					server::send('balanceTeams');
				} else {
					server::send('changeMap', map::name);
				}
			} elsif(@alive<=2 && grep($p==$_, @alive)) {
				if(map::mode('1de', '1dm', '1bd')) {
					server::send('balanceTeams');
				} else {
					server::send('changeMap', map::name);
				}
			} else {
				plus::restart_request($p);
			}
		} else {
			chat::whisper($p, 'This command is only available for coop');
		}
	},

	'restartServer'	=> sub {
		my($e, $p)=@_;

		return unless($e->{'superAdmin'});

		chat::all('Restarting server in');
		ui::display('', '', 'Restarting server in');
		chat::all("5"); ui::display('', '', '5');
		sleep(1);
		chat::all("4"); ui::display('', '', '4');
		sleep(1);
		chat::all("3"); ui::display('', '', '3');
		sleep(1);
		chat::all("2"); ui::display('', '', '2');
		sleep(1);
		chat::all("1"); ui::display('', '', '1');
		sleep(1);

		config::launcher;

		if(config::option('updateMapList')) {
			config::find_maps;
		} else {
			config::read_maps;
		}

		config::write_launcher_config;

		server::start;
		server::reopen_log;
		player::init;
		race::init;
		ball::new;
		plus::new;
	},

	'updatePrepareRestart'	=> sub {
		sleep(5);
		server::reopen_log;
		player::init;
		race::init;
		ball::new;
		plus::new;
	},

	'serverShutdown'	=> sub {
		server::shutdown;
	},

	'serverHitch'	=> sub {
		my($e)=@_;
		my($lag);

		return if($e->{'changedMap'});
		return if(($e->{'time'}-map::start)<10*$config::Clock);

		$lag=$e->{'duration'}/$config::Clock;
		if($lag > config::option('hitchThreshold')) {
			chat::all(sprintf('Server lag: %.2f seconds', $lag));
		}
	},
);

=head2 Console Interaction and Management

When using the B<alti+server> console, there are commands which are not
available under any other circumstance.  These allow the console access
to data which is otherwise easy to access from the game, or to execute
functions which should not be accessible from elsewhere.  These commands
start with a slash (/) character, just like all other commands.

The size of this list depend on the C<OPTIONS> value for C<superAdmin>.
If C<superAdmin> is set to C<console>, then all super admin functions are
also only available from the console.

=cut

%CONSOLE=(
	'server'			=> sub {
		my($action, $name, @args)=@_;
		my($value)=join(' ', @args);
		my($s)=player::server;
		my($lookup);
		my($current);

		if($name=~m/(superA|a)dmins|moderators/i && $value && $value!~m/^[0-9a-f-]{36}$/) {
			if($lookup=player::lookup($value)) {
				$value=$lookup->{'vaporId'};
			} elsif($lookup=db::psearch($value)) {
				$value=$lookup->{'vaporid'};
			} elsif(($lookup)=altbouncer::lookup($value)) {
				$value=$lookup->{'vaporID'};
			} else {
				chat::whisper($s, 'Could not find a vaporID for', $name);
				return;
			}
		}

		if($action eq 'list') {
			'defer';
		} elsif($action eq 'set') {
			unless(config::option_exists($name)) {
				chat::whisper($s, 'Invalid option name', $name);
				return;
			}

			if($name=~m/Color/i && $value!~m/black|blue|cyan|green|magenta|red|white|yellow/) {
				chat::whisper($s, 'Invalid color:', $value);
				return;
			} elsif($name eq 'ulSizeLimit') {
				if($value=~m/(\d+)g/i) {
					$value=$1*(2**30);
				} elsif($value=~m/(\d+)m/i) {
					$value=$1*(2**20);
				} elsif($value=~m/(\d+)k/i) {
					$value=$1*1024;
				}
			}

			if($name=~m/pass/i) {
				$value=~s/(.)/$1^'_'/ge;
				$value='{xor}'.encode_base64($value);
				chomp($value);
			}

			config::option_set($name, $value);

			ui::setup_screen if($name=~m/^ui|Color$/i);
			if($name=~m/secretCode/) {
				chat::whisper($s, 'run /restartServer to complete change');
			} elsif($name=~m/aceLevel/ && xx::enabled) {
				if(config::option('aceLevel')<config::option('noviceLevel')) {
					xx::config_set('minAce', 0);
					xx::config_set('minLevel', config::option('noviceLevel'));
					xx::config_set('levelRestrictions', 'true');
					xx::config_reload;
				}
			}
		} elsif($action eq 'unset') {
			config::option_del($name);
			chat::whisper($s, $name, 'restored to default');

			ui::setup_screen if($name=~m/^ui|Color$/i);

			if($name=~m/secretCode/) {
				config::write_launcher_config($name => '');
			} elsif($name=~m/aceLevel/ && xx::enabled) {
				xx::config_unset('minAce');
				xx::config_unset('minLevel');
				xx::config_unset('levelRestrictions');
				xx::config_reload;
			}
		} elsif($action eq 'add') {
			unless(config::option_exists($name)) {
				chat::whisper($s, 'Invalid option name', $name);
				return;
			}

			$current=config::option($name);

			unless($current=~m/(^|;)$value(;|$)/) {
				config::option_set($name, join(';', $current, $value));

				if($name=~m/^(admins|moderators)$/) {
					if(defined(xx::config_add($name, $value))) {
						xx::perms_reload;
					}
				}
			}
		} elsif($action eq 'del') {
			$current=config::option($name);
			$current=~s/$value;|;?$value//;
			config::option_set($name, $current);

			if($name=~m/^(admins|moderators)$/) {
				if(defined(xx::config_del($name, $value))) {
					xx::perms_reload;
				}
			}
		} else {
			chat::whisper($s, 'Syntax: /server [list|set|unset] [...]');
			return;
		}

		$current=config::option($name);
		foreach my $entry (split(m/;/, $current)) {
			chat::whisper($s, "$name:", $entry);
		}
	},

	'xx'		=> sub {
		my($action, $name, @args)=@_;
		my($value)=join(' ', @args);
		my($s)=player::server;
		my($current);
		my($lookup);

		if($name=~m/allow|admins|moderators/i && $value && $value!~m/^[0-9a-f-]{36}$/) {
			if($lookup=player::lookup($value)) {
				$value=$lookup->{'vaporId'};
			} elsif($lookup=db::psearch($value)) {
				$value=$lookup->{'vaporid'};
			} elsif(($lookup)=altbouncer::lookup($value)) {
				$value=$lookup->{'vaporID'};
			} else {
				chat::whisper($s, 'Could not find a vaporID for', $name);
				return;
			}
		}

		if($action eq 'list') {
			'defer';
		} elsif($action eq 'set') {
			if($name eq 'acl') {
				xx::acl_set(@args);
			} else {
				if(defined(xx::config_set($name, $value))) {
					xx::config_reload;
				} else {
					chat::whisper($s, 'Invalid object or action:', $name);
					return;
				}
			}
		} elsif($action eq 'unset') {
			if($name eq 'acl') {
				xx::acl_unset(@args);
			} else {
				if(defined(xx::config_unset($name))) {
					xx::config_reload;
				} else {
					chat::whisper($s, 'Invalid object or action:', $name);
					return;
				}
			}
		} elsif($action eq 'add') {
			if(defined(xx::config_add($name, $value))) {
				if($name=~m/admins|moderators/i) {
					xx::perms_reload;
				} else {
					xx::config_reload;
				}
			} else {
				chat::whisper($s, 'Invalid object or action:', $name);
				return;
			}
		} elsif($action eq 'del') {
			if(defined(xx::config_del($name, $value))) {
				if($name=~m/admins|moderators/i) {
					xx::perms_reload;
				} else {
					xx::config_reload;
				}
			} else {
				chat::whisper($s, 'Invalid object or action:', $name);
				return;
			}
		} else {
			chat::whisper($s, 'Syntax: /xx [list|set|unset|add|del] [...]');
			return;
		}

		$current=xx::config($name);
		if(!defined($current)) {
			chat::whisper($s, "$name not defined, default bahavior applies");
		} elsif(ref($current) eq 'ARRAY') {
			chat::whisper($s, "$name:", @$current);
		} elsif(ref($current) eq 'HASH' && ref($current->{$args[0]}) eq 'ARRAY') {
			chat::whisper($s, "$args[0]:", @{$current->{$args[0]}});
		} elsif(ref($current) eq 'HASH') {
			if(@args) {
				if(exists($current->{$args[0]})) {
					chat::whisper($s, "$args[0]:", $current->{$args[0]});
				} elsif($name=~m/acl/i) {
					chat::whisper($s, "$args[0]: fallback");
				} else {
					chat::whisper($s, "$args[0]: unset");
				}
			} else {
				chat::whisper($s, "$name:", grep(!m/test[DEH]M/, keys(%$current)));
			}
		} else {
			chat::whisper($s, "$name:", $current);
		}
	},

	'script'		=> sub {
		my($action, $name)=@_;

		if($action=~m/^li/i) {
			script::list;
		} elsif($action=~m/^rel/i) {
			script::install;
		} elsif($action=~m/^rem|^del/i) {
			script::remove($name);
		}
	},

	'command'		=> sub {
		my($action, $name)=@_;
		my($s)=player::server;
		my($cols)=int($ui::Cols/18);
		my(@cmds);

		if($action eq 'list') {
			'defer';
		} elsif($action eq 'enable') {
			unless(config::custom_command_set($name, 1)) {
				chat::whisper($s, 'Invalid command name', $name);
				return;
			}
		} elsif($action eq 'disable') {
			unless(config::custom_command_set($name, 0)) {
				chat::whisper($s, 'Invalid command name', $name);
				return;
			}
		} elsif($action eq 'unset') {
			if(config::custom_command_unset($name)) {
				chat::whisper($s, $name, 'restored to default');
			} else {
				chat::whisper($s, 'Invalid command name', $name);
				return;
			}
		} else {
			chat::whisper($s, 'Syntax: /command [list|enable|disable|unset] [...]');
			return;
		}

		if($name=~m/all/i) {
			@cmds=config::custom_commands;
			while(@cmds) {
				chat::whisper($s, map(
					sprintf("%15s:%d", $_, config::custom_command($_)),
					splice(@cmds, 0, $cols)
				));
			}
		} else {
			chat::whisper($s, "$name:", config::custom_command($name));
		}
	},

	'importDefaults'	=> sub {
		my($prefix)='';
		
		$prefix='! ' if(config::custom_command('!'));

		foreach my $command (plus::import_defaults) {
			server::send($prefix, server::parse_cmd($command));
		}
		stash::delete('INIT', map::name, 'map');
	},

	'stashDisplay'		=> sub {
		my($map)=@_;
		my($stash)=stash::get($map, 'map');
		my($s)=player::server;

		if(ref($stash) eq 'HASH') {
			chat::whisper($s, '{ "'.$map.'"', ':', json::encode($stash), '}');
		} else {
			chat::whisper($s, "Usage: /stashDisplay <map>");
		}
	},

	'stashClearSettings'	=> sub {
		my($map)=@_;
		my($stash)=stash::get($map, 'map');
		my($s)=player::server;

		if(ref($stash) eq 'HASH') {
			foreach my $key (keys(%$stash)) {
				chat::whisper($s, "Delete: $map.$key");
				stash::delete($key, $map, 'map');
			}
		} else {
			chat::whisper($s, "Usage: /stashClearSettings <map>");
		}
	},

	'stashClearRecords'	=> sub {
		my($map)=@_;
		my($s)=player::server;

		if(stash::delete($map, 'records')) {
			chat::whisper($s, "Records cleared for $map");
		} else {
			chat::whisper($s, "No records found for $map");
		}
	},

	'updateNames'		=> sub {
		queue::background { planeball::update } 0;
	},

	'setPlayerName'	=> sub {
		my($search, $name)=@_;
		my($player)=db::psearch($search);
		my($lookup)=player::lookup($player->{'vaporid'});

		if($player) {
			db::update('player', qq{vaporid='$player->{"vaporid"}'}, {
					'name'	=> $name
				});

			$lookup->{'name'}=$name if(ref($lookup));

			ui::slog("Updated $player->{'vaporid'} ($player->{'nickname'}) to $name");
		} else {
			ui::slog("No updates performed, '$search' not found.");
		}
	},

	'linkAccounts'		=> sub {
		my($p1)=db::psearch($_[0]);
		my($p2)=db::psearch($_[1]);
		my($s)=player::server;
		my(@g1, @g2)=();
		my(@linked)=();

		if($p1->{'id'}==$p2->{'id'} && $p1->{'name'} eq $p2->{'name'}) {
			chat::whisper($s, 'The accounts are already linked');
			return;
		}

		if($p1->{'name'} && !$p2->{'name'}) {
			db::update('player', qq{vaporid='$p2->{"vaporid"}'}, {
				'id'       => $p1->{'id'},
				'name'     => $p1->{'name'},
			});
			@linked=map($_->{'nickname'}, $p1, $p2);
		} elsif(!$p1->{'name'} && $p2->{'name'}) {
			db::update('player', qq{vaporid='$p1->{"vaporid"}'}, {
				'id'       => $p2->{'id'},
				'name'     => $p2->{'name'},
			});
			@linked=map($_->{'nickname'}, $p1, $p2);
		} else {
			@g1=db::select('player', qq{ id=$p1->{'id'} });
			@g2=db::select('player', qq{ id=$p2->{'id'} });

			if(@g1<@g2) {
				db::update('player', qq{ id=$p1->{'id'} }, {
					'id'       => $p2->{'id'},
					'name'     => $p2->{'name'},
				});
			} else {
				db::update('player', qq{ id=$p2->{'id'} }, {
					'id'       => $p1->{'id'},
					'name'     => $p1->{'name'},
				});
			}
			@linked=map($_->{'nickname'}, @g1, @g2);
		}

		ui::slog('Linked:', join(', ', @linked));
	},

	'showAdmins'		=> sub {
		my($admins)=config::option('admins');
		my($s)=player::server;
		my($player);

		if(db::enabled) {
			foreach my $admin (split(m/;/, $admins)) {
				$player=db::psearch($admin);
				chat::whisper($s, $admin, 
					$player->{'name'} || $player->{'nickname'});
			}
		} else {
			foreach my $admin (split(m/;/, $admins)) {
				chat::whisper($s, $admin);
			}
		}
	},

	'showModerators'	=> sub {
		my($mods)=config::option('moderators');
		my($s)=player::server;
		my($player);

		if(db::enabled) {
			foreach my $mod (split(m/;/, $mods)) {
				$player=db::psearch($mod);
				chat::whisper($s, $mod, 
					$player->{'name'} || $player->{'nickname'});
			}
		} else {
			foreach my $mod (split(m/;/, $mods)) {
				chat::whisper($s, $mod);
			}
		}
	},

	'playerSearch'		=> sub {
		my($s)=player::server;
		my($location);
		
		if(db::enabled) {
			foreach my $p (db::psearch(@_)) {
				if($p->{'ip'}) {
					$location=sprintf('%s(%s)',
						$p->{'ip'}, utils::geoip($p->{'ip'}));
				} else {
					$location='';
				}
				chat::whisperf($s, '%36s  %-5d  %s',
					$p->{'vaporid'},
					$p->{'id'},
					$p->{'name'},
				);
				chat::whisperf($s, '%36s  %-25s %s',
					$location,
					$p->{'nickname'},
					utils::date($p->{'seen'}),
				);
			}
		} else {
			chat::whisper($s, 'This function requires a database backend.');
		}
	},

	'showPlayer'		=> sub {
		my($s)=player::server;
		my($p)=player::lookup(@_);
		my(@keys)=qw(
			vaporId
			id
			player
			team
			alive
			infractions
			ping
			ip
			country
		);
		my($name)=$p->{'nickname'};

		$name.=" ($p->{'name'})" if($p->{'name'});

		chat::whisper($s, $name, ':');
		chat::whisper($s, '  joined:',
			scalar(localtime($server::Start + $p->{'time'}/$config::Clock)));
		chat::whisper($s, '  level ace:', $p->{'level'}, $p->{'aceRank'});
		foreach my $key (@keys) {
			chat::whisper($s, "  $key:", $p->{$key});
		}

		chat::whisper($s, "  $p->{'plane'}:",
			"$p->{'perkRed'},",
			"$p->{'perkGreen'},",
			"$p->{'perkBlue'},",
			"$p->{'skin'}",
		) if(exists($p->{'plane'}));

	},

	'showTeams'		=> sub {
		my($s)=player::server;
		my($left, $right)=(map::team_color('left'), map::team_color('right'));
		my(@list);

		chat::whisper($s, map::name);

		@list=();
		foreach my $player (player::list('left')) {
			if($player->{'alive'}) {
				push(@list, $player->{'nickname'});
			} else {
				push(@list, '('.$player->{'nickname'}.')');
			}
		}
		chat::whisperf($s, '%-16s: %s', "left  ($left)", join(', ', @list));

		@list=();
		foreach my $player (player::list('right')) {
			if($player->{'alive'}) {
				push(@list, $player->{'nickname'});
			} else {
				push(@list, '('.$player->{'nickname'}.')');
			}
		}
		chat::whisperf($s, '%-16s: %s', "right ($right)", join(', ', @list));

		chat::whisperf($s, '%-16s: %s', 'spec',
			join(', ', map($_->{'nickname'}, player::list('spec'))));
	},

	'showSeen'		=> sub {
		my($s)=player::server;
		my($found)=0;

		foreach my $player (reverse(altbouncer::seen)) {
			chat::whisperf($s, '%-20s  %36s  %s',
					$player->{'nickname'},
					$player->{'vaporID'},
					utils::date($player->{'lastPlayedWithTime'}/1000),
				);
			$found=1;
		}

		chat::whisper($s, 'seen list is empty') unless($found);
	},

	'showRecent'		=> sub {
		my($s)=player::server;
		my($found)=0;
		my($name);

		unless(db::enabled) {
			chat::whisper($s, 'Requires server to have a database backend');
			return;
		}

		foreach my $player (reverse(db::recent)) {
			if($player->{'name'} && $player->{'name'} ne $player->{'nickname'}) {
				$name="$player->{'name'} ($player->{'nickname'})";
			} else {
				$name=$player->{'nickname'};
			}
			chat::whisperf($s, '%-23s  %36s  %s',
					$name,
					$player->{'vaporid'},
					utils::date($player->{'seen'}),
				);
			$found=1;
		}

		chat::whisper($s, 'seen list is empty') unless($found);
	},

	'showRatings'		=> sub {
		my($type)=@_;
		my($s)=player::server;
		my($ratings)=db::query(qq{
			SELECT DISTINCT
				rank.id,rating,differential,name,nickname
			FROM rank,player
			WHERE player.id=rank.id AND rank.type='$type'
			ORDER BY rank.rating,rank.differential
		});

		chat::whisperf($s, '%5s %6s %6s  %s',qw(ID RATING DIFF NAME));

		foreach my $row (@$ratings) {
			chat::whisperf($s, '%5d %6d %+6.1f  %s',
				@$row[0,1,2],
				$row->[3] || $row->[4]
			);
		}
	},

	'showPowerups'		=> sub {
		my($s)=player::server;
		my($coords, @types);

		foreach my $pickup (map::powerups) {
			($coords, @types)=@$pickup;
			chat::whisper($s, $coords, ':', join(', ', @types));
		}
	},

	'chatLeft'		=> sub {
		chat::team('left', @_);
	},

	'chatRight'		=> sub {
		chat::team('right', @_);
	},

	'chatSpec'		=> sub {
		chat::team('spec', @_);
	},

	'shutdown'		=> sub {
		altbouncer::upload;
		server::shutdown;
		db::shutdown;
		ui::shutdown;
		exit(0);
	},
);

=head2 Errors and Signals

If the B<alti+server> code recognizes a failure or if it receives a signal
to exit, it ensures the Altitude game engine is shut down first, then
exits.  Any warnings (which would be produced from using deprecated functions)
are sent to the server log (top) window of the user interface.

=cut

local(%SIG)=(
	'__WARN__'	=> sub {
		ui::slog(@_);
	},
	'__DIE__'		=> sub {
		server::shutdown;
		db::shutdown;
		ui::shutdown;
		print @_, "\n";
		exit(1);
	},
	'HUP'		=> $CONSOLE{'shutdown'},
	'TERM'		=> $CONSOLE{'shutdown'},
	'INT'		=> $CONSOLE{'shutdown'},
);

=head2 Operation

The Altitude game engine will be invoked by B<alti+server> and will also be
closed by B<alti+server>.  If an error occurs with the server, B<alti+server>
will attempt to restart the server.  All managment of the Altitude game engine
should be performed from within B<alti+server> to ensure it has proper
knowledge of ports, players, log files, standard output, etc.

=cut

my($REQ, $SOUT, $TRIGGER, @EVENT);

ui::setup_screen;

db::init;
db::upgrade;

stash::upgrade;

config::launcher;

if(config::option('updateMapList')) {
	config::find_maps;
} else {
	config::read_maps;
}

if(config::lobby) {
	stash::set('nextMap', 'admin', config::lobby);
}

config::write_launcher_config;

server::start;

script::install;

while(1) {
	foreach my $fh (server::data(queue::next)) {
		if(server::is_log($fh)) {
			next unless($REQ=server::event);
		
			@EVENT=&event($REQ);

			script::pre(@EVENT);
			if($TRIGGER=server::triggers($REQ->{'type'})) {
				my($trigger)=shift(@$TRIGGER);
				$HOOKS{$trigger}->(@EVENT, @$TRIGGER);
			}

			if(exists($HOOKS{$REQ->{'type'}})) {
				$HOOKS{$REQ->{'type'}}->(@EVENT);
			} elsif(exists($HOOKS{$REQ->{'command'}})) {
				$HOOKS{$REQ->{'command'}}->(@EVENT);
			}
			script::post(@EVENT);
		} elsif(server::is_output($fh)) {
			$SOUT=server::output;

			if($SOUT=~m/Starting server on port $config::Port/) {
				server::reopen_log;
			} elsif($SOUT=~m/Changing map: (.*)/) {
				dlfmhs::change_map($1);
			} elsif($SOUT=~m/DLFMHS caching file data for (.*)\.altx/) {
				dlfmhs::prepare($1);
			} elsif($SOUT=~m/Got initiate download request from ([\d.:]+)/) {
				dlfmhs::request($1);
			} elsif($SOUT=~m/DLFMHS sending send-complete to ([\d.:]+)/) {
				dlfmhs::complete($1);
			} elsif($SOUT=~m/Removing client '.*?' from ([\d.:]+)/) {
				dlfmhs::remove($1);
			} elsif($SOUT=~m/DLFMHS releasing file data for (.*)\.altx/) {
				dlfmhs::release($1);
			} elsif($SOUT=~m/BindException: Address already in use/) {
				ui::slog('Another instance is already running');

				server::interrupt;
				server::shutdown;
				db::shutdown;
				ui::shutdown;
				exit(1);
			} elsif($SOUT=~m/Error processing packet .*, playerId=(\d+)/) {
				player::infraction(player::lookup($1), 1);
			} elsif($SOUT=~m/$FATAL_SERVER_ERRORS/) {
				ui::slog($SOUT);
				ui::slog(server::flush);

				server::interrupt;
				server::shutdown;

				if($SOUT=~m/config size \((\d+) bytes/) {
					config::resize($1);

					sleep(2);

					if(config::option('updateMapList')) {
						config::find_maps;
					} else {
						db::shutdown;
						ui::shutdown;
						print "Config size too big, remove maps from mapList\n";
						exit(1);
					}
				}

				ui::save_log;
				server::save_log;

				config::write_launcher_config;

				server::start;
				server::reopen_log;
				ui::setup_screen;

				player::init;
				race::init;
				ball::new;
				plus::new;
			} elsif($SOUT=~m/Failed to contact .+ via local UDP port/) {
				queue::schedule {
					utils::ping(config::option('updateServer'))
				} 240;
			} elsif($SOUT=~m/Data Transfer Since Launch/) {
				server::check_tail;
	
				ui::slog('INFO  : alti+server uptime:',
					server::uptime, ', altitude time:', 
					POSIX::strftime("%Y%m%dT%H%M%S", gmtime(time()))
				);

				ui::slog('INFO  : CPU Totals (user system):',
					server::cpu_hrs);

				if(player::none) {
					if(
						map::idle > config::option('timeIdleChange') ||
						map::cpu  > config::option('cpuUsedChange')
					) {
						if(config::lobby) {
							unless(map::name eq config::lobby) {
								server::send('changeMap', config::lobby);
							}
						} else {
							server::send('changeMap', config::random_map);
						}
						map::end;
					}

					if(altbouncer::count > 100) {
						queue::background { altbouncer::upload } 0;
						altbouncer::clear;
					}
				}
			}

			$SOUT=~s/Executing:.*?data=/Executing: /;

			ui::slog($SOUT);
		} elsif($fh==0xDEAD) {
			ui::slog('!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!');
			ui::slog('!!   Server is dead, restarting   !!');
			ui::slog('!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!');

			server::interrupt;

			sleep(2);

			server::start;
			server::reopen_log;
			player::init;
			race::init;
			ball::new;
			plus::new;
		} else {
			input::stdin;
		}
	}

	queue::execute;
}

END {
	unless($queue::Child) {
		server::shutdown;
		db::shutdown;
		ui::shutdown;
		exit(0);
	}
}

=head1 NOTES

The B<alti+server> program is an interactive server manager, which is not
convenient for running on a headless system or (for example) VPS.  It is
recommended that B<alti+server> be run in a detachable terminal emulator
to allow it to continue to function during a disconnect.  The author prefers
screen, but tmux and dtach would both work just as well.  It is a good idea
to name the detatched session if you run multiple already, so it is easy to
re-attach to.

=head1 AUTHOR

biell @ pobox . com 

=head1 PUBLIC DOMAIN NOTICE

This is free and unencumbered software released into the public domain.

Anyone is free to copy, modify, publish, use, compile, sell, or
distribute this software, either in source code form or as a compiled
binary, for any purpose, commercial or non-commercial, and by any
means.

In jurisdictions that recognize copyright laws, the author or authors
of this software dedicate any and all copyright interest in the
software to the public domain. We make this dedication for the benefit
of the public at large and to the detriment of our heirs and
successors. We intend this dedication to be an overt act of
relinquishment in perpetuity of all present and future rights to this
software under copyright law.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.

For more information, please refer to <http://unlicense.org/>

=cut

