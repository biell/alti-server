#!/usr/bin/perl

#use strict;

my($VERSION)='1.28';

=head1 NAME

alti+server - Altitude server designed to support extended game types

=cut

my($INSTALL_ROOT)=$ENV{'ALTITUDE_ROOT'} || "$ENV{'HOME'}/altitude";

#$MAPDIR moved to 'mapDir' in OPTIONS just below.  Now, you can use
#"/server set mapDir ..." to have this option persist across upgrades!
#Set mapDir the first time you upgrade to this version, then it will be stored
#in your json stash, you won't ever have to set it here again.

my(%OPTIONS)=(
	mapDir		=> '',			#Directory under $INSTALL_ROOT/maps
								#to store maps. (e.g. "download")
	lobby		=> '',			#Lobby map for this server
	updateMapList	=> 1,               #Let alti+server change the mapList
	enableTalk	=> 0,			#Enable server aided direct player chat
	changePlane	=> 1,			#Default changePlane value
	hitchThreshold	=> 0.6,			#Length of serverHitch to report
	timeIdleChange	=> 7200,			#changeMap when server is idle for 2hrs
	cpuUsedChange	=> 300,			#changeMap idle servers at 5min CPU used
	allowUploads	=> 1,			#Allow superAdmins to upload maps
	ulSizeLimit	=> 10485760,        #Max allowed download size
	altBouncer	=> 0,			#Upload users to AltBouncer, 0=no/1=yes
	boxColor		=> 'blue',          #Curses color palet:
	chatFromColor	=> 'cyan',          # black, blue, cyan, green,
	chatToColor	=> 'yellow',        # magenta, red, white, yellow
	uiPrettyBoxes	=> 0,               #0='|','-'; 1=ACS/Unicode prettiness
	noviceLevel	=> 8,               #Require level 8 for Ace 0 to play
	aceLevel		=> 3,               #Require level 3 for Ace 1-10 to play
	snarkChance	=> 16,              #per player 1 in snarkChance, 0 disables
	bullyKick		=> 1,               #Kick repeated aggressive language
	infractions	=> 10,			#10 infractions gets players kicked
	debug		=> 0,			#Debug is on(1) or off(0)
	awards		=> 1,			#Give out awards at the end of a round
	recordsTypes	=> 'coop,race',     #Which map types to keep records on
	rotationRE	=> 'tbd|ball|tdm',  #Which maps go into rotation
	configSize	=> 'normal',		#How helpful are extended commands:
								# normal: all commands and help
								# small: all commands, but no help
								# tiny: only required, admin merged
	superAdmin	=> 'admin',		#Super Admin command access:
	                                   # admin: all admins are super admins
								# console: cmds typed at console only
								# list: vaporId from @superAdmins array:
	admins		=> join(';',
			'00000000-0000-0000-0000-000000000000',
		),
	superAdmins	=> join(';',
			'00000000-0000-0000-0000-000000000000',
		),
	motd			=> join(';', 
			'See https://github.com/biell/alti-server for server manual',
		),
);

=head1 DESCRIPTION

The B<alti+server> server script is a perl wrapper around the Altitude
game server engine.  Altitude provides facilities for server hosting
integration for providing custom features and extensions.  

B<alti+server> has one major limitation which is integral to it's design,
and so will not be fixed.  It is designed to run only one server at a time.
An Altitude game server is capable of running multiple engines simultaneously
with a single set of log and command files.  This allows for a more efficient
use of resources, as one java process can run each engine.  If you try to
run multiple simultaneous game engines, B<alti+server> will fail
misserably, don't bother trying.

Beyond adding extra commands for users and map makers, B<alti+server> also
makes management of the server easier.  For example, console errors are
caught, and result in a server restart, allowing the server to maintain a
higher uptime.  Also, B<alti+server> creates a multi-paned curses interface
which allows management of the server to be easier.

=cut

use POSIX;
use IO::Handle;
use IPC::Open3;
use List::Util;
use Data::Dumper;

my($FATAL_SERVER_ERRORS)=join('|',
	'Server config size \(\d+ bytes\) exceeds max allowed size',
	'No suitable Java Virtual Machine could be found',
	'no available nuons!',
	'ERROR : serverLoop disrupted',
);

my(%HOOKS, %CONSOLE);

=head2 Interface

There are three panes to the B<alti+server> interface:

=over 8

=item top

The top pane contains output from the Altitude server engine and additional
logs from B<alti+server> itself.  This data should scroll in such a way
that the scroll-back buffer on your terminal emulator.  Interestingly,
xterm and urxvt tend to hold only this buffer in their scrollback, whereas
screen tends to hold scrolled data from the middle pane also.  This pane
is used to keep track of what is going on with the server.

=item middle

The middle pane is a boxed window.  Inside of it are all chat and
serverMessage entries on the game.  Messages start with the originating user,
then a code for the destination, then the message itself.  The codes are as
such: (*) all user chat, (<) left team chat, (>) right team chat,
(?) spectator team chat, and the nickname of the receipient for direct
communication.

=item bottom

The bottom pane is a small one line box.  It works much the same as the
in-game all-chat box.  Text typed into it will appear as a server message
to players.  If the text starts with a slash (/) character, then it is
assumed to be a server command.  Server commands have a limited tab
completion.

=back

If your terminal supports color, colors will be used to make certain aspects
stand out or fade away.  Specifically, the boxes around windows are dark
blue, Nicks (in chat window) are cyan, and destination specifier (in chat
window) is dark yellow/amber.

=cut

delete($ENV{'LINES'});
delete($ENV{'COLUMNS'});

{	package ui;

	use Curses;
	use Term::ReadKey;

	initscr();

	my($Outfile)	="$INSTALL_ROOT/servers/stdout.txt";
	my($Outfile_o)	="$INSTALL_ROOT/servers/stdout_old.txt";
	my($Chatfile)	="$INSTALL_ROOT/servers/chat.txt";
	my($Chatfile_o)="$INSTALL_ROOT/servers/chat_old.txt";

	my($Cols, $Rows, $Px, $Py)=GetTerminalSize;
	my($Sline, $Iline)=($Rows/2-1, $Rows-3);
	my($Iputw)=$Cols-6;

	my($Swin)=newwin($Sline,   $Cols,   0,        0 );
	my($Cwin)=newwin($Sline-1, $Cols-2, $Sline,   1 );
	my($Iwin)=newwin(3,        $Cols-4, $Iline,   2 );
	my($Chat)=newwin($Sline-3, $Cols-4, $Sline+1, 2 );
	my($Iput)=newwin(1,        $Iputw,  $Iline+1, 3 );
	
	sub adjust_win {
		my($win, $height, $width, $y, $x)=@_;

		$win->resize($height, $width);
		$win->move($y, $x);
		$win->redrawwin();
		$win->refresh();
	}

	sub setup_screen {
		my($default)=-1;
		my($boxColor)='COLOR_'.uc(config::option('boxColor'));
		my($chatFromColor)='COLOR_'.uc(config::option('chatFromColor'));
		my($chatToColor)='COLOR_'.uc(config::option('chatToColor'));

		#Make sure size is right:
		($Cols, $Rows, $Px, $Py)=GetTerminalSize;
		($Sline, $Iline)=($Rows/2-1, $Rows-3);
		($Iputw)=$Cols-6;
		&adjust_win($Swin, $Sline,   $Cols,   0,        0 );
		&adjust_win($Cwin, $Sline-1, $Cols-2, $Sline,   1 );
		&adjust_win($Iwin, 3,        $Cols-4, $Iline,   2 );
		&adjust_win($Chat, $Sline-3, $Cols-4, $Sline+1, 2 );
		&adjust_win($Iput, 1,        $Iputw,  $Iline+1, 3 );

		start_color();
		use_default_colors();
		if(has_colors()) {
			init_pair(1, eval($boxColor),		$default);
			init_pair(2, eval($chatFromColor),	$default);
			init_pair(3, eval($chatToColor),	$default);
		} else {
			init_pair(1, $default, $default);
			init_pair(2, $default, $default);
			init_pair(3, $default, $default);
		}

		stdscr->clear();
		stdscr->refresh();

		$Swin->scrollok(1);
		$Chat->scrollok(1);

		$Swin->redrawwin();
		$Cwin->redrawwin();
		$Chat->redrawwin();
		$Iwin->redrawwin();
		$Iput->redrawwin();

		$Cwin->attron(COLOR_PAIR(1));
		$Iwin->attron(COLOR_PAIR(1));
		if(config::option('uiPrettyBoxes')) {
			$Cwin->box(0, 0);
			$Iwin->box(0, 0);
		} else {
			$Cwin->border('|', '|', '-', '-', ' ', ' ', ' ', ' ');
			$Iwin->border('|', '|', '-', '-', ' ', ' ', ' ', ' ');
		}
		$Cwin->attroff(COLOR_PAIR(1));
		$Iwin->attroff(COLOR_PAIR(1));

		curs_set(0);
		$Swin->leaveok(1);
		$Cwin->leaveok(1);

		noecho();
		cbreak();
		keypad(1);

		$Swin->refresh();
		$Cwin->refresh();
		$Chat->refresh();
		$Iwin->refresh();
		$Iput->refresh();
	}

	sub slog {
		my($slog)=IO::Handle->new;
		my($entry)=join(' ', @_);

		chomp($entry);

		return unless($entry);

		rename($Outfile, $Outfile_o) if(-s $Outfile > 1048576);

		open($slog, '>>', $Outfile);
		print $slog $entry, "\n";
		close($slog);

		$Swin->scrl(1);
		$Swin->addstr($Sline-1, 0, $entry);
		$Swin->refresh();
	}

	sub display {
		my($pre, $type, $text)=@_;
		my($offset1)=length($pre)+1;
		my($offset2)=length($type)+$offset1+1;

		$Chat->scrl(1);
		if($pre) {
			$Chat->attron(COLOR_PAIR(2));
			$Chat->addstr($Sline-4, 0, $pre);
			$Chat->attroff(COLOR_PAIR(2));

			$Chat->attron(COLOR_PAIR(3));
			$Chat->addstr($Sline-4, $offset1, $type);
			$Chat->attroff(COLOR_PAIR(3));

			$Chat->addstr($Sline-4, $offset2, $text);
		} else {
			$Chat->addstr($Sline-4, 0, $text);
		}
		$Chat->refresh();
	}

	sub chat_log {
		my($type, $nick, $msg)=@_;
		my($clog)=IO::Handle->new;
		my($time)=POSIX::strftime("%Y%m%dT%H%M%S", localtime(time()));

		rename($Chatfile, $Chatfile_o) if(-s $Chatfile > 1048576);

		open($clog, '>>', $Chatfile);
		printf($clog "[%s:%-16s:%s] %s\n", $time, $nick, $type, $msg);
		close($clog);

		&display($nick, $type, $msg);
	}

	sub update_input {
		my($msg)=@_;

		$Iput->addstr(0, 0, sprintf("%-${Iputw}s", substr($msg, -$Iputw)));
		$Iput->refresh();
		$Iput->attroff(A_REVERSE());
	}

	sub flash {
		$Iput->attron(A_REVERSE());
	}

	sub shutdown {
		stdscr->move($Rows, $Cols);
		endwin;
		print "\n";
	}

	sub keypress {
		my($input)=getch();
		my($ord)=ord($input);
		
		if($input == KEY_RESIZE) {
			&slog('resize'); #Not working
			&setup_screen;
			return();
		} elsif($input eq "\014") {
			&setup_screen;
			return();
		} elsif($input == KEY_UP) {
			return('up');
		} elsif($input == KEY_DOWN) {
			return('down');
		} elsif($input == KEY_LEFT) {
			return('left');
		} elsif($input == KEY_RIGHT) {
			return('right');
		} elsif($input == KEY_PPAGE) {
			return('prev');
		} elsif($input == KEY_NPAGE) {
			return('next');
		} elsif($input == KEY_BACKSPACE || $ord==127) {
			return('bs');
		} elsif($input eq "\025") {
			return('clear');
		} elsif($input eq "\t") {
			return('tab');
		} elsif($input eq "\n") {
			return('enter');
		} else {
			return($input);
		}
	}
}

=head2 Input and Interaction

Standard keyboard input is availble in the bottom window of the B<alti+server>
interface.  Lines which start with a slash (/) character are assumed to be
commands, and are interpeted as such.  Commands allow for tab expansion.
Commands which require a map as an argument also allow for the expansion of
the map name.  Additionally, a history buffer of the last 50 commands is saved
for easy retrieval;  use the up and down arrow keys to access the history
list.

=cut

{	package input;

	my(@Hist)=();
	my(@Clist)=();

	my($Hindex)=-1;
	my($Eindex)=0;

	my($Input);

	sub hist_up {
		$Hindex++ if($Hindex<$#Hist);
		return($Hist[$Hindex]);
	}

	sub hist_down {
		if($Hindex>0) {
			$Hindex--;
			return($Hist[$Hindex]);
		} else {
			$Hindex=-1;
			return('');
		}
	}

	sub hist_push {
		my($line)=@_;
		unshift(@Hist, '/'.$line);
		pop(@Hist) if(@Hist>50);
		$Hindex=-1;
	}

	sub common_prefix {
		my($len, $prefix, $newtry);

		List::Util::reduce {
			$len=List::Util::min(length($a), length($b));
			$prefix=substr($a, 0, $len);
			$newtry=substr($b, 0, $len);

			while($prefix ne $newtry) {
				chop($prefix);
				chop($newtry);
			}

			return($prefix);
		} @_;
	}

	sub expand_clear {
		my($entry)=@Clist[0];
		@Clist=();
		return($entry);
	}

	sub expand_args {
		my(@cmd)=@_;
		my(@args)=config::arguments($cmd[0]);
		my($arg)=$#cmd-1;
		my($str)=pop(@cmd);
		my($prefix);

		return('/'.join(' ', @cmd, $str)) unless(@args);

		if(@Clist==1) {
			ui::flash;
			return('/'.join(' ', @cmd, &expand_clear));
		} elsif(@Clist) {
			$Eindex=($Eindex+1)%@Clist;
			return('/'.join(' ', @cmd, $Clist[$Eindex]));
		} else {
			$str=~s/^"//;
			if(ref($args[$arg]) eq 'ARRAY') {
				@Clist=grep(m|^\Q$str|i, @{$args[$arg]});
			} elsif($args[$arg] eq 'map') {
				@Clist=grep(m|^\Q$str|i, config::maps());
			} elsif($args[$arg] eq 'player') {
				@Clist=grep(m|^\Q$str|i, player::values('nickname'));
			} elsif($args[$arg] eq 'vaporId') {
				@Clist=grep(m|^\Q$str|i, player::values('vaporId'));
			} else {
				return('/'.join(' ', @cmd, $str).'  ');
			}

			$Eindex=0;
			$prefix=&common_prefix(@Clist);

			foreach(@Clist) {
				if(m/\s/) {
					s/^/"/;
					s/$/"/;
				}
			}

			if(!@Clist) {
				ui::flash();
				return('/'.join(' ', @cmd, $str));
			} elsif($str ne $prefix) {
				@Clist=();
				$prefix=~s/^/"/ if($prefix=~m/\s/);
				return('/'.join(' ', @cmd, $prefix));
			} else {
				ui::slog('Choices:', @Clist) if(@Clist>1);
				return('/'.join(' ', @cmd, $Clist[0]));
			}
		}
	}

	sub expand_command {
		my($str)=@_;
		my($prefix);

		if(@Clist==1) {
			ui::flash();
			return('/'.&expand_clear);
		} elsif(@Clist) {
			$Eindex=($Eindex+1)%@Clist;
			return('/'.$Clist[$Eindex]);
		} else {
			@Clist=config::commands($str);
			$Eindex=0;
			$prefix=&common_prefix(@Clist);

			if(!@Clist) {
				ui::flash();
				return('/'.$str);
			} elsif($str ne $prefix) {
				@Clist=();
				return('/'.$prefix);
			} else {
				ui::slog('Cmds:', @Clist) if(@Clist>1);
				return('/'.$Clist[0]);
			}
		}
	}

	sub stdin {
		my($key)=ui::keypress;
		my(@cmd);

		if($key eq 'up') {
			$Input=&hist_up;
		} elsif($key eq 'down') {
			$Input=&hist_down;
		} elsif($key eq 'bs') {
			$Input=~s/.$//;
		} elsif($key eq 'clear') {
			$Input='';
		} elsif($key eq 'tab') {
			if($Input=~s|^\s*/||) {
				@cmd=($Input=~m/(".*?"|".*$|\w+)/g);
				if(@cmd==1) {
					$Input=&expand_command(@cmd);
				} else {
					$Input=&expand_args(@cmd);
				}
			} else {
				$Input.='  ';
			}
		} elsif($key eq ' ') {
			if($Input=~m|^\s*/(\S+)$|) {
				config::command_help(player::server(), $1);
			}
			$Input.=' ';
		} elsif($key eq 'enter') {
			$Input=~s|^\s+||;

			if($Input=~s|^/||) {
				@cmd=($Input=~m/(".*?"|".*$|\S+)/g);
				foreach(@cmd) {
					s/^"//;
					s/"$//;
				}

				&hist_push($Input);

				if(exists($CONSOLE{$cmd[0]})) {
					$CONSOLE{$cmd[0]}->(splice(@cmd, 1));
				} else {
					server::send($Input);
				}

				$Input='';
			} else {
				chat::all($Input);
				$Input='';
			}
		} else {
			$Input.=$key;
		}

		&expand_clear if($key ne 'tab');

		ui::update_input($Input);
	}
}

=head2 Server Notes

B<alti+server> is designed to run on Linux, but may also run on other
UNIX like operating systems.  It is likely that it could be modified
to run on non UNIX like systems, if necessary.  A recent version of
L<perl(1)> should be used to ensure basic operation.

=cut

{	package utils;

	use Digest::SHA;

	my(@Path)=(
		split(m/:+/, $ENV{'PATH'}),
		qw(/usr/bin /bin /usr/sbin /sbin /usr/local/bin /opt/bin),
		"$ENV{'HOME'}/bin",
	);

	my($Ticks)=POSIX::sysconf(&POSIX::_SC_CLK_TCK);

	my($Geoip);

	sub which {
		my($prog, $feeling, $failing)=@_;
		my(%checked)=();
		my($bin);

		foreach my $dir (@Path) {
			next if($checked{$dir}++);

			$bin="$dir/$prog";
			if(-x $bin) {
				if($feeling) {
					ui::slog('Using', $bin, "($feeling)");
				} else {
					ui::slog('Using', $bin);
				}
				return($bin);
			}
		}

		if($failing) {
			ui::slog($prog, 'not found,', $failing);
		} else {
			ui::slog($prog, 'not found');
		}

		return(undef);
	}

	$Geoip=&which('geoiplookup', 'good', 'Country lookups not available');

	sub minmax {
		my($pair);
		
		return(undef, undef) unless(@_);

		List::Util::reduce {
			$pair=(ref($a) eq 'ARRAY')?$a:[$a, $a];
			$pair->[0]=$b if($pair->[0]>$b);
			$pair->[1]=$b if($pair->[1]<$b);

			return($pair);
		} @_;

		return(@$pair);
	}

	sub uniq {
		my(@ary)=sort(@_);

		for(my $i=1; $i<@ary; $i++) {
			if($ary[$i]==$ary[$i-1]) {
				splice(@ary, $i, 1);
				redo;
			}
		}

		return(@ary);
	}

	sub invert {
		my($hash)=@_;
		my($inverted)={};

		if($hash) {
			foreach my $key (keys(%$hash)) {
				push(@{$inverted->{$hash->{$key}}}, $key);
			}
		}

		return($inverted);
	}

	sub geoip {
		my($ip)=@_;
		my($lookup)=IO::Handle->new;
		my($country)=undef;

		if($Geoip) {
			$ip=~s/:.*$//;

			open($lookup, '-|', $Geoip, $ip);
			while(<$lookup>) {
				$country=$1 if(m/,\s+(.*?)\s*$/);
			}
			close($lookup);
		}

		return($country);
	}

	sub distance {
		my($x1, $y1, $x2, $y2)=@_;

		return(sqrt( ($x2-$x1)**2 + ($y2-$y1)**2 ));
	}

	sub direction {
		my($x, $y)=@_;

		return(int(atan2($y, $x)*180/3.14159));
	}

	sub transform {
		my($t, $x, $y)=@_;
		my($a)=$t->{'rotate'};

		$x+=$t->{'translate'}{'x'};
		$x*=$t->{'scale'};

		$y+=$t->{'translate'}{'y'};
		$y*=$t->{'scale'};

		if($t->{'flipX'} eq 'true') {
			if($a<0) {
				$a=-180-$a;
			} else {
				$a=180-$a;
			}
		}

		if($t->{'flipY'} eq 'true') {
			$a*=-1;
		}

		$a*=3.14159/180;	#convert to radians

		return($x*cos($a)-$y*sin($a), $x*sin($a)+$y*cos($a));
	}

	sub random_value {
		my(@values)=values(%{$_[0]});

		return($values[int(rand(@values))]);
	}

	sub uuid {
		my(@seed)=(POSIX::uname(), $$, time(), rand(2**63), rand(2**31));
		my($digest)=Digest::SHA::sha256_hex(@seed);
		my($x)='0'; #not a standard mechanism, mix of 4 and 5
		my($y)=sprintf('%x', 8+rand(4));
		
		$digest=~m/(.{8}).(.{4}).(.{3}).(.{3}).(.{16})/;

		return(join('-', $1, $2, $x.$3, $y.$4, $5));
	}

	sub proc_time {
		my($pid)=@_;
		my($stat)=IO::Handle->new;
		my($file)="/proc/$pid/stat";
		my($user, $sys)=(0, 0);
		my(@proc);

		if(-r $file) {
			open($stat, '<', $file);
			@proc=split(m/\s+/, $stat->getline);
			close($stat);

			$user=$proc[13]+$proc[15];
			$sys=$proc[14]+$proc[16];
		}

		return($user/$Ticks, $sys/$Ticks);
	}

	sub date {
		my($time)=@_;
		my($now)=time();

		if($time>($now-60)) {
			return('now');
		} elsif($time>($now-3600)) {
			return(sprintf('%d minutes ago', ($now-$time)/60));
		} elsif($time>($now-86400)) {
			return(POSIX::strftime("today at %H:%M", gmtime($time)));
		} else {
			return(POSIX::strftime("%Y-%m-%d", gmtime($time)));
		}
	}

	sub secs2mins {
		my($time)=@_;

		return(sprintf('%02d:%04.1f', $time/60, POSIX::fmod($time, 60)));
	}

	sub secs2hrs {
		my($time)=@_;
		my($hrs, $mins, $secs);

		$secs=$time%60;
		$mins=($time/60)%60;
		$hrs=$time/3600;

		return(sprintf('%02d:%02d:%02d', $hrs, $mins, $secs));
	}

	sub nth {
		my($n)=@_;

		if($n==1) {
			return('1st');
		} elsif($n==2) {
			return('2nd');
		} elsif($n==3) {
			return('3rd');
		} else {
			return($n.'th');
		}
	}
}

=head2 Interchange Formats

B<alti+server> can talk both JSON and XML, but needs the libraries to
do so.  The only non-core libraries you should install for B<alti+server>
are C<JSON::XS> and C<XML::Simple>.  Newer versions of perl contain a
pure-perl C<JSON::PP>, and this will be used if C<JSON::XS> is not found.

=cut

{	package json;

	my($String)='';
	my($Json);

	if($Json=eval('use JSON::XS; JSON::XS->new()')) {
		ui::slog('using JSON::XS (good)');
	} elsif($Json=eval('use JSON::PP; JSON::PP->new()')) {
		ui::slog('using JSON::PP, consider installing JSON::XS (its faster)');
	} else {
		die('Could not find a JSON library, please install JSON::XS');
	}

	sub decode {
		local($SIG{'__DIE__'})=sub {
			ui::slog(@_);
			select(undef, undef, undef, 0.1);
			return(0);
		};
		my($ds)=undef;

		$String=join('', $String, @_);

		if($String=~m/^\s*{/ && $String=~m/}\s*$/) {
			$ds=eval { $Json->decode($String) };
			$String='';
		}

		return($ds);
	}

	sub encode {
		return($Json->encode(@_));

	}

	sub pretty {
		my($string);

		$Json->pretty(1);
		$string=$Json->encode(@_);
		$Json->pretty(0);

		return($string);
	}

}

{	package xml;

	use XML::Simple;

	sub decode {
		local($SIG{'__DIE__'})=sub {
			ui::slog(@_);
			select(undef, undef, undef, 0.1);
			return(0);
		};
		my($ds)=eval { XMLin(@_) };

		if($ds) {
			return($ds);
		} else {
			if(@_<2) {
				ui::slog('Failed to read XML from:', @_);
			} else {
				ui::slog('Failed to read XML from:', $_[0], json::encode($_[1]));
			}
			return(undef);
		}
	}

	sub encode {
		my($ds, @opts)=@_;
		my($header)='<?xml version="1.0" encoding="UTF-8"?>';

		unless(ref($ds)) {
			ui::slog('Invalid data structure sent to xml::encode');
			return('');
		}

		return(XMLout($ds, @opts, 'KeepRoot' => 1, 'XMLDecl' => $header));
	}

	sub valid {
		if(&decode(@_)) {
			return(1);
		} else {
			return(0);
		}
	}

}
=head2 State

B<alti+server> keeps state from one invocation to another.  It stores
user preferences for certain extensions, and map preferences.  These are
used to ensure games are playable as designed for different types of maps.
The format for this data is JSON.

This file is read from at startup, and written to when settings changes
are requested by administrative users.  When written to, the previous
version is stored as F<json_attic.txt>.  All settings changes to this
stash are automatically saved to disk.

=cut

{	package stash;

	my($Stashfile)="$INSTALL_ROOT/servers/json_stash.txt";
	my($Stashattic)="$INSTALL_ROOT/servers/json_attic.txt";
	my($Stash)=undef;

	sub _read {
		my($file)=@_;
		my($stash)=IO::Handle->new;
		my($data);

		if(-r $file) {
			open($stash, '<', $file);
			$data=join('', <$stash>);
			close($stash);
			return(json::decode($data));
		} else {
			return({});
		}
	}

	sub _write {
		my($ds, $file)=@_;
		my($stash)=IO::Handle->new;

		foreach my $key (keys(%$ds)) {
			if(ref($ds->{$key}) eq 'HASH') {
				delete($ds->{$key}) unless(%{$ds->{$key}});
			} elsif(ref($ds->{$key}) eq 'ARRAY') {
				delete($ds->{$key}) unless(@{$ds->{$key}});
			}
		}

		rename($file, "$file.bak");
		open($stash, '>', $file);
		print $stash json::pretty($ds);
		close($stash);
	}

	sub get {
		my($value);

		$Stash=&_read($Stashfile) unless($Stash);

		$value=$Stash;
		while(@_) {
			$value=$value->{pop(@_)};
		}

		return($value);
	}

	sub set {
		my($data)=pop(@_);
		my($next, $value);

		$Stash=&_read($Stashfile) unless($Stash);

		$value=$Stash;
		while(@_>1) {
			$next=pop(@_);
			$value->{$next}={} unless(exists($value->{$next}));
			$value=$value->{$next};
		}
		$next=pop(@_);

		$value->{$next}=$data;

		&_write($Stash, $Stashfile);

		return($data);
	}

	sub delete {
		my($value);

		$Stash=&_read($Stashfile) unless($Stash);

		$value=$Stash;
		while(@_>1) {
			$value=$value->{pop(@_)};
		}

		if(delete($value->{$_[0]})) {
			&_write($Stash, $Stashfile);
			return(1);
		} else {
			return(0);
		}
	}
	
	sub archive {
		my($stash)=IO::Handle->new;
		my($attic)=&_read($Stashattic);
		my($value, $archive, $next);

		$Stash=&_read($Stashfile) unless($Stash);

		$value=$Stash;
		$archive=$attic;
		while(@_>1) {
			$next=pop(@_);

			$value=$value->{$next};

			$archive->{$next}={} unless(exists($archive->{$next}));
			$archive=$archive->{$next};
		}
		$next=pop(@_);

		$archive->{$next}=$value->{$next};
		delete($value->{$next});

		&_write($Stash, $Stashfile);
		&_write($attic, $Stashattic);
	}

	sub retrieve {
		my($attic)=&_read($Stashattic);
		my($value);

		$value=$attic;
		while(@_) {
			$value=$value->{pop(@_)};
		}

		return($value);
	}

	sub upgrade {
		my($changes)=0;
		my($tmp);

		$Stash=&_read($Stashfile) unless($Stash);

		if($OPTIONS{'mapDir'} && !$Stash->{'server'}{'mapDir'}) {
			$Stash->{'server'}{'mapDir'}=$OPTIONS{'mapDir'};
			$changes=1;
		}

		foreach my $key (keys(%$Stash)) {
			if(exists($Stash->{$key}{'portals'})) {		##Upgrade portals##
				foreach my $portal (keys(%{$Stash->{$key}{'portals'}})) {
					$tmp=$Stash->{$key}{'portals'}{$portal};
					if(@$tmp==5) {
						delete($Stash->{$key}{'portals'}{$portal});
						$Stash->{$key}{'portals'}{join(',', @$tmp[0,1])}=
							[ $portal, @$tmp[2,3,4] ];
						$changes=1;
					}
				}
			}

			if(exists($Stash->{$key}{'zones'})) {		##Upgrade zones##
				foreach my $team (values(%{$Stash->{$key}{'zones'}})) {
					next if(exists($team->{'zones'}));
		
					foreach my $zone (keys(%$team)) {
						$team->{'zones'}{$zone}=$team->{$zone};
						delete($team->{$zone});
						$changes=1;
					}
				}
			}

		}

		if($changes) {
			&_write($Stash, $Stashfile);
			ui::slog('Stash upgraded');
		}
	}

	sub fix_doors {
		my($map, $left, $right)=@_;
		my($changes)=0;

		if(exists($Stash->{$map}{'door'}{'doors'})) {
			$Stash->{$map}{'door'}{$left}{'doors'}=$Stash->{$map}{'door'}{'doors'};
			$Stash->{$map}{'door'}{$right}{'doors'}=$Stash->{$map}{'door'}{'doors'};
			delete($Stash->{$map}{'door'}{'doors'});

			$changes=1;
		}
		if(exists($Stash->{$map}{'door'}{'keys'})) {
			$Stash->{$map}{'door'}{$left}{'keys'}=$Stash->{$map}{'door'}{'keys'};
			$Stash->{$map}{'door'}{$right}{'keys'}=$Stash->{$map}{'door'}{'keys'};
			delete($Stash->{$map}{'door'}{'keys'});

			$changes=1;
		}

		if($changes) {
			&_write($Stash, $Stashfile);
			ui::slog('Stash upgraded');
		}
	}

}

=head2 Alti+ overhead

The commands used to interract between users and the server must be supplied
to each new user when they join the server.  These commands are sent in the
same packet which contains the server map list.  This packet is of fixed
lenght, and as such the number of maps must shrink to accomdate the added
commands.  This, however, is more of an art than a science, as the data in
this packet is compressed.  Different choices in map names will compress
differently.  It does this by compressing data which will go in this packet
to see if it looks like it will be sufficient.

=cut

{	package compress;

	my($Compress)=	utils::which('lzma', 'good')	||
				utils::which('gzip', 'ok')	||
				utils::which('bzip2', 'ok');

	unless($Compress) {
		ui::slog('No Compress found (guessing), consider installing lzma (its more accurate)');
	}

	sub guess {
		my($input)=join('', @_);
		my(%tokens)=();
		my($total)=0;

		foreach my $tok (split(m/\W+/, $input)) {
			$tokens{$tok}++;
			$total++;
		}

		return(int(length(join('', keys(%tokens)))/2+$total*1.6));
	}

	sub deflate {
		my($in, $out, $err)=(IO::Handle->new, IO::Handle->new, IO::Handle->new);
		my($output)='';
		my($pid);
		
		#6 tends to be the default, and Altitude seems not to be that good:
		$pid=IPC::Open3::open3($in, $out, $err, $Compress, '-4', '-c');

		print $in @_;
		close($in);

		$output=join('', <$out>);
		close($out);
		close($err);
	
		waitpid($pid, 0);

		return($output);
	}

	sub size_data {
		if($Compress) {
			return(length(&deflate(@_)));
		} else {
			return(&guess(@_));
		}
	}

	sub size_file {
		my($file)=@_;
		my($fh)=IO::Handle->new;
		my(@input);

		open($fh, '<', $file);
		@input=<$fh>;
		close($fh);

		if($Compress) {
			return(length(&deflate(@input)));
		} else {
			return(&guess(@input));
		}
	}
}

=head2 Configuration

B<alti+server> gets it's configuration information from a
variety of places.  Configuration files (either altitude server specific
or B<alti+server> specific) are read in at startup, and used to gather
data for a variety of purposes.  This list of files is used to control
the behavior of B<alti+server>:

=over 8

=item custom_json_commands.txt

This file isn't actually read by B<alti+server>; however, each command
supported by B<altiude_mapqa> must be listed and defined in this file.
This is the file which tells the server process what commands are known
to B<alti+server>.

=item launcher_config.xml

This file contains the information used by the altitude C<server_launcher>
process when the server is initially started.  It contains information
used by B<alti+server> such as a Map list and a command list.  These
are used in the interactive interface to provide command-line completion
and for changing maps periodically.  What is especially nice is that admins
never have to edit the launcher_config.xml to add new maps.  When the
altitude server is restarted, the map directory is automatically searched
for maps; these are added to the F<launcher_config.xml> file for you.

=item filtered_swear_words.txt

A list of naughty words which are often used to harrass other players are
listed in this file.  Harrasment isn't cool!  So, when these words are used,
the server notifies the person who wrote them that a language infraction
has occured.  After too many infractions, the player is kicked by the server.

=back

=cut

my(@ALTIPLUS)=(
	{
		'name'			=> 'help',
		'arguments'		=> [['map', 'nextMap', 'gravity', 'weapons', 'spawnHealth', 'cameraScale', 'planeScale', 'assignTeam', 'planes', 'ballScore', 'spawnMode', 'changePlane', 'maxPlayers', 'gameType', 'powerups', 'portals', 'doors', 'keys', 'diverters', 'oneways', 'zones', 'official', 'altitudegame', 'ladder', 'tinyupload', 'url', 'intro', 'records']],
		'voteThreshold'	=> 0,
		'required'		=> 1,
	},
	{
		'name'			=> 'upload',
		'arguments'		=> [['official', 'altitudegame', 'ladder', 'tinyupload', 'url'], 'string'],
		'voteThreshold'	=> 100,
		'required'		=> 1,
	},
	{
		'name'			=> 'list',
		'arguments'		=> [['map', 'nextMap', 'gravity', 'weapons', 'spawnHealth', 'cameraScale', 'planeScale', 'assignTeam', 'planes', 'ballScore', 'spawnMode', 'changePlane', 'maxPlayers', 'gameType', 'powerups', 'portals', 'doors', 'keys', 'diverters', 'oneways', 'zones', 'intro', 'records']],
		'voteThreshold'	=> 0,
		'required'		=> 1,
	},
	{
		'name'			=> 'set',
		'arguments'		=> [['nextMap', 'gravity', 'weapons', 'spawnHealth', 'cameraScale', 'planeScale', 'assignTeam', 'planes', 'ballScore', 'spawnMode', 'changePlane', 'maxPlayers', 'gameType', 'intro', 'keys'], 'string'],
		'voteThreshold'	=> 100,
		'required'		=> 1,
	},
	{
		'name'			=> 'unset',
		'arguments'		=> [['nextMap', 'gravity', 'weapons', 'spawnHealth', 'cameraScale', 'planeScale', 'assignTeam', 'planes', 'ballScore', 'spawnMode', 'changePlane', 'maxPlayers', 'gameType', 'intro', 'keys']],
		'voteThreshold'	=> 100,
		'required'		=> 1,
	},
	{
		'name'			=> 'add',
		'arguments'		=> [['powerup', 'portal', 'door', 'key', 'diverter', 'oneway', 'zone'], 'string'],
		'voteThreshold'	=> 100,
		'required'		=> 1,
	},
	{
		'name'			=> 'del',
		'arguments'		=> [['powerup', 'portal', 'door', 'key', 'diverter', 'oneway', 'zone', 'record'], 'string'],
		'voteThreshold'	=> 100,
		'required'		=> 1,
	},
	{
		'name'			=> 'restartServer',
		'arguments'		=> [],
		'voteThreshold'	=> 100,
		'required'		=> 1,
	},
	{
		'name'			=> 'randomMap',
		'arguments'		=> [],
		'voteThreshold'	=> 66,
		'required'		=> 1,
	},
	{
		'name'			=> 'removeMap',
		'arguments'		=> ['map'],
		'voteThreshold'	=> 100,
		'required'		=> 1,
	},
	{
		'name'			=> 'spawnZone',
		'arguments'		=> ['string'],
		'argumentDescriptions' => ['Zone name'],
		'voteThreshold'	=> 0,
		'required'		=> 1,
	},
	{
		'name'			=> 'sz',
		'arguments'		=> ['string'],
		'argumentDescriptions' => ['Zone name'],
		'voteThreshold'	=> 0,
		'required'		=> 1,
	},
	{
		'name'			=> 'changePlane',
		'arguments'		=> [],
		'voteThreshold'	=> 0,
		'required'		=> 1,
	},
	{
		'name'			=> 'cp',
		'arguments'		=> [],
		'voteThreshold'	=> 0,
		'required'		=> 1,
	},
	{
		'name'			=> 'switch',
		'arguments'		=> [],
		'voteThreshold'	=> 0,
		'required'		=> 1,
	},
	{
		'name'			=> 'talk',
		'arguments'		=> ['player', 'string'],
		'voteThreshold'	=> 0,
		'required'		=> 1,
	},
	{
		'name'			=> 'mesg',
		'arguments'		=> [['Yes', 'No', '?']],
		'voteThreshold'	=> 0,
		'required'		=> 1,
	},
	{
		'name'			=> 'sum',
		'arguments'		=> [['crc32', 'md5', 'sha1', 'sha256']],
		'voteThreshold'	=> 0,
		'required'		=> 0,
	},
	{
		'name'			=> 'logPickups',
		'arguments'		=> [],
		'voteThreshold'	=> 0,
		'required'		=> 0,
	},
	{
		'name'			=> 'restartMap',
		'arguments'		=> [],
		'voteThreshold'	=> 0,
		'required'		=> 0,
	},
);

{	package config;

	use Storable;
	use FindBin qw($Bin $RealBin);

	my($Conffile)	="$INSTALL_ROOT/servers/launcher_config.xml";
	my($Custfile)	="$INSTALL_ROOT/servers/custom_json_commands.txt";
	my($Custfile_o)="$INSTALL_ROOT/servers/custom_json_commands_old.txt";
	my($Filtfile)	="$INSTALL_ROOT/config/filtered_swear_words.txt";

	my(%Admins)=();
	my(%Commands)=();
	my(@Maps)=();
	my(%Mapdb)=();
	my($Language);
	my($Reserve)=0;

	our($Port)=0;
	our($Ping)=500; #reset from launcher_config.xml
	our($Goals)=6;  #reset from launcher_config.xml
	our($Maxp)=14;  #reset from launcher_config.xml

	our($Clock)=1000;  #Clock is in milliseconds

	our($Uuid)=stash::get('uuid', 'server');

	stash::set('uuid', 'server', $Uuid=utils::uuid) unless($Uuid);
	stash::set('uuid', 'server', $Uuid=utils::uuid) if($Uuid=~m/-0000-/);

	$OPTIONS{'mapDir'}=~s|/+$|| if($OPTIONS{'mapDir'});

	sub option_exists {
		return(exists($OPTIONS{$_[0]}));
	}

	sub option {
		my($key)=@_;
		my($value)=stash::get($key, 'server') // $OPTIONS{$key};

		if(ref($value)) {
			return($value);
		} elsif($value=~m/^(true|yes|t|y)$/i) {
			return(1);
		} elsif($value=~m/^(false|no|f|n)$/i) {
			return(0);
		} else {
			return($value);
		}
	}

	sub option_set {
		my($name, $value)=@_;

		stash::set($name, 'server', $value);
	}

	sub option_del {
		my($name)=@_;

		stash::delete($name, 'server');
	}

	sub _packet_length {
		my($size)=0;
		my($str);

		foreach my $arg (@_) {
			if(ref($arg)) {
				$str=json::encode($arg);
			} else {
				$str=$arg;
			}
			$str=~s/\W//g;
			$size+=length($str);
		}

		return($size);
	}

	sub _write_custom_commands {
		my($cmd)=Storable::dclone($_[0]);
		my($fh)=IO::Handle->new;
		my($json);

		unless(&option('enableTalk')) {
			return if($cmd->{'name'} eq 'talk');
			return if($cmd->{'name'} eq 'mesg');
		}

		unless(&option('allowUploads') && &option('superAdmin')!~m/console/) {
			return if($cmd->{'name'} eq 'upload');
			return if($cmd->{'name'} eq 'removeMap');
		}

		if(&option('configSize')=~m/tiny/i) {
			return unless($cmd->{'required'});
			return if($cmd->{'voteThreshold'}==100 && $cmd->{'name'} ne '!');

			delete($cmd->{'argumentDescriptions'});
			foreach my $arg (@{$cmd->{'arguments'}}) {
				$arg='string' if(ref($arg));
			}
		} elsif(&option('configSize')=~m/small/i) {
			delete($cmd->{'argumentDescriptions'});
			foreach my $arg (@{$cmd->{'arguments'}}) {
				$arg='string' if(ref($arg));
			}
		}

		delete($cmd->{'required'});

		$json=json::encode($cmd);
		open($fh, '>>', $Custfile);
		print $fh $json, "\n";
		close($fh);
	}

	sub write_launcher_config {
		my($lconfig)=IO::Handle->new;
		my($maplist, $adminlist)=(0, 0);
		my($admins)=config::option('admins');
		my($rotation)=config::option('rotationRE');
		my($update_maps)=config::option('updateMapList');
		my($update_admins)=($admins=~m/[1-9a-f]/);
		my(@xml);

		return unless($update_maps || $update_admins);

		open($lconfig, '<', $Conffile);
		@xml=<$lconfig>;
		close($lconfig);

		foreach(@xml) {
			if($update_maps) {
				if(m{</mapList>}i) {
					foreach my $map (@Maps) {
						s{^}{        <String value="$map" />\r\n}s;
					}
					$maplist=0;
				}
				if(m{</mapRotationList>}i) {
					foreach my $map (grep(m/($rotation)/, @Maps)) {
						s{^}{        <String value="$map" />\r\n}s;
					}
					$maplist=0;
				}

				if($maplist) {
					$_=''
				}
	
				if(m{<mapList>|<mapRotationList>}i) {
					$maplist=1;
				}
			}

			if($update_admins) {
				if(m{</adminsByVaporID>}i) {
					foreach my $admin (split(m/;/, $admins)) {
						s{^}{        <UUID UUID="$admin" />\r\n}s;
					}
					$adminlist=0;
				}

				if($adminlist) {
					$_=''
				}
	
				if(m{<adminsByVaporID>}i) {
					$adminlist=1;
				}
			}
		}

		rename($Conffile, "$Conffile.bak");
		open($lconfig, '>', $Conffile);
		print $lconfig @xml;
		close($lconfig);
	}

	sub launcher {
		my($server)=xml::decode($Conffile);
		my($fh)=IO::Handle->new;
		my(@filter)=();
		local($_);

		foreach my $admin (@{$server->
							{'servers'}
							{'AltitudeServerConfig'}
							{'adminsByVaporID'}
							{'UUID'}
						}) {
			$Admins{$admin->{'UUID'}}=1;
		}

		$Port=$server->{'servers'}{'AltitudeServerConfig'}{'port'};
		$Ping=$server->{'servers'}{'AltitudeServerConfig'}{'maxPing'};
		$Maxp=$server->{'servers'}{'AltitudeServerConfig'}{'maxPlayerCount'};

		$Goals=POSIX::ceil(($server->
						{'servers'}
						{'AltitudeServerConfig'}
						{'PlaneBallGameMode'}
						{'goalsPerRound'}
					)/2
			);

		%Commands=map(($_->{'ConsoleCommand'} => undef), @{$server->
				{'servers'}
				{'AltitudeServerConfig'}
				{'consoleCommandPermissions'}
				{'AltitudeServerConsoleCommandPermissions'}
			});

		$Commands{'changeMap'}=['map'];
		$Commands{'removeMap'}=['map'];
		$Commands{'kick'}=['player'];
		$Commands{'ban'}=['vaporId'];
		$Commands{'serverWhisper'}=['player', 'string'];

		rename($Custfile, $Custfile_o);

		&_write_custom_commands({
			"name"			=> "!",
			"arguments"		=> ["string"],
			"voteThreshold"	=> 100,
			"required"		=> 1,
		}) if(&option('configSize')=~m/tiny/i);

		foreach my $cmd (@ALTIPLUS) {
			if($cmd->{'arguments'} && @{$cmd->{'arguments'}}) {
				$Commands{$cmd->{'name'}}=$cmd->{'arguments'};
			} else {
				$Commands{$cmd->{'name'}}=undef;
			}

			&_write_custom_commands($cmd);
		}

		$Reserve=compress::size_file($Custfile);

		#These work only from console (see %CONSOLE):
		$Commands{'server'}=[
				['list', 'set', 'unset', 'add', 'del'],
				[sort(keys(%OPTIONS))],
				'string',
			];
		$Commands{'showPlayer'}=['player'];
		$Commands{'showTeams'}=undef;
		$Commands{'showSeen'}=undef;
		$Commands{'chatLeft'}=['string'];
		$Commands{'chatRight'}=['string'];
		$Commands{'chatSpec'}=['string'];
		$Commands{'shutdown'}=undef;

		open($fh, '<', $Filtfile);
		while(<$fh>) {
			chomp;
			s/\s+//g;
			s/er$//;

			next if(m/damn|bollocks/);

			push(@filter, $_);
		}
		close($fh);
		$Language=sprintf('(%s|\b)(%s)+(%s)?s?\b',
				'er|ing?',
				join('|', @filter),
				'a|er|ing?|ed'
			);
	}

	sub read_maps {
		my($lconfig)=IO::Handle->new;
		my($maplist)=0;
		local($_);

		@Maps=();

		open($lconfig, '<', $Conffile);

		while(<$lconfig>) {
			if(m{</mapList>}i) {
				$maplist=0;
			}

			if($maplist) {
				push(@Maps, $1) if(m{<String value="(.*?)" />});
			}

			if(m{<mapList>|<mapRotationList>}i) {
				$maplist=1;
			}
		}

		close($lconfig);
	}

	sub _map_sort {
		$Mapdb{$a}=(-C $a) unless($Mapdb{$a});
		$Mapdb{$b}=(-C $b) unless($Mapdb{$b});

		return( $Mapdb{$a} <=> $Mapdb{$b} );
	}

	sub find_maps {
		my($packet_space)=1450-250-20*$Maxp-$Reserve;
		my($mapdir)=config::option('mapDir');

		ui::slog('Space reserved for maps:', $packet_space);

		@Maps=sort(config::_map_sort <$INSTALL_ROOT/maps/$mapdir/*_*.altx>);

		if(&option('lobby')) {
			@Maps=grep($_ ne &option('lobby'), @Maps);
		}

		foreach(@Maps) {
			s|^$INSTALL_ROOT/maps/+||;
			s|\.altx$||;
		}

		while(@Maps && compress::size_data(@Maps)>$packet_space) {
			ui::slog('Excluding map due to packet size constraint:',
				pop(@Maps));
		}

		@Maps=List::Util::shuffle(@Maps);

		unless(@Maps) {
			ui::slog('Error: no maps found during startup');
			return;
		}
	}

	sub resize {
		my($diff)=@_;
		$diff-=1450;

		$Reserve+=$diff;
	}

	sub new_maps {
		my($lconfig)=IO::Handle->new;
		my($mapdir)=config::option('mapDir');
		my(%maps)=();
		local($_);

		foreach my $map (@_) {
			$maps{$map}=1 if(file::name_ok($map));
		}

		return(0) unless(%maps);

		open($lconfig, '<', $Conffile);
		while(<$lconfig>) {
			delete($maps{$1}) if(m| <String value="($mapdir.*?)" />|);
		}
		close($lconfig);


		if(%maps) {
			return(1);
		} else {
			return(0);
		}
	}

	sub remove_maps {
		my(@old)=@Maps;

		foreach my $map (@_) {
			@Maps=grep(!m/^\Q$map\E$/, @old);
		}

		if(@old==@Maps) { #Same size?
			return(0);
		} else {
			return(1);
		}
	}

	sub maps {
		return(@Maps);
	}

	sub lobby {
		return(config::option('lobby'));
	}

	sub random_map {
		my($rotation)=config::option('rotationRE');
		my(@candidates)=grep(m/($rotation)/, @Maps);
		my($next)=stash::get('nextMap', 'admin');

		if($next) {
			stash::delete('nextMap', 'admin');
			return($next);
		} else {
			return($candidates[int(rand(@candidates))]);
		}
	}

	sub admin_vip {
		my($vaporid)=@_;
		return(exists($Admins{$vaporid}));
	}

	sub commands {
		my($re)=@_;
		grep(m|^\Q$re|i, keys(%Commands));
	}

	sub arguments {
		my($command)=@_;

		if($Commands{$command}) {
			return(@{$Commands{$command}});
		} else {
			return(undef);
		}
	}

	sub command_help {
		my($p, $command)=@_;
		my($msg)="Syntax: /$command";
		my(@args)=();
		my($choice)=1;
		my($list);

		if($Commands{$command}) {
			foreach my $arg (@{$Commands{$command}}) {
				if(ref($arg) eq 'ARRAY') {
					$msg.=" <choice$choice>";
					push(@args, join(' ', "choice$choice:", @$arg));
					$choice++;
				} elsif($arg eq 'map') {
					$msg.=" <map>";
					$list=join(' ', "map:", @Maps);
					if(length($list)>390) {
						substr($list, 390, 4096, " ...");
					}
					push(@args, $list);
				} elsif($arg eq 'player') {
					$msg.=" <player>";
					push(@args, join(' ', "players:", player::values('nickname')));
				} elsif($arg eq 'vaporId') {
					$msg.=" <vaporId>";
					push(@args, join(' ', "vaporIds:", map(
							"$_->{'nickname'}:$_->{'vaporId'}",
							player::list()))
						);
				} else {
					$msg.=" <...>";
				}
			}
			chat::whisper($p, $msg);
			foreach my $arg (@args) {
				chat::whisper($p, ' ', $arg);
			}
		}
	}

	sub language {
		local($_)=@_;

		if(config::option('bullyKick') && m/$Language/i) {
			return(1);
		} else {
			return(0);
		}
	}
}

=head2 AltBouncer

Keep AltBouncer up-to-date.  If the C<altBouncer> configuration option is
set, then the server will keep track of all users seen and periodically send
them to the AltBouncer system.

=cut

{	package altbouncer;

	my($File)="$INSTALL_ROOT/servers/players_seen_$config::Uuid.xml";
	my($Url)='http://tec27.com/altbouncer/uploadaltnames.php';
	my($Curl)=utils::which('curl', 'good', 'forcing AltBouncer support off');
	my(@Args)=qw(-s -m 5 -F MAX_FILE_SIZE=80000);

	my(%Seen)=();

	sub add {
		my($p)=@_;

		return unless(config::option('altBouncer'));
		return unless($Curl);
		return if($p->{'demo'});
		return if($p->{'nickname'}=~m/Guest_\d{12}/);

		if($p->{'nickname'} && $p->{'vaporId'}) {
			$Seen{$p->{'nickname'}}{$p->{'vaporId'}}=time()*1000;
		}
	}

	sub count {
		return(scalar(keys(%Seen)));
	}

	sub seen {
		my(@players)=();

		foreach my $nick (keys(%Seen)) {
			#Don't propogate people messing around with a nick:
			next if(keys(%{$Seen{$nick}}) > 2);

			foreach my $vip (keys(%{$Seen{$nick}})) {
				push(@players, {
					'lastPlayedWithTime'	=> $Seen{$nick}{$vip},
					'nickname'			=> $nick,
					'vaporID'				=> $vip,
				});
			}
		}

		return(@players);
	}

	sub lookup {
		my($query)=@_;
		my(@players)=();

		foreach my $nick (keys(%Seen)) {
			#Don't propogate people messing around with a nick:
			next if(keys(%{$Seen{$nick}}) > 2);
			next if($nick!~m/$query/ && $query!~m/^[0-9a-f-]{36}$/);

			foreach my $vip (keys(%{$Seen{$nick}})) {
				next if($vip!~m/$query/ && $query=~m/^[0-9a-f-]{36}$/);

				push(@players, {
					'lastPlayedWithTime'	=> $Seen{$nick}{$vip},
					'nickname'			=> $nick,
					'vaporID'				=> $vip,
				});
			}
		}

		return(@players);
	}

	sub upload {
		my($stage, $upload)=(IO::Handle->new, IO::Handle->new);
		my($rejected)=1;
		local($_);

		return unless(keys(%Seen)>10);

		open($stage, '>', $File);
		print $stage xml::encode({
				'PlayedWithList' => {'list' => {'PlayedWith' => [&seen]}}
			});
		close($stage);

		unless(xml::valid($File)) {
			ui::slog('Generated invalid XML file, not uploading');
			%Seen=();
			return;
		}

		ui::slog($Curl, @Args, '-F', "uploadedfile=\@$File", $Url);
		open($upload, '-|', $Curl, @Args, '-F', "uploadedfile=\@$File", $Url);

		while(<$upload>) {
			chomp;
			ui::slog($_) if(m/<title>|<h2>|error|fail/i);
			$rejected=0 if(m/<h2>Completed/);
		}

		close($upload);

		if($?) {
			ui::slog('ERROR : CURL EXIT STATUS:', $?>>8);
		} elsif($rejected) {
			ui::slog('WARN  : curl upload rejected by AltBouncer');
			%Seen=();
		} else {
			ui::slog('INFO  : curl upload to AltBouncer successful');
			%Seen=();
		}
	}
}

=head2 Altitude Game Engine

The core of B<alti+server> is the altitude game engine itself.  B<alti+server>
starts the altitude server, watches it's output and log files, and interacts
directly with it to manage the instance.

=cut

{	package server;

	use IO::Select;

	my($Logfile)	="$INSTALL_ROOT/servers/log.txt";
	my($Logfile_o)	="$INSTALL_ROOT/servers/log_old.txt";
	my($Pidfile)	="$INSTALL_ROOT/servers/server_launcher.pid";

	my(%Trigger)=();

	my($Log)=IO::Handle->new;
	my($Server)=IO::Handle->new;

	my($Streams)=IO::Select->new(\*STDIN);
	my($Server_pid, $Tail_pid);

	my($Cu, $Cs)=(0, 0);

	our($Start)=time();

	sub start {
		my(@times);

		$Streams->remove($Server);

		if($Server_pid && kill('HUP', $Server_pid)) {
			@times=utils::proc_time($Server_pid);
			$Cu+=$times[0];
			$Cs+=$times[1];

			waitpid($Server_pid, 0);
			close($Server);
			$Server_pid=undef;
		}

		rename($Logfile, $Logfile_o);

		chdir($INSTALL_ROOT);

		open($Server, '-|:unix', './server_launcher', '-noui');
		$Server->autoflush(1);
		$Streams->add($Server);
	}

	sub reopen_log {
		my($pid)=IO::Handle->new;
		my($in)=IO::Handle->new;
		my(@times);

		$Start=time();

		$Streams->remove($Log);

		if($Tail_pid && kill('HUP', $Tail_pid)) {
			@times=utils::proc_time($Tail_pid);
			$Cu+=$times[0];
			$Cs+=$times[1];

			close($Log);
			$Tail_pid=undef;
		}

		open($pid, '<', $Pidfile);
		$Server_pid=<$pid>;
		close($pid);

		close(STDERR);
		$Tail_pid=open($Log, '-|:unix', 'tail', '--pid', $Server_pid, '-F', $Logfile);
		$Log->autoflush(1);
		$Streams->add($Log);
	}
	
	sub data { 
		my(@streams);
		my($hang)=time()+300;

		@streams=$Streams->can_read(300);

		if(@streams || time()<$hang) {
			return(@streams);
		} else {
			return(0xDEAD);
		}
	}

	sub is_log {
		return($_[0]==$Log);
	}

	sub is_output {
		return($_[0]==$Server);
	}

	sub event {
		return(json::decode($Log->getline));
	}

	sub output {
		return($Server->getline);
	}

	sub interrupt {
		if($Tail_pid) {
			kill('CONT', $Tail_pid);
			kill('INT', $Tail_pid);
		}
		if($Server_pid) {
			kill('CONT', $Server_pid);
			kill('INT', $Server_pid);
		}
	}

	sub shutdown {
		kill('HUP', $Tail_pid) if($Tail_pid);
		kill('HUP', $Server_pid) if($Server_pid);

		$Streams->remove($Server, $Log);

		close($Server);
		close($Log);

		waitpid($Server_pid, 0);
		waitpid($Tail_pid, 0);

		$Server_pid=undef;
		$Tail_pid=undef;
	}

	sub uptime {
		return(utils::secs2hrs(time()-$^T));
	}

	sub cpu_secs {
		my($pu, $ps, $cu, $cs)=times;
		my(@times);

		foreach my $pid ($Server_pid, $Tail_pid) {
			@times=utils::proc_time($pid);
			$cu+=$times[0];
			$cs+=$times[1];
		}

		return($pu+$cu+$Cu, $ps+$cs+$Cs);
	}

	sub cpu_hrs {
		return(map(utils::secs2hrs($_), &cpu_secs));
	}

	sub send {
		my($command)=shift;
		my($pipe)="$INSTALL_ROOT/servers/command.txt";
		my($msg)=IO::Handle->new;

		foreach my $arg (@_) {
			if($arg=~m/^\s*".*"\s*$/) {
				$command.=sprintf(' %s', $arg);
			} elsif($arg=~m/[ \t'`]/) {
				$command.=sprintf(' "%s"', $arg);
			} else {
				$command.=sprintf(' %s', $arg);
			}
		}
		
		open($msg, '>>', $pipe);
		printf($msg "%d,%s,%s\n", $config::Port, 'console', $command);
		close($msg);
	}

	sub trigger {
		my($command, $key, @data)=@_;

		&send($command);
		push(@{$Trigger{$command}}, ["$command:$key", @data]);
	}

	sub override {
		my($command, $key, @data)=@_;

		push(@{$Trigger{$command}}, ["$command:$key", @data]);
	}

	sub triggers {
		my($command)=@_;

		if(exists($Trigger{$command})) {
			return(shift(@{$Trigger{$command}}));
		} else {
			return();
		}
	}

}

=head2 Maps

Altitude maps are the playing surfaces for each game.  Each one has
different modes, characteristics, and design.  Beyond what is supported
by default with Altitude, Alti+ maps can have additional characterstic
types which alter the normal behavior.

=cut

{	package map;

	my($Map)=undef;
	my($Type)=undef;

	my($Cpu)=0;
	my($Ds)=undef;
	my(%Pickups)=();
	my(%Goals)=();

	our($Xmid, $Ymid)=(0, 0);

	my(%Teams)=(
		2	=> 'spec',	'spec'	=> 2,
		3	=> 'red',		'red'	=> 3,
		4	=> 'blue',	'blue'	=> 4,
		5	=> 'green',	'green'	=> 5,
		6	=> 'yellow',	'yellow'	=> 6,
		7	=> 'orange',	'orange'	=> 7,
		8	=> 'purple',	'purple'	=> 8,
		9	=> 'azure',	'azure'	=> 9,
		10	=> 'pink',	'pink'	=> 10,
		11	=> 'brown',	'brown'	=> 11,
	);
	my($Color_re)=join('|', grep(length>2, keys(%Teams)));

	sub file {
		my($mapdir)=config::option('mapDir');

		if($mapdir) {
			return("$INSTALL_ROOT/maps/$mapdir/$Map->{'map'}.altx");
		} else {
			return("$INSTALL_ROOT/maps/$Map->{'map'}.altx");
		}
	}

	sub definition {
		my($map)=@_;
		my($mapdir)=config::option('mapDir');
		my($cache)="$INSTALL_ROOT/maps/cache/$mapdir";
		my($file)=<$cache/$map.altx/*.alte>;
		my(%parser)=(
			'SuppressEmpty'	=> 1,
			'ForceArray'		=> ['View', 'powerupSpawner', 'String'],
			'ValueAttr'		=> [ 'value', 'index' ],
			'GroupTags'		=> {
				'views'			=> 'View',
				'selectedPowerups'	=> 'String',
				'image'			=> 'path'
			}
		);

		if(-r $file) {
			return(xml::decode($file, %parser));
		} else {
			ui::slog("!!!  I could not find a .alte file in your  !!!");
			ui::slog("!!!  $cache  !!!");
			ui::slog("!!!  Your map cache is broken, this is bad  !!!");
			ui::slog("!!!  I will do my best, but without seeing  !!!");
			ui::slog("!!!  the map definition, I am blind to the  !!!");
			ui::slog("!!!  location of pickups.                   !!!");

			if(-d "$cache/$map.altx") {
				if(-w "$cache/$map.altx") {
					ui::slog("Your cache directory exists, why isn't there .alte file?");
				} else {
					ui::slog("$cache/$map.altx isn't writable");
				}
			} else {
				ui::slog("$cache/$map.altx does not exist");
				if(-d $cache) {
					ui::slog("$cache isn't writable") unless(-w $cache);
				} else {
					ui::slog("$cache does not exist");
				}
			}

			return(undef);
		}
	}

	sub set_type {
		local($_)=@_;

		if(m/(^|_)flag(_|$)/) {
			$Type='flag';
		} elsif(m/(^|_)zone(_|$)/) {
			$Type='zone';
		} elsif(m/(^|_)ra?ce(_|$)/) {
			$Type='race';
		} elsif(m/(^|_)coop(_|$)/) {
			$Type='coop';
		} elsif(m/(^|_)mdg(_|$)/) {
			$Type='mdg';
		} else {
			$Type='std';
		}

		return($Type);
	}

	sub type {
		if(@_) {
			return(grep(m/^$Type$/, @_)>0);
		} else { 
			return($Type);
		}
	}

	sub start	{
		return($Map->{'time'});
	}

	sub busy {
		$Map->{'idle'}=time();
	}

	sub idle {
		return(0) unless($Map->{'map'});
		return(time()-$Map->{'idle'});
	}

	sub teams {
		($Map->{'leftTeam'}, $Map->{'rightTeam'})=@_;
	}

	sub _value_or_query {
		my($key)=shift;

		if(@_) {
			return(grep($Map->{$key} eq $_, @_)>0);
		} else {
			return($Map->{$key});
		}
	}

	sub name		{ &_value_or_query('map', @_);		}
	sub mode		{ &_value_or_query('mode', @_);		}

	sub left		{
		foreach(@_) {
			return(1) if(m/^$Teams{$Map->{'leftTeam'}}$/i);
			return(1) if(m/^(left|<|all|both|\*|0)$/i);
		}
		&_value_or_query('leftTeam', @_);
	}

	sub right		{
		foreach(@_) {
			return(1) if(m/^$Teams{$Map->{'rightTeam'}}$/i);
			return(1) if(m/^(right|>|all|both|\*|1)$/i);
		}
		&_value_or_query('rightTeam', @_);
	}

	sub spec		{
		if(@_) {
			foreach(@_) {
				return(1) if(m/^(spec.*|\^|all|\*|-1|$Teams{'spec'})$/i);
			}
			return(0);
		} else {
			return($Teams{'spec'});
		}
	}

	sub side		{
		my($p)=@_;

		if(&left($p->{'team'})) {
			return('left');
		} elsif(&right($p->{'team'})) {
			return('right');
		} else {
			return(undef);
		}
	}

	sub team_color {
		my($team)=@_;

		if($team=~m/$Color_re/i) {
			return($team);
		} elsif(&left($team)) {
			return($Teams{$Map->{'leftTeam'}});
		} elsif(&right($team)) {
			return($Teams{$Map->{'rightTeam'}});
		} elsif(&spec($team)) {
			return('spec');
		} elsif($team=~m/^\d+$/) {
			return($Teams{$team});
		} else {
			return('unknown');
		}
	}

	sub team_number {
		my($team)=@_;

		if($team=~m/$Color_re/i) {
			return($Teams{$team});
		} elsif(&left($team)) {
			return($Map->{'leftTeam'});
		} elsif(&right($team)) {
			return($Map->{'rightTeam'});
		} elsif(&spec($team)) {
			return(2);
		} elsif($team=~m/^\d+$/) {
			return($team);
		} else {
			return(undef);
		}
	}

	sub team_symbol {
		my($team)=@_;

		if(&left($team)) {
			return('<');
		} elsif(&right($team)) {
			return('>');
		} elsif(&spec($team)) {
			return('^');
		} else {
			return('?');
		}
	}

	sub powerup {
		my($e, $type)=@_;
		my($xy)=join(',', @$e{'positionX','positionY'});

		if(exists($Pickups{$xy})) {
			if($type) {
				if(@{$Pickups{$xy}}==1 && $Pickups{$xy}[0]=~m/$type/i) {
					return($Pickups{$xy}[0]);
				} else {
					return(undef);
				}
			} else {
				return(@{$Pickups{$xy}});
			}
		} elsif(!defined($Ds)) {
			return(undef) if($e->{'velocityX'} || $e->{'velocityY'});
			return(undef) if($e->{'positionX'}=~m/\./);
			return(undef) if($e->{'positionY'}=~m/\./);

			if($type) {
				if($e->{'powerup'}=~m/$type/i) {
					return($e->{'powerup'});
				} else {
					return(undef);
				}
			} else {
				return($e->{'powerup'});
			}
		} else {
			return(undef);
		}
	}

	sub register_goal {
		my($obj)=@_;
		my(@goal)=utils::transform($obj->{'transformation'}, -25, 0);
		my(@box)=utils::transform($obj->{'transformation'}, 60, 0);

		$goal[0]+=$obj->{'x'};
		$goal[1]+=$obj->{'y'};

		$box[0]+=$obj->{'x'};
		$box[1]+=$obj->{'y'};

		$Goals{$obj->{'team'}}{'goal'}=[@goal];

		#The goal box is really a circle:
		$Goals{$obj->{'team'}}{'box'}=[@box];
		$Goals{$obj->{'team'}}{'radius'}=utils::distance(@goal, @box);
	}

	sub goalbox {
		my($e)=@_;
		my($x, $y)=@$e{'positionX','positionY'};
		my($left, $right)=(&left(), &right());
		my($box, $radius);
		
		if($box=$Goals{$left}{'box'}) {
			$radius=$Goals{$left}{'radius'};

			if(utils::distance(@$box, $x, $y) < $radius) {
				return('left');
			}
		}

		if($box=$Goals{$right}{'box'}) {
			$radius=$Goals{$right}{'radius'};

			if(utils::distance(@$box, $x, $y) < $radius) {
				return('right');
			}
		}

		return();
	}

	sub going_in {
		my($e)=@_;
		my($cx, $cy)=@$e{'positionX','positionY'};
		my($vx, $vy)=@$e{'velocityX','velocityY'};
		my($team, $goal);
		my($catch, $miss);

		#Extend the travel line by two intervals:
		$vx*=2;
		$vy*=2;

		if($team=&goalbox($e)) {
			if($goal=$Goals{&team_number($team)}{'goal'}) {
				$catch=utils::distance(@$goal, $cx, $cy);
				$miss=utils::distance(@$goal, $cx+$vx, $cy+$vy);

				return(1) if($miss < $catch);
			}
		}

		return(0);
	}

	sub cpu {
		return(List::Util::sum(server::cpu_secs)-$Cpu);
	}

	sub new {
		my($mapref)=@_;
		my(@views)=();

		$Map=$mapref;
		&set_type($Map->{'map'});
		$Map->{'idle'}=time();

		$Cpu=List::Util::sum(server::cpu_secs);
		$Ds=&definition($Map->{'map'});
		%Pickups=();
		%Goals=();

		$Xmid=$Ds->{'views'}{'Game'}{'bounds'}{'maxX'}/2;
		$Ymid=$Ds->{'views'}{'Game'}{'bounds'}{'maxY'}/2;

		if(ref($Ds->{'views'}{'Game'}{'Goal'}{'Goal'}) eq 'ARRAY') {
			foreach my $goal (@{$Ds->{'views'}{'Game'}{'Goal'}{'Goal'}}) {
				&register_goal($goal);
			}
		}

		@views=map($Ds->{'views'}{$_}{'powerupSpawner'},
			keys(%{$Ds->{'views'}}));

		foreach my $view (@views) {
			next unless($view);

			foreach my $pu (@{$view->[0]{'powerupSpawner'}}) {
				$Pickups{"$pu->{'x'},$pu->{'y'}"}=$pu->{'selectedPowerups'};
			}
		}
	}

	sub end {
		ui::slog('INFO  : CPU used by', &name, ':', utils::secs2mins(&cpu));
	}


}

=head2 Players

The B<alti+server> wrapper initiates the altitude game engine to ensure
it has full knowledge of it's state, and the users logged into the server.
Since it manages starts, restarts, and shutdowns. it sees every user login
and logoff.  This is used to keep active player profiles.  Statistics
are kept on players, and information about what team they are on, etc.
is updated with them as the games progress.

=cut

{	package player;

	my(@Players)=();
	my(@Admins)=();
	my(%Pdb)=();

	sub server {
		return({
			'nickname'	=> 'server',
			'vaporId'		=> '00000000-0000-0000-0000-000000000000',
			'player'		=> -1,
			'team'		=> -1,
			'isBot'		=> 1,
			'superAdmin'	=> 1,
		});
	}

	sub add {
		my($p)=@_;
		my($sas)=config::option('superAdmins');

		$p->{'alive'}=1;

		if($p->{'nickname'}=~m/^Bot ([1-9]|[1-2][0-9])$/) {
			$p->{'isBot'}=1;
		} else {
			$p->{'isBot'}=0;
			push(@Players, $p);
		}

		if(config::admin_vip($p->{'vaporId'})) {
			push(@Admins, $p);
		}

		if($sas=~m/(^|;)$p->{'vaporId'}(;|$)/) {
			$p->{'superAdmin'}=1;
		} else {
			$p->{'superAdmin'}=0;
		}

		$Pdb{$p->{'nickname'}}	=
		$Pdb{$p->{'player'}}	=
		$Pdb{$p->{'vaporId'}}	= $p;
	}

	sub rename {
		my($old, $new)=@_;
		my($p)=$Pdb{$old};

		$Pdb{$new}=$p;
		delete($Pdb{$old});

		$p->{'nickname'}=$new;
	}

	sub remove {
		my($p)=@_;

		delete($Pdb{$p->{'nickname'}});
		delete($Pdb{$p->{'vaporId'}});
		delete($Pdb{$p->{'player'}});

		for(my $i=0; $i<@Players; $i++) {
			if($Players[$i]==$p) {
				splice(@Players, $i, 1);
				last;
			}
		}

		for(my $i=0; $i<@Admins; $i++) {
			if($Admins[$i]==$p) {
				splice(@Admins, $i, 1);
				last;
			}
		}

		$p->{'alive'}=0;
		delete($p->{'player'});
	}

	sub lookup {
		my($player)=@_;

		return(undef) if($player eq '00000000-0000-0000-0000-000000000000');

		if(length($player)>0 && exists($Pdb{$player})) {
			return($Pdb{$player});
		} else {
			return(undef);
		}
	}

	sub infraction {
		my($p, $value)=@_;
		my($count)=config::option('infractions');

		$p->{'infractions'}+=$value;
		if($p->{'infractions'}>$count) {
			server::send('kick', $p->{'nickname'});
			return(0);
		} else {
			return($p->{'infractions'});
		}
	}

	sub forgive {
		my($p)=@_;

		$p->{'infractions'}-- if($p->{'infractions'}>0);
	}

	sub event_search {
		my($e)=@_;
		my($p);

		$p=	&lookup($e->{'nickname'})	||
			&lookup($e->{'player'})		||
			&lookup($e->{'vaporId'})		||
			&lookup($e->{'source'})		;

		$p=$e if(	!$p					&&
				exists($e->{'nickname'})	&&
				exists($e->{'player'})	&&
				exists($e->{'vaporId'})	);

		return($p);
	}

	sub list {
		my($filter)=@_;

		if(map::left($filter)) {
			return(grep(map::left($_->{'team'}), @Players));
		} elsif(map::right($filter)) {
			return(grep(map::right($_->{'team'}), @Players));
		} elsif(map::spec($filter)) {
			return(grep(map::spec($_->{'team'}), @Players));
		} else {
			return(@Players);
		}
	}

	sub count {
		return(scalar(&list(@_)));
	}

	sub none {
		return(@Players==0);
	}

	sub values {
		my($key)=@_;

		return(map($_->{$key}, @Players));
	}

	sub admins {
		return(@Admins);
	}

}

=head2 Server to Player communication

The server will periodically communicate with users about settings, events,
and enhanced game related features.  Communication can be to all users,
teams, or to individual users.  The communication can also be for
debugging or to make funny comments.

=cut

{	package chat;

	my($Delay)=0;

	sub all {
		my($msg)=join(' ', @_);
		server::send('serverMessage', $msg);
	}

	sub team {
		my($team)=shift;
		my($msg)=join(' ', @_);
		my($any)=0;

		if(ref($team) eq 'HASH' && exists($team->{'team'})) {
			$team=$team->{'team'};
		}

		foreach my $player (player::list($team)) {
			server::send('serverWhisper', $player->{'nickname'}, $msg);
			$any=1;
		}

		ui::chat_log(map::team_symbol($team), 'server', $msg) if($any);
	}

	sub whisper {
		my($p)=shift;
		my($msg)=join(' ', @_);

		if($p->{'isBot'}) {
			ui::slog('|', $msg);
		} else {
			ui::chat_log($p->{'nickname'}, 'server', $msg);
			server::send('serverWhisper', $p->{'nickname'}, $msg);
		}
	}

	sub debug {
		my($debug)=stash::get('debug', 'server');
		my($msg);
		
		if($debug) {
			foreach my $stmt (@_) {
				if(ref($stmt)) {
					if(ref($stmt) eq 'HASH' && exists($stmt->{'nickname'})) {
						$msg.=$stmt->{'nickname'};
					} else {
						$msg.=json::encode($stmt);
					}
				} else {
					$msg.=$stmt;
				}
				$msg.=' ';
			}

			foreach my $admin (player::admins) {
				server::send('serverWhisper', $admin->{'nickname'}, $msg);
			}

			ui::chat_log('debug', 'server', $msg);

		}
	}

	sub laud {
		&all(@_) if(config::option('snarkChance')>0);
	}

	sub snark {
		my($p)=shift;
		my($time)=time();

		return if($p->{'isBot'});

		if( config::option('snarkChance')>0 && $time>$p->{'snarkGrace'} ) {
			$p->{'snarkGrace'}=$time+10;
			&all(@_);
		}
	}

	sub snarky {
		my($multiplier)=config::option('snarkChance');
		my($time)=time();

		return(0) unless($multiplier>0);
		return(0) unless(int(rand($multiplier*player::count))==0);
		return(0) unless($time>$Delay);

		$Delay=$time+3;
		return(1);
	}
}

=head2 Records

The server can keep track of records on a per-map basis.  Records will be
displayed at the completion of a map and players will be congratulated if
they make the top 5.

=cut

{	package records;

	my($Start)=0;

	sub print {
		my($records)=stash::get('records', map::name);
		my($i)=1;

		return unless(ref($records) eq 'ARRAY');

		foreach my $record (@$records) {
			chat::all(sprintf('%s : %s  (%s)',
					utils::nth($i++),
					utils::secs2mins($record->[0]),
					utils::date($record->[1]),
				));
		}
	}

	sub whisper {
		my($p)=@_;
		my($records)=stash::get('records', map::name);
		my($i)=1;

		return unless(ref($records) eq 'ARRAY');

		foreach my $record (@$records) {
			chat::whisper($p, sprintf('%s : %s  (%s)',
					utils::nth($i++),
					utils::secs2mins($record->[0]),
					utils::date($record->[1]),
				));
		}
	}

	sub mark {
		my($e)=@_;

		$Start=$e->{'time'}/$config::Clock;
	}

	sub enter {
		my($e, $winner)=@_;
		my($types)=config::option('recordsTypes');
		my($records)=stash::get('records', map::name);
		my($place)=1;
		my($time);

		return unless(map::type(split(m/[\s,;|]+/, $types)));

		$records=[] unless(ref($records) eq 'ARRAY');

		$time=sprintf("%0.1f", $e->{'time'}/$config::Clock - $Start);

		for(my $i=0; $i<@$records; $i++) {
			if($time<$records->[$i][0]) {
				splice(@$records, $i, 0, [$time, time()]);
				pop(@$records) if(@$records>5);
				last;
			} else {
				$place++;
			}
		}

		if(@$records) {
			if($place<=5) {
				push(@$records, [$time, time()]) if(@$records<$place);
				stash::set('records', map::name, $records);
			}

			chat::all('Record Times');
			chat::all('-----------------------');
			&print;

			if($place<=5) {
				chat::all('Congratulations, you placed',  utils::nth($place));
			} else {
				chat::all('you',  ':', utils::secs2mins($time));
			}
			chat::all('-----------------------');
		} else {
			stash::set('records', map::name, [[$time, time()]]);
		}
	}

	sub delete {
		my($remove)=@_;
		my($records)=stash::get('records', map::name);
		my($found)=0;

		return(0) unless(ref($records) eq 'ARRAY');

		if($remove=~m/0?(\d+):0?(\d+.\d+)/) {
			$remove=$1*60+$2;
		}

		for(my $i=0; $i<@$records; $i++) {
			if($remove == $records->[$i][0]) {
				splice(@$records, $i, 1);
				$found=1;
			}
		}

		return($found);
	}

}

=head2 Ball Games

B<alti+server> supports standard ball games and keeps track of more information
than a normal game would have.  This is used to laud good play, balance teams,
and provide slightly enhanced game play.

=cut

{	package ball;

	my(@Score)=(0, 0);
	my($Team)=map::spec;
	my($Last)=map::spec;
	my($Shot)=0;

	my($Carrier)=undef;
	my($Passer)=undef;

	my(@Relay)=();

	sub new {
		@Score=(0, 0);
		@Relay=();
		$Last=map::spec;
		$Team=map::spec;
	}

	sub reset {
		@Relay=();
		$Last=map::spec;
		$Team=map::spec;
	}

	sub update_score {
		my($team)=@_;

		if(@_==2) {
			@Score=@_;
		} elsif(map::left($team)) {
			$Score[0]++;
		} elsif(map::right($team)) {
			$Score[1]++;
		}
	}

	sub set_score {
		server::send('overrideBallScore', @_);
	}

	sub score {
		my($p)=@_;

		&update_score(map::left($p->{'team'})?'left':'right');
		&set_score(@Score);
	}

	sub shoot {
		my($e)=@_;

		$Passer=$Carrier;
		$Carrier=undef;

		if($e->{'type'} eq 'powerupUse' && $e->{'powerup'} eq 'Ball') {
			return($Shot=$e->{'time'});
		} else {
			return(undef);
		}
	}

	sub catch {
		my($e, $p)=@_;
		my($airtime)=$e->{'time'}-$Shot;

		unless($e->{'type'} eq 'powerupPickup' && $e->{'powerup'} eq 'Ball') {
			return(undef);
		}

		$Carrier=$p;

		$Last=$Team;
		$Team=$p->{'team'};

		if($Last == $Team) {
			unless($Passer == $Carrier) {
				if($airtime>900 && $airtime<2200 && chat::snarky) {
					chat::snark($p, "Nice Pass $p->{'nickname'}!");
				}
				push(@Relay, $p);
				$p->{'stats'}{'pass'}++;
			}
		} else {
			@Relay=();
		}

		return(1);
	}

	sub drop {
		$Passer=undef;
		$Carrier=undef;
	}

	sub goal {
		my($e, $p)=@_;
		my($airtime)=$e->{'time'}-$Shot;

		$Shot=0;
		$Passer=undef;
		$Carrier=undef;

		&update_score(map::side($p));

		if($airtime>3000 && $airtime<6000) {
			chat::laud("Nice Shot $p->{'nickname'}!");
		}
	}

	sub intercepted {
		if(map::spec($Last) || $Last == $Team) {
			return(undef);
		} else {
			return($Team);
		}
	}

	sub passes {
		return(scalar(@Relay));
	}

}

=head2 Altitued Plus Games

An alti+ game requires a lot of extra management.  The B<alti+server> wrapper
provides interfaces for each game.  Functions relating to maps, spawning,
game types, etc.  are available from the server wrapper.  This is the main
purpose of this server code:  to extend the possibilities of Altitude game
play though extended interfaces and server support.

=cut

{	package plus;

	my(%Stats)=();
	my(%Reset)=();
	my($Hunted)=undef;
	my($Active)=0;

	sub round {
		ball::new;		#Can ball have multiple rounds?
		#$Hunted=undef;	#Should hunted change per round?
	}

	sub active {
		my($old)=$Active;
		$Active=1;
		return($old);
	}

	sub playing {
		my($p)=@_;

		return($Stats{'players'}{'playing'}{$p});
	}

	sub leave {
		my($p)=@_;

		if($Stats{'players'}{'playing'}{$p}) {
			delete($Stats{'players'}{'playing'}{$p});
			if($Stats{'players'}{'count'}>0) {
				$Stats{'players'}{'count'}--;
			}
			return(1);
		} else {
			return(0);
		}
	}

	sub hunted {
		if(@_) {
			return($_[0] eq $Hunted);
		} else {
			return($Hunted);
		}
	}

	sub prey {
		my($p)=@_;

		if($Hunted==$p) {
			return(1);
		} elsif(!$Hunted || !$Hunted->{'alive'}) {
			$Hunted=$p;
			return(1);
		} else {
			return(0);
		}
	}

	sub cower {
		my($p)=@_;

		$Hunted=undef;
	}

	sub score {
		my($p)=@_;

		ball::score($p);
	}

	sub angle {
		my($x)=shift;
		my($y)=shift;
		my($a);

		if(@_==1) {
			$a=lc($_[0]);
		} else {
			return(utils::direction(@_));
		}

		#Accept -90, 270, 'down', or 's' to signify straight down:
		if($a eq 'up' || $a eq 'n' || $a eq 'north') {
			$a=90;
		} elsif($a eq 'down' || $a eq 's' || $a eq 'south') {
			$a=-90;
		} elsif($a eq 'left' || $a eq 'w' || $a eq 'west') {
			$a=180;
		} elsif($a eq 'right' || $a eq 'e' || $a eq 'east') {
			$a=0;
		} elsif($a eq 'ne' || $a eq 'northeast') {
			$a=45;
		} elsif($a eq 'se' || $a eq 'southeast') {
			$a=-45;
		} elsif($a eq 'sw' || $a eq 'southwest') {
			$a=-135;
		} elsif($a eq 'nw' || $a eq 'northwest') {
			$a=135;
		} elsif($a eq 'c' || $a eq 'center') {
			$a=utils::direction($map::Xmid-$x, $map::Ymid-$y);
		} elsif($a eq 'h' || $a eq 'hmirror') {
			$a=utils::direction($map::Xmid-$x, 0);
		} elsif($a eq 'v' || $a eq 'vmirror') {
			$a=utils::direction(0, $map::Ymid-$y);
		} elsif($a<=-180) {
			$a=int($a + 360);
		} elsif($a>180) {
			$a=int($a - 360);
		} else {
			$a=int($a);
		}
	}

	sub spawn_reset {
		my($p)=@_;

		if(exists($p->{'stats'}{'spawns'}) && @{$p->{'stats'}{'spawns'}}>1) {
			pop(@{$p->{'stats'}{'spawns'}});
			server::send('overrideSpawnPoint', $p->{'nickname'},
				@{$p->{'stats'}{'spawns'}[-1]}
			);
		} else {
			server::send('overrideSpawnPoint', $p->{'nickname'}, 0, 0, 0);
			delete($p->{'stats'}{'spawns'});
		}
	}

	sub spawn_here {
		my($p, $x, $y, @angle)=@_;
		my($angle)=&angle($x, $y, @angle);
		
		if(abs($angle)>90) {
			$x=POSIX::ceil($x);
		} else {
			$x=POSIX::floor($x);
		}
		if($angle<0) {
			$y=POSIX::ceil($y);
		} else {
			$y=POSIX::floor($y);
		}

		server::send('overrideSpawnPoint', $p->{'nickname'}, $x, $y, $angle);
		push(@{$p->{'stats'}{'spawns'}}, [$x, $y, $angle]);
	}

	sub clear_spawn {
		my($p)=@_;

		$Reset{$p}=1;
	}

	sub check_spawn {
		my($p)=@_;

		if(exists($Reset{$p})) {
			&spawn_reset($p);
			delete($Reset{$p});
			return(1);
		} else {
			return(0);
		}
	}

	sub spawn_near {
		my($p, $x, $y)=@_;
		my($zones)=stash::get('zones', $p->{'team'}, 'zones', map::name);
		my($spawn_mode)=stash::get('spawnMode', map::name);
		my($near, $delta, $try)=('far', 2**20, 0);

		if($spawn_mode eq 'near' && ref($zones) eq 'HASH' && %$zones) {
			foreach my $zone (sort(keys(%$zones))) {
				$try=utils::distance($x, $y, @{$zones->{$zone}}[0,1]);
				if($try<$delta) {
					$near=$zone;
					$delta=$try;
				}
			}
			&spawn_here($p, @{$zones->{$near}});
		} else {
			&spawn_reset($p);
		}

	}

	sub bench {
		my($p)=@_;

		if(map::mode('ffa')) {
			chat::whisper($p, 'Players cannot be forced to respawn in FFA');
		} elsif(map::left($p->{'team'})) {
			server::send('assignTeam', $p->{'nickname'}, 0);
		} elsif(map::right($p->{'team'})) {
			server::send('assignTeam', $p->{'nickname'}, 1);
		} else {
			server::send('assignTeam', $p->{'nickname'}, -1);
		}
	}

	sub no_repeats {
		my($e, $p)=@_;
		my($pickup)=join(',', @$e{'positionX','positionY'});
		my($time)=$e->{'time'};

		if($time<$p->{'stats'}{'timer'}{$pickup}) {
			return(0);
		} else {
			$p->{'stats'}{'timer'}{$pickup}=$time+800;
			return(1);
		}
	}

	sub capture {
		my($e, $p)=@_;
		my($pickup)=join(',', @$e{'positionX','positionY'});
		my($flag)=stash::get($pickup, $p->{'team'}, 'powerups', map::name);

		if($flag && no_repeats($e, $p)) {
			unless(map::mode('ffa')) {
				foreach my $player (player::list) {
					plus::bench($player);
				}
			}
			chat::all($p->{'nickname'}, 'captured the flag!');
			$p->{'stats'}{'capture'}++;
			plus::score($p);
		}
	}

	sub checkpoint {
		my($e, $p)=@_;
		my($pickup)=join(',', @$e{'positionX','positionY'});
		my($checkpoints)=stash::get($p->{'team'}, 'powerups', map::name);
		my($cp)=$checkpoints->{$pickup};
		my($teamstats, $t_all, $t_lap, $p_all, $p_lap);

		return unless(defined($cp));

		#Initialize team stats:
		unless($Stats{$p->{'team'}}{'cp'}) {
			foreach my $key (values(%$checkpoints)) {
				$Stats{$p->{'team'}}{'cp'}{$key}=0;
			}
		}

		#Initialize player stats:
		unless($p->{'stats'}{'cp'}) {
			foreach my $key (values(%$checkpoints)) {
				$p->{'stats'}{'cp'}{$key}=0;
			}
		}

		$teamstats=$Stats{$p->{'team'}}{'cp'};
		($t_all, $t_lap)=utils::minmax(values(%$teamstats));
		($p_all, $p_lap)=utils::minmax(values(%{$p->{'stats'}{'cp'}}));

		if($p->{'stats'}{'cp'}{$cp}<$p_lap || $p_all==$p_lap) {
			$p->{'stats'}{'cp'}{$cp}++;
		}

		if(&no_repeats($e, $p) && $p_lap==$t_lap &&
		  ($teamstats->{$cp}<$t_lap || $t_all==$t_lap)) {
			chat::all($p->{'nickname'}, 'reached checkpoint', $cp);
			plus::score($p);
			$teamstats->{$cp}++;
			$p->{'stats'}{'checkpoint'}++;
		}
	}

	sub door_open {
		my($p, $door)=@_;
		my($team)=$p->{'team'};

		return(
			$Stats{$p}{$team}{'door'}{$door}
			||  $Stats{$team}{'door'}{$door}
		);
	}

	sub zone_open {
		my($p, $zone)=@_;
		my($team)=$p->{'team'};

		return(
			$Stats{$p}{$team}{'zone'}{$zone}
			||  $Stats{$team}{'zone'}{$zone}
		);
	}

	sub key_found {
		my($p, $key)=@_;
		my($team)=$p->{'team'};

		return(
			$Stats{$p}{$team}{'key'}{$key}
			||  $Stats{$team}{'key'}{$key}
		);
	}


	sub zone_init {
		my($p)=@_;
		my($zones)=stash::get('zones', map::name);
		my($stats);

		if($p) {
			$stats=$Stats{$p};
			return if(exists($stats->{map::left}{'zones'}));
		} else {
			$stats=\%Stats;
		}

		foreach my $team (keys(%$zones)) {
			#Initialize all zones to open:
			foreach my $name (keys(%{$zones->{$team}{'zones'}})) {
				$stats->{$team}{'zone'}{$name}=1;
			}

			#If a zone has a key, close it:
			foreach my $name (values(%{$zones->{$team}{'keys'}})) {
				$stats->{$team}{'zone'}{$name}=0;
			}
		}
	}

	sub key {
		my($e, $p)=@_;
		my($door)=stash::get($p->{'team'}, 'door', map::name);
		my($zone)=stash::get($p->{'team'}, 'zones', map::name);
		my($personal)=stash::get('keys', map::name) & 1;
		my($pickup)=join(',', @$e{'positionX','positionY'});
		my($keys, $color);

		if($door->{'doors'}{$pickup} && &no_repeats($e, $p)) {
			unless(&door_open($p, $door->{'doors'}{$pickup})) {
				plus::bench($p);
				chat::whisper($p, $door->{'doors'}{$pickup}, 'is locked');
			}

			return(1);
		} elsif($door->{'keys'}{$pickup} && &no_repeats($e, $p)) {
			if(&door_open($p, $door->{'keys'}{$pickup})) {
				return(0);
			}

			if(&key_found($p, $pickup)) {
				return(0);
			} else {
				chat::team($p, $p->{'nickname'}, 'found a key to door:', $door->{'keys'}{$pickup});
				if($personal) {
					$Stats{$p}{$p->{'team'}}{'key'}{$pickup}=1;
				} else {
					$Stats{$p->{'team'}}{'key'}{$pickup}=1;
					$p->{'stats'}{'keys'}++;
				}
			}

			$keys=utils::invert(stash::get('keys', $p->{'team'}, 'door', map::name));

			foreach my $key (@{$keys->{$door->{'keys'}{$pickup}}}) {
				unless(&key_found($p, $key)) {
					return(0);
				}
			}

			if($personal) {
				$Stats{$p}{$p->{'team'}}{'door'}{$door->{'keys'}{$pickup}}=1;
				chat::whisper($p, 'Door unlocked:', $door->{'keys'}{$pickup});
			} else {
				$Stats{$p->{'team'}}{'door'}{$door->{'keys'}{$pickup}}=1;
				chat::team($p, 'Door unlocked:', $door->{'keys'}{$pickup});
			}

		} elsif($zone->{'keys'}{$pickup} && &no_repeats($e, $p)) {
			if(&zone_open($p, $zone->{'keys'}{$pickup})) {
				return(0);
			}

			if(&key_found($p, $pickup)) {
				return(0);
			} else {
				chat::team($p, $p->{'nickname'}, 'found a key to zone:', $zone->{'keys'}{$pickup});
				if($personal) {
					$Stats{$p}{$p->{'team'}}{'key'}{$pickup}=1;
				} else {
					$Stats{$p->{'team'}}{'key'}{$pickup}=1;
					$p->{'stats'}{'keys'}++;
				}
			}

			$keys=utils::invert(stash::get('keys', $p->{'team'}, 'zones', map::name));

			foreach my $key (@{$keys->{$zone->{'keys'}{$pickup}}}) {
				unless(&key_found($p, $key)) {
					return(0);
				}
			}

			if($personal) {
				$Stats{$p}{$p->{'team'}}{'zone'}{$zone->{'keys'}{$pickup}}=1;
				chat::whisper($p, 'Zone unlocked:', $zone->{'keys'}{$pickup});
			} else {
				$Stats{$p->{'team'}}{'zone'}{$zone->{'keys'}{$pickup}}=1;
				chat::team($p, 'Zone unlocked:', $zone->{'keys'}{$pickup});
			}
		}

		return(0);
	}

	sub divert {
		my($e, $p)=@_;
		my($pickup)=join(',', @$e{'positionX','positionY'});
		my($other)=stash::get($pickup, 'diverters', map::name);

		return unless($other);

		if($Stats{'diverters'}{$pickup}) {
			chat::whisper($p, 'Wrong diverter');
			plus::bench($p);
		} else {
			$Stats{'diverters'}{$pickup}=1;
			$Stats{'diverters'}{$other}=0;
		}
	}

	sub teleport {
		my($e, $p)=@_;
		my($pickup)=join(',', @$e{'positionX','positionY'});
		my($portal)=stash::get($pickup, 'portals', map::name);

		return(0) unless($portal);

		&bench($p);
		&spawn_here($p, @$portal[1,2,3]);

		chat::whisper($p, 'Teleporting you to:', $portal->[0]);

		return(1);
	}

	sub most {
		my($text, $stats, $players)=@_;
		my($most)=0;
		my($start)=0;
		my($p);

		for(my $i=0; $i<@$players; $i++) {
			$p=player::lookup($players->[$i]);
			last unless($p->{'isBot'});
			$start++;
		}

		for(my $i=$start; $i<@$players; $i++) {
			if($stats->[$i]>=$stats->[$most]) {
				$p=player::lookup($players->[$i]);
				$most=$i unless($p->{'isBot'});
			}
		}

		if($stats->[$most]>0) {
			$p=player::lookup($players->[$most]);
			chat::all($text, $p->{'nickname'}) unless($p->{'isBot'});
		}
	}

	sub enter {
		my($p)=@_;
		my($max)=stash::get('maxPlayers', map::name) || $config::Maxp;

		if($Stats{'players'}{'playing'}{$p}) {
			return(1);
		} elsif($Stats{'players'}{'count'}<$max) {
			&zone_init($p) if(stash::get('keys', map::name) & 1);
			$Stats{'players'}{'playing'}{$p}=1;
			$Stats{'players'}{'count'}++;
			return(1);
		} else {
			return(0);
		}
	}

	sub new {
		%Stats=();
		%Reset=();
		$Hunted=undef;
		$Active=0;

		foreach my $player (player::list) {
			delete($player->{'team'});
		}

		&zone_init() unless(stash::get('keys', map::name) & 1);
	}

}

=head2 Downloading Maps

The B<alti+server> allows admin users access to download maps and restart
the server on-the-fly.  Great care is taken to ensure this can be done in
a secure way.  All file opens either use L<IPC::Open3> or perl's built-in
3+ argument C<open> function.  Additionally, file names and URL's are
reviewed for odd or special characters.

Besides security, a number of functions are available to map makers to
facilitate in map download and verifications.  Map makers have access
to added server commands like C<cksum> for 32-bit checksums, and C<md5>,
C<sha1>, and C<sha256> for stronger checksums.  Also, are download functions
which support scanning the L<http://altitudegame.com/map> web pages for 
easy map downloads.  Maps stored on this server can be downloads simply
with their name.

=cut

{	package file;

	my($Curl)=utils::which('curl', 'good', 'map uploads not possible');

	sub sum {
		my($sum, $file)=@_;
		my($cmd)=IO::Handle->new;
		my($output);

		open($cmd, '-|', $sum, $file);
		chomp($output=$cmd->getline);
		close($cmd);

		$output=~s/\s+\S+$//;

		return($output);
	}

	sub type {
		my($file)=@_;
		my($cmd)=IO::Handle->new;
		my($type);

		open($cmd, '-|', 'file', $file);
		chomp($type=$cmd->getline);
		close($cmd);

		return($type);
	}

	sub update_ctime {
		my($map)=@_;
		my(@st)=stat($map);

		chmod($st[2]&0777, $map);
	}

	sub name_ok {
		local($_)=@_;
		my($mapdir)=config::option('mapDir');

		s|^$INSTALL_ROOT/maps/$mapdir/*||;
		s|^$mapdir/*||;

		return(0) unless(m/^[\w.?!%:=+-]{5,}$/);
		return(0) unless(m/^(1bd|1de|1dm|ball|ffa|tbd|tdm)_|^lobby/);
		return(0) if(m/\.\./);

		return(1);
	}

	sub url_ok {
		local($_)=@_;

		return(0) if(m/\.\./);
		if(m|^file:///var/tmp/([\w.?!%:=+-]+\.altx)|) {
			return(0)	unless(&name_ok($1));
		} else {
			return(0) unless(m/^(https?|ftps?):\/\/[\w.-]+\/[\w.;&?!%:\/=+-]*$/i);
		}

		return(1);
	}

	sub download {
		my($in, $out, $err)=(IO::Handle->new, IO::Handle->new, IO::Handle->new);
		my($eout);
		my($pid);

		ui::slog($Curl, @_);

		return(0) unless($Curl);
		return(0) unless(&url_ok($_[-1]));

		$pid=IPC::Open3::open3($in, $out, $err,
			$Curl, '-s', '--max-filesize', config::option('ulSizeLimit'), @_);

		$_=join('', <$out>);

		while($eout=<$err>) {
			chomp($eout);
			ui::slog($eout);
		}

		close($in);
		close($out);
		close($err);

		waitpid($pid, 0);
	}

	sub altigame_download {
		my($file, $name)=@_;
		my($url)='https://altitudegame.com/map/?p=';
		local($_);

		return(0) unless(&name_ok($file));
		return(0) unless(&name_ok($name));

		foreach my $i (0 .. 25) {
			&download("$url$i");

			if(m|<a +href=".*?" *>\Q$name\E</a>.*?<a +href="(.*?)" *>download</a>|) {
				&download('-L', '-o', $file, $1);

				if(-s $file) {
					return(1);
				} else {
					unlink($file);
					return(0);
				}
			}
		}
		return(0);
	}
}

=head2 Normalized Hook Management

The B<alti+server> makes supporting log hooks easier by normalizing the
hook arguments.  Each hook is called with two arguments: the event data
structure, and the person data structure for the player in question.  Most
hooks would otherwise have to have code to lookup a player from the event
details.  This method eliminates that, and provides for less overall code.

=cut

sub event {
	my($event)=@_;
	my($player)=undef;
	
	unless($config::Clock==1000) {
		$event->{'time'}*=1000/$config::Clock;
	}

	if($event->{'group'} eq 'server') {
		$player=player::server;
	} else {
		$player=player::event_search($event);
	}

	if($event->{'group'} eq 'server') {
		$event->{'admin'}=1;
		$event->{'superAdmin'}=1;
	} elsif($event->{'group'} eq 'Administrator') {
		$event->{'admin'}=1;
		if(config::option('superAdmin') eq 'list') {
			$event->{'superAdmin'}=$player->{'superAdmin'};
		} else {
			$event->{'superAdmin'}=1;
		}
	} else {
		$event->{'admin'}=0;
		$event->{'superAdmin'}=0;
	}

	return($event, $player);
}

=head2 Snarky Server Responses

The B<alti+server> will periodically emit snarky comments about player's
choices of planes, perks, or skins.  This is, of course, as long as the
C<snarkChance> flag is set to a true value in the C<OPTIONS> configuration at
the top of the B<alti+server> code file.  The server will take the value of
C<snarkChance> and multiply it by the number of players.  Then, for each
even which has snarks associated with it, there will be a 1 in that many
chance of a snarky comment being made.

These are not meant to be a large distraction from the game, but instead to
make players chuckle.  The comments should be infrequent.

Setting C<snarkChance> to 0 will also disable server lauds.  These are
congratulations for a pass, nice goal, etc.  If C<snarkChance> is set to
a non-zero value, these laudable activities are mentioned for each occurance.
Frankly, people don't pass enough, this is enabled to try to coax more
and better passing in the game.

=cut

my(%SNARKS)=(
	"%s, pick a nick already!"
			=> { 'nickname'=> 'Guest_' },

	"%s can't aim"
			=> { 'perkRed' => 'Tracker' },

	"%s is toxic"
			=> { 'perkRed' => 'Acid Bomb' },

	"%s likes to drop bombs on your head"
			=> { 'perkRed' => 'Bombs' },

	"I wouldn't fly behind %s"
			=> { 'perkRed' => 'Flak Tailgun' },

	"%s's other vehicle is a DeLorean"
			=> { 'perkRed' => 'Time Anchor' },

	"%s dares you to fly near a wall"
			=> { 'perkRed' => 'Director|Thermobarics' },

	"%s says rat-tat-tat-tat-tat"
			=> { 'perkRed' => 'Recoilless Gun' },

	"%s brought out the big gun"
			=> { 'perkRed' => 'Heavy Cannon' },

	"%s bounces, but recovers well"
			=> { 'perkGreen' => 'Rubberized Hull' },

	"%s can turn on a dime"
			=> { 'perkGreen' => 'Flexible Wings' },

	"%s needs a backup camera"
			=> { 'perkBlue' => 'Reverse Thrust' },

	"%s is an ace"
			=> { 'perkBlue' => 'Ace Instincts' },

	"%s says Grrrr"
			=> { 'skin' => 'Shark Skin' },

	"%s is on fire"
			=> { 'skin' => 'Flame Skin' },

	"%s is trying to hide"
			=> { 'skin' => 'Zebra Skin' },

	"%s, how about a nice game of chess?"
			=> { 'skin' => 'Checker Skin' },

	"%s says Ho Ho Ho!"
			=> { 'skin' => 'Santa Hat' },

	"You know, I have one simple request.  And that is to have sharks with frickin' laser beams attached to their heads!"
			=> { 'skin' => 'Shark Skin', 'perkRed' => 'Laser' },
);

=head2 Levels

The default Altitude level check is equal to any Ace level.  This might not
work for all servers.  B<alti+server> allows you to specify a different
milestone for Ace 0 players vs Ace 1-10 players.  This allows for keeping
games competitive, and also serves to discourage smurfing.

=cut

my(%MILESTONES)=(
	2	=> 'green perk',
	6	=> 'bomber',
	8	=> 'blue perk',
	11	=> 'whale',
	13	=> 'heavy armor',
	16	=> 'bip',
	18	=> 'ultracapacitor',
	21	=> 'all planes',
	24	=> 'double fire',
	27	=> 'dumb bombs',
	30	=> 'repair',
	32	=> 'thermobarics',
	35	=> 'recoiless gun',
	38	=> 'laser',
	41	=> 'rev',
	44	=> 'acid',
	47	=> 'flak gun',
	50	=> 'flexi-wings',
	53	=> 'remote',
	56	=> 'heavy cannon',
	58	=> 'time anchor',
	60	=> 'all perks'
);

=head2 Log Parsing and Hooks

The main interface for B<alti+server> to see what is going on with the
Altitude game engine is the F<log.txt> file.  B<alti+server> reads this
file continuously and interprets the entries.  Hooks are considered to be
any of the following:

=over 8

=item type="x"

These are events generated directly by the Altitude game engine.  They
can be events which happened in a game, notifications about changes, or
the result of a user request.  A hook name of C<x> will be executed
each type an event of type="x" is seen in the log file.

=item command="y" type="consoleCommandExecute"

These are events generated either by players or by the B<alti+server> code
itself.  This is the method by which B<alti+server> supports commands
added to the F<custom_json_commands.txt> file.  Each time a log entry is
made where command="y", the hook named C<y> will be executed.

=item type="x" when triggered by hook "z"

The B<alti+server> contains it's own trigger mechanism.  Not all commands
execute by players, the server, or events thrown by the Altitude game engine
contain enough information to complete a request.  In these cases, the
hook code for C<z> will generate a request for the server to execute an
additional command C<x>.  When C<x> is run, B<alti+server> looks for a hook
named C<x:z>, and runs it instead of the normally defined hook for C<x>.
The triggered code will then complete the original request with information
from both the original hook C<z>, and the new one C<x>.

=back

=head2 Game Extensions

Some of the extensions provided by the B<alti+server> are:

=over 8

=item Messaging

Users can utilize the server to facilitate private communication.  The main
purpose of this is for map makers to offer suggestions to players testing
out a map.  Also, this works well in reverse.  If a player would like to
bring up a point regarding game play private to the map map maker.  In case
of abuse, users can disable this feature.

=item Managed Map Downloads

The server supports 3 methods to download new maps.  People often store maps
on the altitudegame.com/map/ (the original map testing) site; maps can be
downloads from here with just their name.  Another location where maps are
often stored are on the Ladder servers, here maps can also be downloaded
by name.  Finally, for other maps a download method for arbitrary URLs is
supported; this method will not work for javascript enabled downloads.
Conversely, a method also exists to remove maps from the server.

=item Map Specific Settings

Each map can have its own gravity, scale, team enforcement, spawn location,
etc. settings.  Hooks exist for adding/changing/deleting these settings 
on a per-map basis.  Each time a new map loads, these settings are made
by B<alti+server>, so the game can be played as designed each time without
user interaction.

=item Spawn Enhancements

A number of spawn possibilities are created by B<alti+server>.  Players
can spawn normally as always.  However, the additional methods are also
available:
died (players spawn where they last died),
zone (players can manually choose the location where they spawn),
near (players spawn at the nearest defined zone location to where they die),
portal (players use any number of listed health powerups and are respawned in a different location), 
health (players spawn at the location where they pickup their last health),
powerup (players spawn where they picked up their last powerup of any kind).

=item Plane Limitations

A map can have only specified plane types allowed.  This is helpful in certain
"capture the flag" game types, where by whales can wildly disrupt the inner
core protecting the flag.

=back

=cut

%HOOKS=(
	'!'			=> sub {	#Admin command for tiny_custom_json_commands.txt
		my($e, $p)=@_;
		my($args)=@{$e->{'arguments'}};
		my(@params);

		unless($e->{'admin'}) {
			chat::whisper($p, 'You are not an admin');
			return;
		}

		if($args=~s/^\s*(\S+)\s*//) {
			$e->{'command'}=$1;
			$e->{'arguments'}=[];
			@params=config::arguments($e->{'command'});
		} else {
			chat::whisper($p, 'Empty command ignored');
			return;
		}

		while(@params>1) {
			if($args=~s/^\s*(".*?"|".*$|\S+)\s*//) {
				push(@{$e->{'arguments'}}, $1);
				$e->{'arguments'}[-1]=~s/^"//;
				$e->{'arguments'}[-1]=~s/"$//;
				shift(@params);
			} else {
				chat::whisper($p, 'Missing arguments:', $e->{'command'});
				return;
			}
		}
		push(@{$e->{'arguments'}}, $args) if($args);

		if(exists($HOOKS{$e->{'command'}})) {
			$HOOKS{$e->{'command'}}->($e, $p);
		} else {
			chat::whisper($p, 'Invalid command:', $e->{'command'});
		}
	},

	'help'		=> sub {
		my($e, $p)=@_;
		my($type)=@{$e->{'arguments'}};

		if(exists($HOOKS{"help $type"})) {
			$HOOKS{"help $type"}->($e, $p);
			if(config::commands('!')) {
				chat::whisper($p, 'Admin commands use `/! cmd ...` syntax');
			}
		} else {
			config::command_help($p, 'help');
		}
	},

	'list'		=> sub {
		my($e, $p)=@_;
		my($type)=@{$e->{'arguments'}};

		if(exists($HOOKS{"list $type"})) {
			$HOOKS{"list $type"}->($e, $p);
		} else {
			config::command_help($p, 'list');
		}
	},

	'set'		=> sub {
		my($e, $p)=@_;
		my($type, $args)=@{$e->{'arguments'}};
		my(@args);

		if($type=~m/intro/) {
			@args=($args);
		} else {
			@args=($args=~m/(".*?"|".*$|[^\s,]+)/g);
		}

		return unless($e->{'admin'});

		if(exists($HOOKS{"set $type"})) {
			$HOOKS{"set $type"}->($e, $p, @args);
		} else {
			config::command_help($p, 'set');
		}
	},

	'unset'		=> sub {
		my($e, $p)=@_;
		my($type)=@{$e->{'arguments'}};

		return unless($e->{'admin'});

		if(exists($HOOKS{"unset $type"})) {
			$HOOKS{"unset $type"}->($e, $p);
		} else {
			config::command_help($p, 'unset');
		}
	},

	'add'		=> sub {
		my($e, $p)=@_;
		my($type, $args)=@{$e->{'arguments'}};
		my(@args);

		@args=($args=~m/(".*?"|".*$|[^\s,]+)/g);

		return unless($e->{'admin'});

		if(exists($HOOKS{"add $type"})) {
			$HOOKS{"add $type"}->($e, $p, @args);
		} else {
			config::command_help($p, 'add');
		}
	},

	'del'		=> sub {
		my($e, $p)=@_;
		my($type, $args)=@{$e->{'arguments'}};
		my(@args);

		@args=($args=~m/(".*?"|".*$|[^\s,]+)/g);

		return unless($e->{'admin'});

		if(exists($HOOKS{"del $type"})) {
			$HOOKS{"del $type"}->($e, $p, @args);
		} else {
			config::command_help($p, 'del');
		}
	},

	'upload'		=> sub {
		my($e, $p)=@_;
		my($type, $args)=@{$e->{'arguments'}};
		my(@args);

		@args=($args=~m/(".*?"|".*$|\S+)/g);

		return unless($e->{'superAdmin'});

		if(exists($HOOKS{"upload $type"})) {
			$HOOKS{"upload $type"}->($e, $p, @args);
		} else {
			config::command_help($p, 'upload');
		}
	},

	'switch'	=> sub {
		my($e, $p)=@_;

		if(map::mode('ffa')) {
			chat::whisper($p, '/switch does not function in ffa');
		} elsif($p->{'carrier'}) {
			chat::whisper($p, 'You cannot /switch as a carrier');
		} else {
			server::send('assignTeam', $p->{'nickname'}, -1);
			chat::whisper($p, 'Spectating, press `t` to join a team');
		}
	},

	'mesg'	=> sub {
		my($e, $p)=@_;
		local($_)=$e->{'arguments'}[0];

		if(m/y(es)?/i) {
			stash::delete('block', $p->{'nickname'});
			chat::whisper($p, "Private on-server messaging enabled");
		} elsif(m/no?/i) {
			stash::set('block', $p->{'nickname'}, 1);
			chat::whisper($p, "Private on-server messaging disabled");
		} else {
			if(stash::get('block', $p->{'nickname'})) {
				chat::whisper($p, "Private on-server messaging disabled");
			} else {
				chat::whisper($p, "Private on-server messaging enabled");
			}
		}
	},

	'vote'	=> sub {
		my($e, $p)=@_;
		my($command)=shift(@{$e->{'arguments'}});
		our($kicker, $kickee);

		if(config::option('bullyKick') && $command eq 'kick') {
			$kicker=$p;
			$kickee=shift(@{$e->{'arguments'}});
			player::infraction($p, 1);
		}
	},

	'kick'	=> sub {
		my($e, $p)=@_;
		my($nick)=shift(@{$e->{'arguments'}});
		our($kicker, $kickee);

		if($nick eq $kickee && ref($kicker) eq 'HASH') {
			player::forgive($kicker);
			undef($kicker);
		}
	},

	'talk'	=> sub {
		my($e, $p)=@_;
		my($to)=player::lookup(shift(@{$e->{'arguments'}}));
		my($msg)=join(' ', @{$e->{'arguments'}});

		if(config::language($msg)) {
			chat::whisper($p, "message not sent");
			chat::whisper($p, 'language(', player::infraction($p, 1), ')');
		} elsif($p->{'nickname'} eq 'server') {
			chat::whisper($to, $msg);
		} elsif(!stash::get('block', $to->{'nickname'})) {
			ui::chat_log($to->{'nickname'}, $p->{'nickname'}, $msg);
			server::send('serverWhisper', $to->{'nickname'}, "$p->{'nickname'}> $msg");
		} else {
			chat::whisper($p, "private messaging is disabled for $to->{'nickname'}");
		}
		
	},

	'help altitudegame'	=> sub {
		my($e, $p)=@_;
		chat::whisper($p, '/upload altitudegame <map>');
		chat::whisper($p, ' map: name is exactly as it appears on the website');
		chat::whisper($p, ' Upload maps FROM http://altitudegame.com/map/');
	},

	'upload altitudegame'	=> sub {
		my($e, $p, $name)=@_;
		my($mapdir)=config::option('mapDir');
		my($maps)="$INSTALL_ROOT/maps/$mapdir";
		my($mapname, $file, $mapconfig);

		$name=~s|^$mapdir/*|| if($mapdir);
		$name=~s|\.altx$||;
		$name=~s|\s+|_|g;

		unless(file::name_ok($name)) {
			chat::whisper($p, "map name $name does not follow standard");
			return(0);
		}

		if($mapdir) {
			$mapname="$mapdir/$name";
		} else {
			$mapname=$name;
		}
		$file="$maps/$mapname.altx";

		if(file::altigame_download($file, $name)) {
			if(-s $file > config::option('ulSizeLimit')) {
				unlink($file);
				chat::whisper($p, "$mapname too big");
			} elsif(file::type($file)!~m/LZMA compressed data/) {
				unlink($file);
				chat::whisper($p, "$mapname is not the right type");
				chat::whisper($p, "maybe redirect failure, or a javascript enabled download");
			} else {
				if(config::new_maps($mapname)) {
					chat::whisper($p,
						"Map added to config, you must /restartServer");

					if($mapconfig=stash::retrieve($mapname)) {
						stash::set($mapname, $mapconfig);
					}
				}
				chat::all("$mapname updated");
			}
		} else {
			chat::whisper($p, "Could not download $name from altitudegame.com/map/");
		}
	},

	'help official'	=> sub {
		my($e, $p)=@_;
		chat::whisper($p, '/upload ladder <map>');
		chat::whisper($p, ' map: name of official map');
		chat::whisper($p, ' Upload maps FROM http://maps.altitudegame.com/');
	},

	'upload official'	=> sub {
		my($e, $p, $name)=@_;
		my($mapdir)=config::option('mapDir');
		my($maps)="$INSTALL_ROOT/maps/$mapdir";
		my($url)="http://maps.altitudegame.com/";
		my($mapname, $file, $key, $mapconfig);
		local($_);

		$name=~s|^$mapdir/*|| if($mapdir);
		$name=~s|\.altx$||;
		$name=~s|\s+|_|g;

		unless(file::name_ok($name)) {
			chat::whisper($p, "map name $name does not follow standard");
			return(0);
		}

		if($mapdir) {
			$mapname="$mapdir/$name";
		} else {
			$mapname=$name;
		}
		$file="$maps/$mapname.altx";

		file::download($url);
		unless(($key)=m|<Key>([0-9.]+/$name.altx)</Key>|i) {
			chat::whisper($p, "$name not indexed on maps.altitudegame.com");
			return(0);
		}
		
		file::download('-L', '-o', $file, $url.$key);

		if(-s $file < 1024) {
			unlink($file);
			chat::whisper($p, "Could not find $name on maps.altitudegame.com");
		} elsif(-s $file > config::option('ulSizeLimit')) {
			unlink($file);
			chat::whisper($p, "$mapname too big");
		} elsif(file::type($file)!~m/LZMA compressed data/) {
			unlink($file);
			chat::whisper($p, "$mapname is not the right type, download failure");
		} else {
			if(config::new_maps($mapname)) {
				chat::whisper($p,
					"Map added to config, you must /restartServer");

				if($mapconfig=stash::retrieve($mapname)) {
					stash::set($mapname, $mapconfig);
				}
			}
			chat::all("$mapname updated");
		}
	},

	'help ladder'	=> sub {
		my($e, $p)=@_;
		chat::whisper($p, '/upload ladder <map>');
		chat::whisper($p, ' map: name is exactly as it when running in ladder');
		chat::whisper($p, ' Upload maps FROM http://altituderank.com/mapdownloads/');
	},

	'upload ladder'	=> sub {
		my($e, $p, $name)=@_;
		my($mapdir)=config::option('mapDir');
		my($maps)="$INSTALL_ROOT/maps/$mapdir";
		#my($url)="http://altituderank.com/mapdownloads/%s.altx";
		my($url)="http://maps.planeball.com/%s.altx";
		my($mapname, $file, $mapconfig);

		$name=~s|^$mapdir/*|| if($mapdir);
		$name=~s|\.altx$||;
		$name=~s|\s+|_|g;

		unless(file::name_ok($name)) {
			chat::whisper($p, "map name $name does not follow standard");
			return(0);
		}

		if($mapdir) {
			$mapname="$mapdir/$name";
		} else {
			$mapname=$name;
		}
		$file="$maps/$mapname.altx";

		file::download('-L', '-o', $file, sprintf($url, $name));

		if(-s $file < 1024) {
			unlink($file);
			chat::whisper($p, "Could not find $name on altituderank.com/mapdownloads/");
		} elsif(-s $file > config::option('ulSizeLimit')) {
			unlink($file);
			chat::whisper($p, "$mapname too big");
		} elsif(file::type($file)!~m/LZMA compressed data/) {
			unlink($file);
			chat::whisper($p, "$mapname is not the right type");
			chat::whisper($p, "maybe redirect failure, or a javascript enabled download");
		} else {
			if(config::new_maps($mapname)) {
				chat::whisper($p,
					"Map added to config, you must /restartServer");

				if($mapconfig=stash::retrieve($mapname)) {
					stash::set($mapname, $mapconfig);
				}
			}
			chat::all("$mapname updated");
		}
	},

	'help tinyupload'		=> sub {
		my($e, $p)=@_;
		chat::whisper($p, '/upload tinyupload <key>');
		chat::whisper($p, ' key: 20 digit file_id decimal key');
		chat::whisper($p, ' You only need to enter key after "file_id"');
	},

	'upload tinyupload'		=> sub {
		my($e, $p, $key)=@_;
		my($mapdir)=config::option('mapDir');
		my($maps)="$INSTALL_ROOT/maps/$mapdir";
		my($url)='http://s000.tinyupload.com/';
		my($name, $next, $mapname, $file, $mapconfig);
		local($_);

		return(0) unless($key=~m/^\d+$/);

		file::download("$url?file_id=$key");

		($next, $name)=m|<a href="(download.php.*?)"><b>(\w+).altx</b></a>|i;

		$name=~s|\s+|_|g;

		return(0) unless(file::name_ok($name));
		return(0) unless(file::url_ok("$url$next"));

		if($mapdir) {
			$mapname="$mapdir/$name";
		} else {
			$mapname=$name;
		}
		$file="$maps/$mapname.altx";

		file::download('-L', '-o', $file, "$url$next");

		if($name) {
			if(-s $file > config::option('ulSizeLimit')) {
				unlink($file);
				chat::whisper($p, "$mapname too big");
			} elsif(file::type($file)!~m/LZMA compressed data/) {
				unlink($file);
				chat::whisper($p, "$mapname is not the right type");
				chat::whisper($p, "maybe redirect failure, or a javascript enabled download");
			} else {
				if(config::new_maps($mapname)) {
					chat::whisper($p,
						"Map added to config, you must /restartServer");

					if($mapconfig=stash::retrieve($mapname)) {
						stash::set($mapname, $mapconfig);
					}
				}
				chat::all("$mapname updated");
			}
		} else {
			chat::whisper($p, "Could not download $name from tinyupload.com");
		}
	},

	'help url'		=> sub {
		my($e, $p)=@_;
		chat::whisper($p, '/upload url <map> <url>');
		chat::whisper($p, ' map: name exactly as you want it to appear in the game');
		chat::whisper($p, ' url: the full URL (incld http://) of the map. Javascript enabled downloads do not work.');
	},

	'upload url'		=> sub {
		my($e, $p, $name, $url)=@_;
		my($mapdir)=config::option('mapDir');
		my($maps)="$INSTALL_ROOT/maps/$mapdir";
		my($mapname, $file, $mapconfig);

		$name=~s|^$mapdir/*|| if($mapdir);
		$name=~s|\.altx$||;
		$name=~s|\s+|_|g;

		return(0) unless(file::name_ok($name));
		return(0) unless(file::url_ok($url));

		if($mapdir) {
			$mapname="$mapdir/$name";
		} else {
			$mapname=$name;
		}
		$file="$maps/$mapname.altx";

		file::download('-L', '-o', $file, $url);

		if(-s $file > config::option('ulSizeLimit')) {
			unlink($file);
			chat::whisper($p, "$mapname too big");
		} elsif(file::type($file)!~m/LZMA compressed data/) {
			unlink($file);
			chat::whisper($p, "$mapname is not the right type");
			chat::whisper($p, "maybe redirect failure, or a javascript enabled download");
		} else {
			if(config::new_maps($mapname)) {
				chat::whisper($p,
					"Map added to config, you must /restartServer");

				if($mapconfig=stash::retrieve($mapname)) {
					stash::set($mapname, $mapconfig);
				}
			}
			chat::all("$mapname updated");
		}
	},

	#
	## Change map to random map as requested by players/admin
	'randomMap' => sub {
		my ($e, $p) = @_;
		server::send('changeMap', config::random_map);
	},

	'removeMap'		=> sub {
		my($e, $p)=@_;
		my($mapdir)=config::option('mapDir');
		my($maps)="$INSTALL_ROOT/maps/$mapdir";
		my($mapname, $file);

		return(0) unless($e->{'superAdmin'});

		$e->{'arguments'}[0]=~s|^$mapdir/*|| if($mapdir);
		$e->{'arguments'}[0]=~s|\.altx$||;
		$e->{'arguments'}[0]=~s|\s+|_|g;

		return(0) unless(file::name_ok($e->{'arguments'}[0]));

		$mapname="$mapdir/$e->{'arguments'}[0]";
		$mapname=~s|^/+||;
		$file="$maps/$mapname.altx";

		if(-r $file) {
			if(map::name($mapname)) {
				server::send('changeMap', config::random_map)
			}

			stash::archive($mapname);

			unlink($file);

			#Should we be cleaning up the cache and server-unpacked-maps.xml?

			if(config::remove_maps($mapname)) {
				chat::whisper($p,
					"Map removed from config, you must /restartServer");
			}
			chat::all("$mapname deleted");
		}
	},

	'help map'	=> sub {
		my($e, $p)=@_;
		chat::whisper($p, '/list map');
		chat::whisper($p, 'List the name and settings for the current map');
		chat::whisper($p, 'alti+server version:', $VERSION);
	},

	'list map'	=> sub {
		my($e, $p)=@_;
		my(@settings)=qw(
			ballScore
			gravity
			weapons
			spawnHealth
			cameraScale
			planeScale
			assignTeam
			planes
			spawnMode
			changePlane
			keys
			maxPlayers
			gameType
			intro
		);

		chat::whisper($p, 'Name:', map::name);

		foreach my $setting (@settings) {
			$HOOKS{"list $setting"}->($e, $p)
				if(exists($HOOKS{"list $setting"}));
		}
	},

	'help nextMap'	=> sub {
		my($e, $p)=@_;

		chat::whisper($p, '/list nextMap');
		chat::whisper($p, '/nextMap');
		chat::whisper($p, '/set nextMap <map>');
		chat::whisper($p, '/unset nextMap');
		chat::whisper($p, 'Overrride map votes and default nextMap with <map>');
	},

	'list nextMap'	=> sub {
		my($e, $p)=@_;
		my($next)=stash::get('nextMap', 'admin');

		if($next) {
			chat::whisper($p, 'Next map is', $next);
		} else {
			chat::whisper($p, 'Run /nextMap to see next map');
		}
	},

	'nextMap'	=> sub {
		my($e, $p)=@_;
		my($next)=stash::get('nextMap', 'admin');

		chat::whisper($p, 'Next map override is', $next) if($next);
	},

	'set nextMap'	=> sub {
		my($e, $p, $next)=@_;

		stash::set('nextMap', 'admin', $next);
		chat::whisper($p, 'Next map is now', $next);
	},

	'unset nextMap'	=> sub {
		my($e, $p)=@_;

		stash::delete('nextMap', 'admin');
		chat::whisper($p, 'Next map is now left to server');
	},

	'mapLoading'	=> sub {
		my($e, $p)=@_;
		my($mapdir)=config::option('mapDir');
		my($map)="$INSTALL_ROOT/maps/$mapdir/$e->{'map'}.altx";
		my($next)=stash::get('nextMap', 'admin');

		if($next && $e->{'map'} ne $next) {
			server::send('changeMap', $next);
			server::override('mapChange', 'skip');
		} else {
			file::update_ctime($map);
			map::busy;
		}

		stash::delete('nextMap', 'admin') if($next);
	},

	'mapChange:skip'	=> sub {
		return;
	},

	'mapChange'	=> sub {
		my($e, $p)=@_;
		my(@settings)=qw(
			ballScore
			gravity
			weapons
			spawnHealth
			cameraScale
			planeScale
			assignTeam
			planes
			spawnMode
			changePlane
			keys
			maxPlayers
			gameType
		);

		stash::fix_doors($e->{'map'}, $e->{'leftTeam'}, $e->{'rightTeam'});

		map::new($e);
		plus::new;

		foreach my $player (player::list) {
			$player->{'stats'}={'carrier' => 0};
			player::forgive($player);
		}

		foreach my $setting (@settings) {
			$HOOKS{"enable $setting"}->($e, $p)
				if(exists($HOOKS{"enable $setting"}));
		}

		chat::all('Server configured for map:', $e->{'map'});
	},

	'help gravity'	=> sub {
		my($e, $p)=@_;

		chat::whisper($p, '/list gravity');
		chat::whisper($p, '/set gravity <0|1|2|3>');
		chat::whisper($p, '/unset gravity');
		chat::whisper($p, '0=default, 1=disable planes/weapons, 2=disable ball, 3=none');
	},

	'list gravity'	=> sub {
		my($e, $p)=@_;
		my($gravity)=stash::get('gravity', map::name);
		my(@table)=('0 (default)', '1 (no plane gravity)', '2 (no ball gravity)', '3 (no gravity)');

		chat::whisper($p, 'gravity:', $table[$gravity]);
	},

	'enable gravity'	=> sub {
		my($e, $p)=@_;
		my($gravity)=stash::get('gravity', map::name);

		if(defined($gravity)) {
			server::send('testGravityMode', $gravity);
		} else {
			server::send('testGravityMode', 0);
		}
	},

	'set gravity'	=> sub {
		my($e, $p, $grav)=@_;

		if($grav==0) {
			stash::delete('gravity', map::name);
			chat::all('Returning gravity to normal');
			server::send('testGravityMode', 0);
		} elsif($grav<=3) {
			stash::set('gravity', map::name, $grav);
			server::send('testGravityMode', $grav);
		} else {
			chat::whisper($p, "Invalid gravity value: $grav");
		}
	},

	'unset gravity'	=> sub {
		my($e, $p)=@_;

		stash::delete('gravity', map::name);
		server::send('testGravityMode', 0);

		chat::all('Returning gravity to normal');
	},

	'help weapons'	=> sub {
		my($e, $p)=@_;

		chat::whisper($p, '/list weapons');
		chat::whisper($p, '/set weapons <0|1|2|3>');
		chat::whisper($p, '/unset weapons');
		chat::whisper($p, '0=default, 1=disable primary, 2=disable secondary, 3=no weapons');
	},

	'list weapons'	=> sub {
		my($e, $p)=@_;
		my($weapons)=stash::get('weapons', map::name);
		my(@table)=('0 (default)', '1 (secondary only)', '2 (primary only)', '3 (no weapons)');

		chat::whisper($p, 'weapons:', $table[$weapons]);
	},

	'enable weapons'	=> sub {
		my($e, $p)=@_;
		my($weapons)=stash::get('weapons', map::name);

		if(defined($weapons)) {
			server::send('testDisableWeaponMode', $weapons);
		} else {
			server::send('testDisableWeaponMode', 0);
		}
	},

	'set weapons'	=> sub {
		my($e, $p, $weapons)=@_;

		if($weapons==0) {
			stash::delete('weapons', map::name);
			chat::all('Returning weapons to normal');
			server::send('testDisableWeaponMode', 0);
		} elsif($weapons<=3) {
			stash::set('weapons', map::name, $weapons);
			server::send('testDisableWeaponMode', $weapons);
		} else {
			chat::whisper($p, "Invalid weapons value: $weapons");
		}
	},

	'unset weapons'	=> sub {
		my($e, $p)=@_;

		stash::delete('weapons', map::name);
		server::send('testDisableWeaponMode', 0);

		chat::all('Returning weapons to normal');
	},

	'help spawnHealth'	=> sub {
		my($e, $p)=@_;

		chat::whisper($p, '/list spawnHealth');
		chat::whisper($p, '/set spawnHealth <1-999>');
		chat::whisper($p, '/unset spawnHealth');
		chat::whisper($p, '50=half normal health, 200=double normal health');
	},

	'list spawnHealth'	=> sub {
		my($e, $p)=@_;
		my($health)=stash::get('spawnHealth', map::name);
		my($msg);

		if(!defined($health) || $health==100) {
			$msg='100 (default)';
		} elsif($health<100) {
			$msg="$health (fragile)";
		} elsif($health>100) {
			$msg="$health (strong)";
		}

		chat::whisper($p, 'spawnHealth:', $msg);
	},

	'enable spawnHealth'	=> sub {
		my($e, $p)=@_;
		my($health)=stash::get('spawnHealth', map::name);

		if(defined($health)) {
			server::send('testHealthModifier', $health);
		} else {
			server::send('testHealthModifier', 100);
		}
	},

	'set spawnHealth'	=> sub {
		my($e, $p, $health)=@_;

		if($health==100) {
			stash::delete('spawnHealth', map::name);
			chat::all('Returning spawnHealth to normal');
			server::send('testHealthModifier', 100);
		} elsif(0<$health && $health<1000) {
			stash::set('spawnHealth', map::name, $health);
			server::send('testHealthModifier', $health);
		} else {
			chat::whisper($p, "Invalid spawnHealth value: $health");
		}
	},

	'unset spawnHealth'	=> sub {
		my($e, $p)=@_;

		stash::delete('spawnHealth', map::name);
		server::send('testHealthModifier', 100);

		chat::all('Returning spawnHealth to normal');
	},

	'help cameraScale'	=> sub {
		my($e, $p)=@_;

		chat::whisper($p, '/list cameraScale');
		chat::whisper($p, '/set cameraScale <40-300>');
		chat::whisper($p, '/unset cameraScale');
		chat::whisper($p, '50=Zoom in(half normal viewable) 200=Zoom out(twice normal viewable)');
	},

	'list cameraScale'	=> sub {
		my($e, $p)=@_;
		my($scale)=stash::get('cameraScale', map::name);
		my($msg);

		if(!defined($scale) || $scale==100) {
			$msg='100 (default)';
		} elsif($scale<100) {
			$msg="$scale (zoom in)";
		} elsif($scale>100) {
			$msg="$scale (zoom out)";
		}

		chat::whisper($p, 'cameraScale:', $msg);
	},

	'enable cameraScale'	=> sub {
		my($e, $p)=@_;
		my($scale)=stash::get('cameraScale', map::name);

		server::send('testCameraViewScale', $scale || 100);
	},

	'set cameraScale'	=> sub {
		my($e, $p, $zoom)=@_;

		$zoom=~s/%$//;
		$zoom=100 if($zoom=~m/default|normal/i);

		if($zoom==100) {
			stash::delete('cameraScale', map::name);
			chat::all('Returning camera zoom to normal');
			server::send('testCameraViewScale', 100);
		} elsif(40<=$zoom && $zoom<=300) {
			stash::set('cameraScale', map::name, $zoom);
			server::send('testCameraViewScale', $zoom);
		} else {
			chat::whisper($p, "Invalid camera scale value: $zoom");
		}
	},

	'unset cameraScale'	=> sub {
		my($e, $p)=@_;

		stash::delete('cameraScale', map::name);
		server::send('testCameraViewScale', 100);

		chat::all('Returning camera zoom to normal');
	},

	'help planeScale'	=> sub {
		my($e, $p)=@_;

		chat::whisper($p, '/list planeScale');
		chat::whisper($p, '/set planeScale <40-300>');
		chat::whisper($p, '/unset planeScale');
		chat::whisper($p, '50=planes are half size, 200=planes are double size');
	},

	'list planeScale'	=> sub {
		my($e, $p)=@_;
		my($scale)=stash::get('planeScale', map::name);
		my($msg);

		if(!defined($scale) || $scale==100) {
			$msg='100 (default)';
		} elsif($scale<100) {
			$msg="$scale (smaller)";
		} elsif($scale>100) {
			$msg="$scale (bigger)";
		}

		chat::whisper($p, 'planeScale:', $msg);
	},

	'enable planeScale'	=> sub {
		my($e, $p)=@_;
		my($scale)=stash::get('planeScale', map::name);

		server::send('testPlaneScale', $scale || 100);
	},

	'set planeScale'	=> sub {
		my($e, $p, $zoom)=@_;

		$zoom=~s/%$//;
		$zoom=100 if($zoom=~m/default|normal/i);

		if($zoom==100) {
			stash::delete('planeScale', map::name);
			chat::all('Returning plane zoom to normal');
			server::send('testPlaneScale', 100);
		} elsif(40<=$zoom && $zoom<=300) {
			stash::set('planeScale', map::name, $zoom);
			server::send('testPlaneScale', $zoom);
		} else {
			chat::whisper($p, "Invalid plane scale value: $zoom");
		}
	},

	'unset planeScale'	=> sub {
		my($e, $p)=@_;

		stash::delete('planeScale', map::name);
		server::send('testPlaneScale', 100);

		chat::all('Returning plane zoom to normal');
	},

	'help assignTeam'	=> sub {
		my($e, $p)=@_;

		chat::whisper($p, 'Force players to spawn on a specific team');
		chat::whisper($p, '/list assignTeam');
		chat::whisper($p, '/set assignTeam <left|right|none>');
		chat::whisper($p, '/unset assignTeam');
	},

	'list assignTeam'	=> sub {
		my($e, $p)=@_;
		my($team)=stash::get('assignTeam', map::name);
		my($color);

		if($team) {
			$color=map::team_color($team);
			chat::whisper($p, 'assignTeam:', $team, "($color)");
		} else {
			chat::whisper($p, 'assignTeam:', 'none');
		}
	},

	'enable assignTeam'	=> sub {
		my($e, $p)=@_;
		my($team)=stash::get('assignTeam', map::name);
		my($color);

		if(defined($team)) {
			$color=map::team_color($team);
			chat::all('assignTeam:', $team, "($color)");
		}
	},

	'set assignTeam'	=> sub {
		my($e, $p, $side)=@_;

		if(map::left($side)) {
			stash::set('assignTeam', map::name, 'left');
			chat::all(map::name, 'is configured to force players left');

			foreach my $m (player::list) {
				server::send('assignTeam', $m->{'nickname'}, 0)
					if(map::right($m->{'team'}));
			}
		} elsif(map::right($side)) {
			stash::set('assignTeam', map::name, 'right');
			chat::all(map::name, 'is configured to force players right');

			foreach my $m (player::list) {
				server::send('assignTeam', $m->{'nickname'}, 0)
					if(map::left($m->{'team'}));
			}
		} elsif($side=~m/none/i) {
			stash::delete('assignTeam', map::name);
			chat::all('Side enforcement for', map::name, 'is disabled');
		}
	},

	'unset assignTeam'	=> sub {
		my($e, $p)=@_;

		stash::delete('assignTeam', map::name);

		chat::all('Deleted team assignment');
	},

	'help planes'	=> sub {
		my($e, $p)=@_;

		chat::whisper($p, 'Allow only certain planes to join the game');
		chat::whisper($p, '/list planes');
		chat::whisper($p, '/set planes <Loopy|Bomber|Explodet|Biplane|Miranda>');
		chat::whisper($p, '/unset planes');
	},

	'list planes'	=> sub {
		my($e, $p)=@_;
		my($planes)=stash::get('planes', map::name);

		chat::whisper($p, 'planes:', $planes || 'all');
	},

	'enable planes'	=> sub {
		my($e, $p)=@_;
		my($planes)=stash::get('planes', map::name);

		if(defined($planes)) {
			chat::all('planes:', $planes);
		}
	},

	'set planes'	=> sub {
		my($e, $p, @planes)=@_;
		my(%planes)=();
		my($planere);

		if(map::mode('ffa')) {
			chat::whisper($p, 'Plane enforcement is not possible in FFA');
			return;
		}

		foreach(split(m/[\s,;\|]+/, join(',', @planes))) {
			s/["']//g;

			s/loop.*/Loopy/i;
			s/[bd]omb.*/Bomber/i;
			s/whale/Explodet/i;
			s/expl.*/Explodet/i;
			s/bip.*/Biplane/i;
			s/.*randa/Miranda/i;
			s/mir.*/Miranda/i;

			if(m/all|none/) {
				stash::delete('planes', map::name);
				chat::all('Plane enforcement for', map::name, 'is disabled');
				return;
			} elsif(m/Loopy|Bomber|Explodet|Biplane|Miranda/) {
				$planes{$_}=1;
			}
		}

		$planere=join('|', keys(%planes));
		stash::set('planes', map::name, $planere);
		chat::all(map::name, 'only allows planes:', $planere);

		foreach my $m (player::list) {
			plus::bench($m) unless($m->{'plane'}=~m/$planere/);
		}
	},

	'unset planes'	=> sub {
		my($e, $p)=@_;

		if(stash::delete('planes', map::name)) {
			chat::all('Deleted plane requirements');
		} else {
			chat::whisper($p, 'No plane requirements exist');
		}
	},

	'help ballScore'	=> sub {
		my($e, $p)=@_;

		chat::whisper($p, 'When the map loads, pre-set the initial ball score');
		chat::whisper($p, '/list ballScore');
		chat::whisper($p, '/set ballScore <-#|#> <-#|#>');
		chat::whisper($p, '/unset ballScore');
		chat::whisper($p, 'Negative numbers are an offset from the winning score');
	},

	'list ballScore'	=> sub {
		my($e, $p)=@_;
		my($scores)=stash::get('ballScore', map::name);

		return unless(map::mode('ball'));

		if($scores) {
			chat::whisper($p, 'ballScore: [', join(',', @$scores), ']');
		} else {
			chat::whisper($p, 'ballScore: [', '0,0', ']');
		}
	},

	'enable ballScore'	=> sub {
		my($e, $p)=@_;
		my($scores)=stash::get('ballScore', map::name);
		my($goals)=$config::Goals;

		if($scores) {
			$scores->[0]=$goals+$scores->[0] if($scores->[0]<0);
			$scores->[1]=$goals+$scores->[1] if($scores->[1]<0);
			server::send('overrideBallScore', @$scores);
		}
	},

	'set ballScore' 	=> sub {
		my($e, $p, $l, $r)=@_;
		my($goals)=$config::Goals;

		return unless(map::mode('ball'));

		if($l<=-$goals || $r<=-$goals || $goals<=$l || $goals<=$r) {
			chat::whisper($p, "Invalid goal #, must be between -$goals and $goals");
		} elsif($l==0 && $r==0) {
			chat::whisper($p, "Initial score returned to normal for next round");
			stash::delete('ballScore', map::name);
		} else {
			chat::all("Initial score set to [$l, $r]");
			stash::set('ballScore', map::name, [$l, $r]);

			$l=$goals+$l if($l<0);
			$r=$goals+$r if($r<0);
			server::send('overrideBallScore', $l, $r);
		}

	},

	'unset ballScore'	=> sub {
		my($e, $p)=@_;

		if(stash::delete('ballScore', map::name)) {
			chat::whisper($p, 'Removed initial ballScore');
		} else {
			chat::whisper($p, 'Initial ballScore not set');
		}
	},

	'help maxPlayers'	=> sub {
		my($e, $p)=@_;

		chat::whisper($p, 'Set a map specific max player # smaller than the server default');
		chat::whisper($p, '/list maxPlayers');
		chat::whisper($p, '/set maxPlayers #');
		chat::whisper($p, '/unset maxPlayers');
	},

	'list maxPlayers'	=> sub {
		my($e, $p)=@_;
		my($count)=stash::get('maxPlayers', map::name);

		chat::whisper($p, 'maxPlayers:', $count || $config::Maxp);
	},

	'set maxPlayers'	=> sub {
		my($e, $p, $count)=@_;

		if($count>0) {
			stash::set('maxPlayers', map::name, $count);
		} else {
			stash::delete('maxPlayers', map::name);
		}
	},

	'unset maxPlayers'	=> sub {
		my($e, $p)=@_;

		stash::delete('maxPlayers', map::name);
	},

	'help spawnMode'	=> sub {
		my($e, $p)=@_;

		chat::whisper($p, 'Change the behavior of how users spawn when they die, or pickup powerups');
		chat::whisper($p, '/list spawnMode');
		chat::whisper($p, '/set spawnMode <default|died|pickup|health|zone|near|portal>');
		chat::whisper($p, '/unset spawnMode');
	},

	'list spawnMode'	=> sub {
		my($e, $p)=@_;
		my($spawn_mode)=stash::get('spawnMode', map::name);

		if($spawn_mode) {
			chat::whisper($p, 'spawnMode:', $spawn_mode);
		}
	},

	'enable spawnMode'	=> sub {
		my($e, $p)=@_;
		my($spawn_mode)=stash::get('spawnMode', map::name);

		if($spawn_mode) {
			chat::all('spawnMode:', $spawn_mode);
		}
	},

	'set spawnMode'	=> sub {
		my($e, $p, $spawn)=@_;

		if($spawn=~m/default|normal|start/i) {
			chat::all("Player spawn returned to normal");
			stash::delete('spawnMode', map::name);
		} elsif($spawn=~m/die/i) {
			chat::all("Players spawn where died, use '/sz start' to spawn normal");
			stash::set('spawnMode', map::name, 'died');
		} elsif($spawn=~m/power|pick/i) {
			chat::all("Players spawn at last powerup, use '/sz start' to spawn normal");
			stash::set('spawnMode', map::name, 'powerup');
		} elsif($spawn=~m/health/i) {
			chat::all("Players spawn at last health powerup, use '/sz start' to spawn normal");
			stash::set('spawnMode', map::name, 'health');
		} elsif($spawn=~m/zone/i) {
			chat::all("Spawn zones enabled, use /spawnZone to use them");
			stash::set('spawnMode', map::name, 'zone');
		} elsif($spawn=~m/near/i) {
			chat::all("Spawn in closest zone enabled, use '/sz start' to spawn normal");
			stash::set('spawnMode', map::name, 'near');
		} elsif($spawn=~m/portal/i) {
			if(map::mode('ffa')) {
				chat::whisper($p, 'Portals do not work in FFA');
				return;
			}

			chat::all("Spawn portals enabled, use '/sz start' to spawn normal");
			stash::set('spawnMode', map::name, 'portal');
		}
	},

	'unset spawnMode'	=> sub {
		my($e, $p)=@_;

		if(stash::delete('spawnMode', map::name)) {
			chat::all('Disabled enhanced spawn locations');
		} else {
			chat::whisper($p, 'Enhanced spawn locations not set');
		}
	},

	'help changePlane'	=> sub {
		my($e, $p)=@_;

		chat::whisper($p, 'Specify if players can change planes mid-map, defaults to 1 (ON)');
		chat::whisper($p, '/list changePlane');
		chat::whisper($p, '/set changePlane [0|1]');
		chat::whisper($p, '/unset changePlane');
	},

	'list changePlane'	=> sub {
		my($e, $p)=@_;
		my($cp)=stash::get('changePlane', map::name) // config::option('changePlane');

		if($cp) {
			chat::whisper($p, 'changePlane: 1 (enabled)');
		} else {
			chat::whisper($p, 'changePlane: 0 (disabled)');
		}
	},

	'enable changePlane'	=> sub {
		my($e, $p)=@_;
		my($cp)=stash::get('changePlane', map::name) // config::option('changePlane');

		if($cp) {
			chat::all('changePlane: 1 (enabled)');
		} else {
			chat::all('changePlane: 0 (disabled)');
		}
	},

	'set changePlane'	=> sub {
		my($e, $p, $cp)=@_;

		stash::set('changePlane', map::name, $cp);

		if($cp) {
			chat::all('Changing planes is enabled');
		} else {
			chat::all('Changing planes is only possible after dying');
		}
	},

	'unset changePlane'	=> sub {
		my($e, $p)=@_;
		my($cp)=config::option('changePlane');

		stash::delete('changePlane', map::name);

		chat::all('Changing planes is set to default',
				$cp?'(enabled)':'(disabled)', 'state');
	},

	'help gameType'	=> sub {
		my($e, $p)=@_;

		chat::whisper($p, 'These are Alti+ game times, which are extentions to the mode');
		chat::whisper($p, '/list gameType');
		chat::whisper($p, '/set gameType <mapname|std|coop|race|flag|zone|mdg>');
		chat::whisper($p, '/unset gameType');
		chat::whisper($p, 'mapname causes the type to be inferred from the map name');
	},

	'list gameType'	=> sub {
		my($e, $p)=@_;

		chat::whisper($p, 'gameType:', map::type);
	},

	'enable gameType'	=> sub {
		my($e, $p)=@_;
		my($type)=stash::get('gameType', map::name);

		if($type) {
			chat::all('gameType:', map::set_type($type));
		} else {
			chat::all('gameType:', map::set_type(map::name));
		}
	},

	'set gameType'		=> sub {
		my($e, $p, $type)=@_;

		if($type=~m/normal|file/i) {
			stash::delete('gameType', map::name);
			map::set_type(map::name);
		} else {
			stash::set('gameType', map::name, $type);
			map::set_type($type);
		}

		chat::all('gameType:', map::type);
	},

	'unset gameType'		=> sub {
		my($e, $p)=@_;

		if(stash::delete('gameType', map::name)) {
			chat::whisper($p, 'Removed gameType override');
			chat::all('gameType:', map::set_type(map::name));
		} else {
			chat::whisper($p, 'gameType not set');
		}
	},

	'help intro'	=> sub {
		my($e, $p)=@_;

		chat::whisper($p, 'Set an introductory message for players on a map');
		chat::whisper($p, '/list intro');
		chat::whisper($p, '/set intro <text ...>');
		chat::whisper($p, '/unset intro');
	},

	'list intro'	=> sub {
		my($e, $p)=@_;
		my($intro)=stash::get('intro', map::name);

		if($intro) {
			chat::whisper($p, $intro);
		} else {
			chat::whisper($p, 'This map does not have an introduction');
		}
	},

	'enable intro'	=> sub {
		my($e, $p)=@_;
		my($intro)=stash::get('intro', map::name);

		chat::all($intro) if($intro);
	},

	'set intro'		=> sub {
		my($e, $p, @text)=@_;
		my($text)=join(' ', @text);

		if($text) {
			stash::set('intro', map::name, $text);
			chat::all($text);
		} else {
			stash::delete('intro', map::name);
			chat::whisper($p, 'Removed map introduction');
		}

	},

	'unset intro'		=> sub {
		my($e, $p)=@_;

		stash::delete('intro', map::name);
		chat::whisper($p, 'Removed map introduction');
	},

	'help records'	=> sub {
		my($e, $p)=@_;

		chat::whisper($p, 'Manage map records');
		chat::whisper($p, '/list records');
		chat::whisper($p, '/del record <time>');
	},

	'list records'	=> sub {
		my($e, $p)=@_;

		records::whisper($p);
	},

	'del record'	=> sub {
		my($e, $p, $record)=@_;

		if(records::delete($record)) {
			chat::whisper($p, "Record $record deleted");
		} else {
			chat::whisper($p, "Failed to delete record: $record");
		}
	},

	'help portals'	=> sub {
		my($e, $p)=@_;

		chat::whisper($p, 'Portals allow users to be transported from a pickup to another location');
		chat::whisper($p, '/list portals');
		chat::whisper($p, '/add portal <name> <px>,<py> <sx>,<sy>,<sa>');
		chat::whisper($p, '/del portal <name>');
	},

	'list portals'	=> sub {
		my($e, $p)=@_;
		my($portals)=stash::get('portals', map::name);
		my($spawn_mode)=stash::get('spawnMode', map::name);
		my($any)=0;

		foreach my $portal (sort(keys(%$portals))) {
			chat::whisper($p, sprintf('%s: %s -> %d,%d @%s',
					$portals->{$portal}[0],
					$portal,
					@{$portals->{$portal}}[1,2,3]
				));
			$any=1;
		}

		chat::whisper($p, 'No spawn portals defined') unless($any);
	},

	'add portal'	=> sub {
		my($e, $p, $portal, $px, $py, $sx, $sy, $sa)=@_;

		if(map::mode('ffa')) {
			chat::whisper($p, 'Portals cannot function in FFA games');
			return;
		}

		stash::set("$px,$py", 'portals', map::name,
			[$portal => $sx, $sy, $sa]);
		chat::all('Added portal:', $portal);
	},

	'del portal'	=> sub {
		my($e, $p, $remove, $rest)=@_;
		my($portals)=stash::get('portals', map::name);

		$remove=join(',', $remove, $rest) if($rest);

		foreach my $portal (keys(%$portals)) {
			if($portal eq $remove) {
				stash::delete($portal, 'portals', map::name);
				chat::all('Deleted portal:', $portal);
			} elsif($portals->{$portal}[0] eq $remove) {
				stash::delete($portal, 'portals', map::name);
				chat::all('Deleted portal:', $portal);
			} else {
				chat::whisper($p, 'No portal at or named:', $remove);
			}
		}
	},

	'help doors'	=> sub {
		my($e, $p)=@_;

		chat::whisper($p, 'Doors disable planes to pass through a pickup until all keys are found');
		chat::whisper($p, '/list doors');
		chat::whisper($p, '/add door <name> <team> <dx>,<dy>');
		chat::whisper($p, '/del door <name> <team>');
	},

	'list doors'	=> sub {
		my($e, $p)=@_;
		my($any)=0;
		my(@teams)=();
		my($sep)=':';
		my($doors, $keys, $status);

		if($e->{'admin'} || map::spec($p->{'team'})) {
			@teams=(map::left, map::right);
		} elsif(map::left($p->{'team'})) {
			@teams=(map::left);
		} elsif(map::right($p->{'team'})) {
			@teams=(map::right);
		}
		foreach my $team (@teams) {
			$doors=utils::invert(stash::get('doors', $team, 'door', map::name));
			$keys=utils::invert(stash::get('keys', $team, 'door', map::name));

			if(@teams==2) {
				if(map::left($team)) {
					$sep='<';
				} else {
					$sep='>';
				}
			}

			foreach my $door (sort(keys(%$doors))) {
				if(plus::door_open($p, $door)) {
					$status='(open)';
				} else {
					$status='(locked)';
				}
				chat::whisper($p, $door, $sep, @{$doors->{$door}}, '<=',
					@{$keys->{$door}}, $status);
				delete($keys->{$door});
				$any=1;
			}

			foreach my $key (sort(keys(%$keys))) {
				chat::whisper($p, 'orphaned key', $key ,':', @{$keys->{$key}});
				$any=1;
			}
		}

		chat::whisper($p, 'No doors defined') unless($any);
	},

	'add door'	=> sub {
		my($e, $p, $name, $team, $dx, $dy)=@_;

		if(map::mode('ffa')) {
			chat::whisper($p, 'Doors cannot function in FFA games');
			return;
		}

		$team='*' unless($team);

		if(map::left($team)) {
			stash::set("$dx,$dy", 'doors', map::left, 'door', map::name, $name);
			chat::all('Added left door:', $name, "($dx,$dy)");
		}

		if(map::right($team)) {
			stash::set("$dx,$dy", 'doors', map::right, 'door', map::name, $name);
			chat::all('Added right door:', $name, "($dx,$dy)");
		}
	},

	'del door'	=> sub {
		my($e, $p, $name, $team)=@_;
		my($any)=0;
		my($doors);

		$team='*' unless($team);

		if(map::left($team)) {
			$doors=stash::get('doors', map::left, 'door', map::name);

			foreach my $door (keys(%$doors)) {
				if($doors->{$door} eq $name) {
					stash::delete($door, 'doors', map::left, 'door', map::name);
					chat::all('Deleted left door:', $name, "($door)");
					$any=1;
				}
			}
		}

		if(map::right($team)) {
			$doors=stash::get('doors', map::right, 'door', map::name);

			foreach my $door (keys(%$doors)) {
				if($doors->{$door} eq $name) {
					stash::delete($door, 'doors', map::right, 'door', map::name);
					chat::all('Deleted right door:', $name, "($door)");
					$any=1;
				}
			}
		}

		unless($any) {
			chat::whisper($p, 'No door named:', $name);
		}
	},

	'help keys'	=> sub {
		my($e, $p)=@_;

		chat::whisper($p, 'Keys unlock doors and zones, see /help doors or /help zones');
		chat::whisper($p, '/list keys');
		chat::whisper($p, '/add key <door|zone> <team> <kx>,<ky>');
		chat::whisper($p, '/del key <door|zone> <team>');
		chat::whisper($p, '/set keys <team|personal>');
		chat::whisper($p, '/unset keys');
	},

	'list keys'	=> sub {
		my($e, $p)=@_;
		my($keys)=stash::get('keys', map::name);
		my(@flags)=();
		my($locked)=	stash::get('keys', map::left, 'door', map::name)	||
					stash::get('keys', map::right, 'door', map::name)	||
					stash::get('keys', map::left, 'zones', map::name)	||
					stash::get('keys', map::right, 'zones', map::name);

		if(defined($keys)) {
			push(@flags, 'personal') if($keys & 1);

			@flags=('team') unless(@flags);

			chat::whisper($p, 'keys:', @flags);
		} elsif($locked) {
			chat::whisper($p, 'keys:', 'team');
		}
	},

	'enable keys'	=> sub {
		my($e, $p)=@_;
		my($keys)=stash::get('keys', map::name);
		my(@flags)=();
		my($locked)=	stash::get('keys', map::left, 'door', map::name)	||
					stash::get('keys', map::right, 'door', map::name)	||
					stash::get('keys', map::left, 'zones', map::name)	||
					stash::get('keys', map::right, 'zones', map::name);

		if(defined($keys)) {
			push(@flags, 'personal') if($keys & 1);

			@flags=('team') unless(@flags);

			chat::all('keys:', @flags);
		} elsif($locked) {
			chat::all('keys:', 'team');
		}
	},

	'set keys'	=> sub {
		my($e, $p, $flag)=@_;
		#We can OR these later if we add more flags.

		if($flag=~m/0|team/i) {
			stash::set('keys', map::name, 0);
			chat::whisper($p, 'Keys are team-wide as of the next map load');
		} elsif($flag=~m/1|personal|single/) {
			stash::set('keys', map::name, 1);
			chat::whisper($p, 'Keys will be personal on next map load');
		}
	},

	'unset keys'	=> sub {
		my($e, $p)=@_;

		stash::delete('keys', map::name);
		chat::whisper($p, 'Keys are team-wide as of the next map load');
	},

	'add key'		=> sub {
		my($e, $p, $name, $team, $kx, $ky)=@_;

		$team='*' unless($team);

		if(map::left($team)) {
			if(stash::get("$kx,$ky", 'doors', map::left, 'door', map::name)) {
				stash::set("$kx,$ky", 'keys', map::left, 'door', map::name, $name);
				chat::all('Added left key for door:', $name, "($kx,$ky)");
			} elsif(stash::get($name, 'zones', map::left, 'zones', map::name)) {
				stash::set("$kx,$ky", 'keys', map::left, 'zones', map::name, $name);
				chat::all('Added left key for zone:', $name, "($kx,$ky)");
			} else {
				chat::whisper($p, 'You must define the left door or zone first');
			}
		}

		if(map::right($team)) {
			if(stash::get("$kx,$ky", 'doors', map::right, 'door', map::name)) {
				stash::set("$kx,$ky", 'keys', map::right, 'door', map::name, $name);
				chat::all('Added right key for door:', $name, "($kx,$ky)");
			} elsif(stash::get($name, 'zones', map::right, 'zones', map::name)) {
				stash::set("$kx,$ky", 'keys', map::right, 'zones', map::name, $name);
				chat::all('Added right key for zone:', $name, "($kx,$ky)");
			} else {
				chat::whisper($p, 'You must define the right door or zone first');
			}
		}
	},

	'del key'	=> sub {
		my($e, $p, $name, $team)=@_;
		my($any)=0;
		my($keys);

		$team='*' unless($team);

		if(map::left($team)) {
			$keys=stash::get('keys', map::left, 'door', map::name);
			foreach my $key (keys(%$keys)) {
				if($keys->{$key} eq $name) {
					stash::delete($key, 'keys', 'door', map::name);
					chat::all('Deleted key for door:', $name, "($key)");
					$any=1;
				}
			}

			$keys=stash::get('keys', map::left, 'zones', map::name);
			foreach my $key (keys(%$keys)) {
				if($keys->{$key} eq $name) {
					stash::delete($key, 'keys', 'zones', map::name);
					chat::all('Deleted key for zone:', $name, "($key)");
					$any=1;
				}
			}
		}

		if(map::right($team)) {
			$keys=stash::get('keys', map::right, 'door', map::name);
			foreach my $key (keys(%$keys)) {
				if($keys->{$key} eq $name) {
					stash::delete($key, 'keys', 'door', map::name);
					chat::all('Deleted key for door:', $name, "($key)");
					$any=1;
				}
			}

			$keys=stash::get('keys', map::right, 'zones', map::name);
			foreach my $key (keys(%$keys)) {
				if($keys->{$key} eq $name) {
					stash::delete($key, 'keys', 'zones', map::name);
					chat::all('Deleted key for door:', $name, "($key)");
					$any=1;
				}
			}
		}

		unless($any) {
			chat::whisper($p, 'No keys for door or zone named:', $name);
		}
	},

	'help diverters'	=> sub {
		my($e, $p)=@_;

		chat::whisper($p, 'Diverters alternate access to parts of a map');
		chat::whisper($p, '/list diverters');
		chat::whisper($p, '/add diverter <x1>,<y1> <x2>,<y2>');
		chat::whisper($p, '/del diverter <x1>,<y1>');
		chat::whisper($p, 'only binary diverters are supported');
	},

	'list diverters'	=> sub {
		my($e, $p)=@_;
		my($divs)=stash::get('diverters', map::name);
		my(%seen)=();

		foreach my $diverter (keys(%$divs)) {
			unless(exists($seen{$diverter})) {
				chat::whisper($p, $diverter, ':', $divs->{$diverter});
				$seen{$divs->{$diverter}}=1;
			}
		}
	},

	'add diverter'	=> sub {
		my($e, $p, $x1, $y1, $x2, $y2)=@_;

		stash::set("$x1,$y1", 'diverters', map::name, "$x2,$y2");
		stash::set("$x2,$y2", 'diverters', map::name, "$x1,$y1");
	},

	'del diverter'	=> sub {
		my($e, $p, $x1, $y1)=@_;
		my($divs)=stash::get('diverters', map::name);

		stash::delete($divs->{"$x1,$y1"}, 'diverters', map::name);
		stash::delete("$x1,$y1", 'diverters', map::name);
	},

	'help oneways'	=> sub {
		my($e, $p)=@_;

		chat::whisper($p, 'Ensure anyone picking up a powerup is traveling in a direction');
		chat::whisper($p, '/list oneways');
		chat::whisper($p, '/add oneway <x>,<y> <direction>');
		chat::whisper($p, '/del oneway <x>,<y>');
	},

	'list oneways'	=> sub {
		my($e, $p)=@_;
		my($oneway)=stash::get('oneways', map::name);

		foreach my $powerup (keys(%$oneway)) {
			chat::whisper($p, $powerup, ':', $oneway->{$powerup});
		}
	},

	'add oneway'	=> sub {
		my($e, $p, $x, $y, $direction)=@_;

		stash::set("$x,$y", 'oneways', map::name, lc($direction));
	},

	'del oneway'	=> sub {
		my($e, $p, $x, $y)=@_;

		stash::delete("$x,$y", 'oneways', map::name);
	},

	'help zones'	=> sub {
		my($e, $p)=@_;

		chat::whisper($p, 'Zones are used by spawnType zone and near for spawn locations');
		chat::whisper($p, '/list zones');
		chat::whisper($p, '/add zone <name> <team> <x>,<y>,<a>');
		chat::whisper($p, '/del zone <name> <team>');
	},

	'list zones'	=> sub {
		my($e, $p)=@_;
		my($spawn_mode)=stash::get('spawnMode', map::name);
		my($any)=0;
		my(@teams)=();
		my($sep)=':';
		my($zones, $keys, $status);

		if($e->{'admin'} || map::spec($p->{'team'})) {
			@teams=(map::left, map::right);
		} elsif(map::left($p->{'team'})) {
			@teams=(map::left);
		} elsif(map::right($p->{'team'})) {
			@teams=(map::right);
		}
		foreach my $team (@teams) {
			$zones=stash::get('zones', $team, 'zones', map::name);
			$keys=utils::invert(stash::get('keys', $team, 'zones', map::name));

			if(@teams==2) {
				if(map::left($team)) {
					$sep='<';
				} else {
					$sep='>';
				}
			}

			foreach my $zone (sort(keys(%$zones))) {
				if(plus::zone_open($p, $zone)) {
					$status='(open)';
				} else {
					$status='(closed)';
				}
				if(exists($keys->{$zone})) {
					chat::whisper($p,
						sprintf("%s $sep %d,%d @%s <=", $zone, @{$zones->{$zone}}),
						@{$keys->{$zone}},
						$status
					);
				} else {
					chat::whisper($p,
						sprintf("%s $sep %d,%d @%s", $zone, @{$zones->{$zone}})
					);
				}
				delete($keys->{$zone});
				$any=1;
			}

			foreach my $key (sort(keys(%$keys))) {
				chat::whisper($p, 'orphaned key', $key ,':', @{$keys->{$key}});
				$any=1;
			}
		}

		if($spawn_mode eq 'zone' || $spawn_mode eq 'near') {
			chat::whisper($p, 'No spawn zones defined') unless($any);
		} else {
			chat::whisper($p, 'spawnMode is not set to zone');
		}
	},

	'add zone'	=> sub {
		my($e, $p, $zone, $team, $sx, $sy, $sa)=@_;

		$team='*' unless($team);

		if(map::left($team)) {
			stash::set($zone, 'zones', map::left, 'zones', map::name, [$sx, $sy, $sa]);
			chat::all('Added left zone:', $zone, "($sx,$sy)");
		}

		if(map::right($team)) {
			stash::set($zone, 'zones', map::right, 'zones', map::name, [$sx, $sy, $sa]);
			chat::all('Added right zone:', $zone, "($sx,$sy)");
		}
	},

	'del zone'	=> sub {
		my($e, $p, $zone, $team)=@_;

		$team='*' unless($team);

		if(map::left($team)) {
			if(stash::delete($zone, 'zones', map::left, 'zones', map::name)) {
				chat::all('Deleted left zone:', $zone);
			} else {
				chat::whisper($p, 'No left zone', $zone);
			}
		}

		if(map::right($team)) {
			if(stash::delete($zone, 'zones', map::right, 'zones', map::name)) {
				chat::all('Deleted right zone:', $zone);
			} else {
				chat::whisper($p, 'No right zone', $zone);
			}
		}
	},

	'help powerups'	=> sub {
		my($e, $p)=@_;

		chat::whisper($p, 'Mark a powerup special to the game type (e.g. flag or race)');
		chat::whisper($p, '/list powerups');
		chat::whisper($p, '/add powerup <name> <team> <x> <y>');
		chat::whisper($p, '/del powerup <name> <team>');
	},

	'list powerups'	=> sub {
		my($e, $p)=@_;
		my($powerups)=stash::get('powerups', map::name);
		my($any)=0;
		my($groups);

		if($e->{'admin'}) {
			$groups=utils::invert(%{$powerups->{map::left}});
			foreach my $key (sort(keys(%$groups))) {
				chat::whisper($p, '<', $key, ':', @{$groups->{$key}});
				$any=1;
			}

			$groups=utils::invert(%{$powerups->{map::right}});
			foreach my $key (sort(keys(%$groups))) {
				chat::whisper($p, '>', $key, ':', @{$groups->{$key}});
				$any=1;
			}
		} else {
			$groups=utils::invert(%{$powerups->{$p->{'team'}}});
			foreach my $key (sort(keys(%$groups))) {
				chat::whisper($p, $key, ':', @{$groups->{$key}});
				$any=1;
			}
		}

		chat::whisper($p, 'No special powerups defined') unless($any);
	},

	'add powerup'	=> sub {
		my($e, $p, $powerup, $team, $px, $py)=@_;
		my(@powerups)=();
		my($color);

		$team='*' unless($team);

		if(map::left($team)) {
			$color=map::team_color('left');
			stash::set("$px,$py", map::left, 'powerups', map::name, $powerup);
			chat::all("Added left ($color) powerup:", $powerup, "($px,$py)");
		}

		if(map::right($team)) {
			$color=map::team_color('right');
			stash::set("$px,$py", map::right, 'powerups', map::name, $powerup);
			chat::all("Added right ($color) powerup:", $powerup, "($px,$py)");
		}
	},
	
	'del powerup'	=> sub {
		my($e, $p, $px, $py, $team)=@_;
		my($powerup);
		my($color);

		$team='*' unless($team);

		if(map::left($team)) {
			$color=map::team_color('left');
			$powerup=stash::get("$px,$py", map::left, 'powerups', map::name);
			if(stash::delete("$px,$py", map::left, 'powerups', map::name)) {
				chat::all("Deleted left ($color) powerup:", $powerup, "($px,$py)");
			} else {
				chat::whisper($p, 'No left powerup at', "$px,$py");
			}
		}

		if(map::right($team)) {
			$color=map::team_color('right');
			$powerup=stash::get("$px,$py", map::right, 'powerups', map::name);
			if(stash::delete("$px,$py", map::right, 'powerups', map::name)) {
				chat::all("Deleted right ($color) powerup:", $powerup, "($px,$py)");
			} else {
				chat::whisper($p, 'No right powerup at', "$px,$py");
			}
		}
	},
	
	'spawnZone'	=> sub {
		my($e, $p)=@_;
		my($zone)=@{$e->{'arguments'}};
		my($coords)=stash::get($zone, 'zones', $p->{'team'}, 'zones', map::name);
		my($spawn_mode)=stash::get('spawnMode', map::name);

		if($p->{'carrier'}) {
			chat::whisper($p, 'You cannot /spawnZone as a carrier');
		} elsif($zone=~m/^start$/i) {
			plus::bench($p);
			plus::spawn_reset($p);
		} elsif($spawn_mode ne 'zone') {
			chat::whisper($p, "Zone spawning not allowed in mode: $spawn_mode");
		} elsif(ref($coords) eq 'ARRAY') {
			if(plus::zone_open($p, $zone)) {
				if(map::mode('ffa')) {
					chat::whisper($p, 'Next spawn will be in', $zone);
				} else {
					plus::bench($p);
				}
				plus::spawn_here($p, @$coords);
			} else {
				chat::whisper($p, "Zone '$zone' is not yet open");
			}
		} else {
			chat::whisper($p, "No zone named '$zone'");
		}
	},

	'sz'			=> sub {
		$HOOKS{'spawnZone'}->(@_);
	},

	'changePlane'	=> sub {
		my($e, $p)=@_;

		if($p->{'carrier'}) {
			chat::whisper($p, 'You cannot /changePlane as a carrier');
		} else {
			server::trigger('logPlanePositions', 'changePlane', $e, $p);
		}
	},

	'cp'			=> sub {
		$HOOKS{'changePlane'}->(@_);
	},

	'logPlanePositions:changePlane'	=> sub {
		my($e1, $p1, $e2, $p2)=@_;
		server::trigger('logPlanePositions', 'logPlanePositions:changePlane', $e1, $p1, $e2, $p2);
	},

	'logPlanePositions:logPlanePositions:changePlane'	=> sub {
		my($e1, $p1, $e2, $p2, $e3, $p3)=@_;
		my(@pos1)=split(m/,/, $e2->{'positionByPlayer'}{$p3->{'player'}});
		my(@pos2)=split(m/,/, $e1->{'positionByPlayer'}{$p3->{'player'}});

		plus::bench($p3);
		plus::spawn_here($p3, @pos1, $pos2[0]-$pos1[0], $pos2[1]-$pos1[1]);
		plus::clear_spawn($p3);
	},

	'sum'		=> sub {
		my($e, $p)=@_;
		my($name)=@{$e->{'arguments'}};
		my($map)=map::file;
		my(%sums)=(
			'crc32'	=> 'cksum',
			'md5'	=> 'md5sum',
			'sha1'	=> 'sha1sum',
			'sha256'	=> 'sha256sum',
		);
		my($sum)=$sums{lc($name)};

		unless($sum) {
			chat::whisper($p, "Invalid digest name: $sum");
			chat::whisper($p, "Choose from: crc32 md5 sha1 sha256");
			return(0);
		}

		if(-r $map && file::name_ok($map)) {
			chat::whisper($p, map::name, ':', file::sum($sum, $map));
		}
	},

	'clientAdd'		=> sub {
		my($e, $p)=@_;

		#                       PlayerId|VaporID
		if($p->{'nickname'}=~m/^(\d{1,2}|[0-9a-f-]{36})$/) {
			chat::whisper($e, 'Invalid nickname for this server.');
			server::send('kick', $e->{'nickname'});
			return(undef);
		} elsif($p->{'vaporId'}=~m/[^0-]/ && $p->{'nickname'}=~m/^Bot \d\d?/) {
			chat::whisper($e, 'Invalid nickname for this server.');
			server::send('kick', $e->{'nickname'});
			return(undef);
		}

		return unless($e && $p);

		$p->{'stats'}={};

		player::add($p);

		return if($p->{'isBot'});

		altbouncer::add($p);

		if($p->{'country'}=utils::geoip($p->{'ip'})) {
			ui::display('', '', "< $p->{'nickname'} entered from $p->{'country'} >");
		} else {
			ui::display('', '', "< $p->{'nickname'} entered >");
		}

		foreach my $statement (split(m/;/, config::option('motd'))) {
			chat::whisper($p, $statement);
		}
	},

	'clientNicknameChange'	=> sub {
		my($e, $p)=@_;

		player::rename($e->{'oldNickname'}, $e->{'newNickname'});

		altbouncer::add($p);

		if(chat::snarky) {
			chat::whisper($p, 'Oh', $p->{'nickname'},
				', you will always be', $p->{'vaporId'}, 'to me.');
		}
	},

	'clientRemove'		=> sub {
		my($e, $p)=@_;

		player::remove($p);

		return if($p->{'isBot'});

		map::busy;

		ui::display('', '', "< $p->{'nickname'} $e->{'message'} >");

		plus::leave($p);

		$p->{'alive'}=0;
		delete($p->{'player'});
	},

	'balanceTeams'		=> sub {
		ball::reset;
	},

	'teamChange'		=> sub {
		my($e, $p)=@_;
		my($map_team)=stash::get('assignTeam', map::name);
		my($zones)=stash::get('zones', $p->{'team'}, 'zones', map::name);
		my($minlvl)=0;
		my(@badge)=();
		my($planes, $intro);
		
		if($p->{'isBot'}) {
			$p->{'team'}=$e->{'team'};
			return;
		}

		#Make sure players are the correct level for their aceRank:
		if($p->{'aceRank'}==0) {
			$minlvl=config::option('noviceLevel');
			@badge=('on this server');
		} else {
			$minlvl=config::option('aceLevel');
			@badge=('at Ace', $p->{'aceRank'});
		}
		if($p->{'level'} < $minlvl) {
			$p->{'team'}=$e->{'team'};

			return if(map::spec($e->{'team'}));

			server::send('assignTeam', $p->{'nickname'}, -1);
			player::infraction($p, 2);

			if(exists($MILESTONES{$minlvl})) {
				chat::whisper($p, 'You must unlock',
					$MILESTONES{$minlvl}, 'to play', @badge);
			} else {
				chat::whisper($p, 'You must reach level',
					$minlvl, 'to play', @badge);
			}

			return;
		}

		#Display the intro after users join (first teamChange to spec):
		unless($p->{'stats'}{'intro'}) {
			$planes=stash::get('planes', map::name);
			$intro=stash::get('intro', map::name);

			chat::whisper($p, 'Allowed Planes:', $planes) if($planes);
			chat::whisper($p, $intro) if($intro);

			$p->{'stats'}{'intro'}=1;
		}

		#Keep track of players and allow access only as necessary:
		if(map::spec($e->{'team'})) {
			if(map::spec($p->{'team'})) {
				$p->{'team'}=$e->{'team'};
				return;
			} else {
				plus::spawn_reset($p) unless(map::type('coop'));

				$p->{'team'}=$e->{'team'};

				plus::leave($p);
				plus::cower($p) if(plus::hunted($p));
	
				return;
			}
		} elsif(plus::enter($p)) {
			#Non needed/causes problems?#plus::spawn_reset($p);
			$p->{'team'}=$e->{'team'};
		} else {
			server::send('assignTeam', $p->{'nickname'}, -1);
			$p->{'team'}=-1;
			player::infraction($p, 0.2);

			return;
		}

		#Ensure players are on the correct team:
		if(map::type('mdg') && plus::prey($p)) {
			if(ref($zones) eq 'HASH' && %$zones) {
				plus::spawn_here($p, @{utils::random_value($zones)});
			}
			if($map_team eq 'left' && map::left($p->{'team'})) {
				server::send('assignTeam', $p->{'nickname'}, 1);
			} elsif($map_team eq 'right' && map::right($p->{'team'})) {
				server::send('assignTeam', $p->{'nickname'}, 0);
			}
		} elsif($map_team eq 'left' && map::right($p->{'team'})) {
			plus::spawn_reset($p);
			server::send('assignTeam', $p->{'nickname'}, 0);
			return;
		} elsif($map_team eq 'right' && map::left($p->{'team'})) {
			plus::spawn_reset($p);
			server::send('assignTeam', $p->{'nickname'}, 1);
			return;
		}
	},

	'spawn'	=> sub {
		my($e, $p)=@_;
		my($planere)=stash::get('planes', map::name);
		my($map_team)=stash::get('assignTeam', map::name);
		my($zones)=stash::get('zones', $p->{'team'}, 'zones', map::name);
		my($match);

		$p->{'plane'}=$e->{'plane'};
		$p->{'team'}=$e->{'team'};
		$p->{'stats'}{'turret'}=0;

		if($p->{'isBot'}) {
			$p->{'team'}=$e->{'team'};
			return;
		} elsif(plus::enter($p)) {
			$p->{'team'}=$e->{'team'};
		} else {
			server::send('assignTeam', $p->{'nickname'}, -1);
			$p->{'team'}=-1;
			player::infraction($p, 0.2);
			plus::spawn_reset($p);

			return;
		}

		unless($p->{'plane'}=~m/$planere/) {
			plus::bench($p);
			chat::whisper($p, "Allowed planes: $planere");
			return;
		}

		#Ensure players are on the correct team:
		if(map::type('mdg') && plus::prey($p)) {
			if(ref($zones) eq 'HASH' && %$zones) {
				plus::spawn_here($p, @{utils::random_value($zones)});
			}
			if($map_team eq 'left' && map::left($p->{'team'})) {
				server::send('assignTeam', $p->{'nickname'}, 1);
			} elsif($map_team eq 'right' && map::right($p->{'team'})) {
				server::send('assignTeam', $p->{'nickname'}, 0);
			}
		} elsif($map_team eq 'left' && map::right($p->{'team'})) {
			server::send('assignTeam', $p->{'nickname'}, 0);
			return;
		} elsif($map_team eq 'right' && map::left($p->{'team'})) {
			server::send('assignTeam', $p->{'nickname'}, 1);
			return;
		}

		plus::check_spawn($p);

		unless(plus::active) {
			if(map::name eq config::lobby) {
				server::send('changeMap', config::random_map);
			} else {
				records::mark($e);
			}
		}

		if(chat::snarky) {
			foreach my $snark (List::Util::shuffle(keys(%SNARKS))) {
				$match=1;
				foreach my $test (keys(%{$SNARKS{$snark}})) {
					$match&=($e->{$test}=~m/\Q$SNARKS{$snark}{$test}/);
				}
				if($match) {
					chat::snark($p, sprintf($snark, $p->{'nickname'}));
					last;
				}
			}
		}
	},

	'goal'	=> sub {
		my($e, $p)=@_;
		my($a)=player::lookup($e->{'assister'});
		my($a2)=player::lookup($e->{'secondaryAssister'});
		my($spawn_mode)=stash::get('spawnMode', map::name);

		ball::goal($e, $p);

		if($spawn_mode eq 'near') {
	 		foreach my $player (player::list) {
				plus::spawn_reset($player);
			}
		}

		if(ball::passes>4) {
			chat::laud('Nice teamwork', map::team_color($p->{'team'}));
		} elsif($a2 && !$a2->{'isBot'}) {
			chat::laud("Good pass $a->{'nickname'}, you too $a2->{'nickname'}.");
		} elsif($a && !$a->{'isBot'}) {
			chat::laud("Good pass $a->{'nickname'}.");
		}

		ball::reset;
	},

	'ballLost'		=> sub {
		my($spawn_mode)=stash::get('spawnMode', map::name);

		ball::reset;

		if($spawn_mode eq 'near') {
	 		foreach my $player (player::list) {
				plus::spawn_reset($player);
			}
		}
	},
	
	'overrideBallScore'	=> sub {
		my($e, $p)=@_;

		ball::update_score( @{$e->{'arguments'}} );
	},
	
	'logPickups'		=> sub {
		my($e, $p)=@_;

		$p->{'logPickups'}^=1;

		if($p->{'logPickups'}) {
			chat::whisper($p, 'Pickup logging enabled');
		} else {
			chat::whisper($p, 'Pickup logging disabled');
		}
	},

	'powerupUse'	=> sub {
		my($e, $p)=@_;
		my($diff)=$e->{'time'} - $p->{$e->{'powerup'}}{'time'};

		if($e->{'powerup'}=~m/Ball|Bomb|Demolition Charge/) {
			$p->{'carrier'}=0;
		}

		if($e->{'powerup'} eq 'Ball') {
			ball::shoot($e);
		} elsif(0<$diff && $diff<2000) {
			$p->{$e->{'powerup'}}{'count'}++;
		} else {
			$p->{$e->{'powerup'}}{'time'}=$e->{'time'};
			$p->{$e->{'powerup'}}{'count'}=1;
		}

		if($p->{'Homing Missile'}{'count'} > 12) {
			chat::snark($p, 'Hwacha');
		}
		if($p->{'Bomb'}{'count'} > 8) {
			chat::snark($p, "$p->{'nickname'} bombs with extreme prejudice");
		}
	},

	'powerupPickup'	=> sub {
		my($e, $p)=@_;
		my($spawn_mode)=stash::get('spawnMode', map::name);
		my($pickup)=join(',', @$e{'positionX','positionY'});

		plus::capture($e, $p) if(map::type('flag'));
		plus::checkpoint($e, $p) if(map::type('race'));

		plus::divert($e, $p);

		if(	ball::catch($e, $p)				&&
			ball::intercepted				&&
			map::goalbox($e) eq map::side($p)	&&
			map::going_in($e)
		) {
			$p->{'stats'}{'saves'}++;
			chat::snark($p, 'Nice Save', $p->{'nickname'}) if(chat::snarky);
		}

		if($e->{'powerup'}=~m/Ball|Bomb|Demolition Charge/) {
			$p->{'carrier'}=1;
		}

		return if($p->{'isBot'});

		if($e->{'powerup'} eq 'Ball') {
			$p->{'carrier'}=1;
			$p->{$e->{'powerup'}}{'time'}=0;
		} elsif($e->{'powerup'} eq 'Bomb') {
			$p->{'carrier'}=1;
			if($e->{'velocityX'} && $e->{'velocityY'} && chat::snarky) {
				chat::snark($p, 'Nice catch', $p->{'nickname'});
			}
		}

		if($p->{'logPickups'} && map::powerup($e)) {
			chat::whisper($p, $pickup,':',join(', ', map::powerup($e)));
		}

		return if(plus::key($e, $p));

		if(plus::teleport($e, $p)) {
			if($spawn_mode!~m/died|powerup|health|portal/) {
				plus::clear_spawn($p);
			}
			return;
		}

		if(stash::get($pickup, 'oneways', map::name)) {
			server::trigger('logPlanePositions', 'oneway', $e, $p);
		} elsif($spawn_mode eq 'health') {
			if(map::powerup($e, 'Health')) {
				server::trigger('logPlanePositions', 'powerup', $e, $p)
			}
		} elsif($spawn_mode eq 'powerup') {
			if(map::powerup($e)) {
				server::trigger('logPlanePositions', 'powerup', $e, $p)
			}
		}
	},

	'powerupAutoUse'	=> sub {
		$HOOKS{'powerupPickup'}->(@_);
	},

	'logPlanePositions:powerup'	=> sub {
		my($e1, $p1, $e2, $p2)=@_;
		my($x, $y)=split(m/,/,$e1->{'positionByPlayer'}{$p2->{'player'}});

		$x-=$e2->{'positionX'};
		$y-=$e2->{'positionY'};

		plus::spawn_here($p2, $e2->{'positionX'}, $e2->{'positionY'}, $x, $y);
	},

	'logPlanePositions:oneway' 	=> sub {
		my($e1, $p1, $e2, $p2)=@_;
		my($x1, $y1)=split(m/,/,$e1->{'positionByPlayer'}{$p2->{'player'}});
		my($x2, $y2)=@$e2{'positionX','positionY'};
		my($allowed)=plus::angle($x2, $y2, stash::get("$x2,$y2", 'oneways', map::name));
		my($direction)=plus::angle($x2, $y2, $x1-$x2, $y1-$y2);
		my($wrong_way)=0;

		if($allowed>80 && $direction<0) {
			$wrong_way=1 if(plus::angle($x2, $y2, $allowed+80)<$direction);
		} elsif($allowed<=-80 && $direction>0) {
			$wrong_way=1 if(plus::angle($x2, $y2, $allowed-80)>$direction);
		} elsif($direction<($allowed-80) || ($allowed+80)<$direction) {
			$wrong_way=1;
		}

		if($wrong_way) {
			plus::bench($p2);
			plus::spawn_here($p2, $x2, $y2, $allowed);
			chat::whisper($p2, 'Wrong way!');
		}
	},

	'kill'	=> sub {
		my($e, $p)=@_;
		my($v)=player::lookup($e->{'victim'});
		my($spawn_mode)=stash::get('spawnMode', map::name);
		my($angle);

		return unless($v);

		$v->{'carrier'}=0;
		ball::drop;

		return if($v->{'isBot'});

		plus::check_spawn($v);

		if($spawn_mode eq 'died') {
			if($e->{'player'}==-1 && $e->{'source'} eq 'plane') { #crash
				$e->{'victimVelocityX'}*=-1;
				$e->{'victimVelocityY'}*=-1;
			}
			plus::spawn_here($v,
				$e->{'victimPositionX'}, $e->{'victimPositionY'},
				$e->{'victimVelocityX'}, $e->{'victimVelocityY'});
		} elsif($spawn_mode eq 'near') {
			plus::spawn_near($v,
				$e->{'victimPositionX'}, $e->{'victimPositionY'});
		}

		return unless($p);
		return unless($e->{'source'}=~m/plane/);
		return if($p->{'isBot'});

		if(map::type('mdg')) {
			if(map::mode('ball')) {
				if($e->{'player'}==-1) {
					'crash';
				} elsif($p->{'team'} == $v->{'team'}) {
					'friendly fire';
				} else {
					plus::score($p);
				}
			}
		}

		if(List::Util::max(map(abs, @$e{'victimVelocityX', 'victimVelocityY'})) > 15) {
			chat::snark($v, "$v->{'nickname'} says Ouch!!");
		}

		$p->{'stats'}{'kill'}{$v->{'nickname'}}++;
		$v->{'stats'}{'died'}++;

		if($p->{'team'} == $v->{'team'}) {
			chat::snark($v, "$v->{'nickname'} was killed by friendly fire");
		} elsif($e->{'multi'}>5) {
			chat::snark($p, "$p->{'nickname'} says Booyah!!");
		} elsif($e->{'streak'}>10) {
			chat::snark($p, "$p->{'nickname'}: $e->{'streak'}");
		} elsif(($v->{'stats'}{'died'}%15)==0 && player::count>4) {
			if($p->{'stats'}{'kill'}{$v->{'nickname'}} > $v->{'stats'}{'died'}/(player::count()/4)) {
				chat::snark($v, "$p->{'nickname'} must really like killing $v->{'nickname'}");
			}
		}
	},

	'structureDestroy'	=> sub {
		my($e, $p)=@_;

		$p->{'stats'}{$e->{'target'}}++;

		if( ($p->{'stats'}{$e->{'target'}} % 35)==0 ) {
			chat::snark($p, "$p->{'nickname'} is tearing down the house");
		}
	},

	'pingSummary'	=> sub {
		my($e, $p)=@_;
		my(%pings)=%{$e->{'pingByPlayer'}};
		my($laggard);

		return unless(chat::snarky);
		return if($config::Ping<100);

		foreach my $player (List::Util::shuffle(keys(%pings))) {
			if($pings{$player}>=$config::Ping) {
				$laggard=player::lookup($player);
				chat::snark($laggard, $laggard->{'nickname'}, 'is laggy');
				last;
			}
		}
	},

	'chat'		=> sub {
		my($e, $p)=@_;
		my($to)='*';

		if($e->{'team'}) {
			if($e->{'blocked'}) {
				$to='!';
				if(length($e->{'message'})>10) {
					chat::whisper($p,
						'Message (',
						substr($e->{'message'}, 0, 8),
						'...) not delivered'
					);
				} else {
					chat::whisper($p,
						'Message (',
						$e->{'message'},
						') not delivered'
					);
				}
			} else {
				$to=map::team_symbol($p->{'team'});
			}
		}

		ui::chat_log($to, $p->{'nickname'}, $e->{'message'});

		if(config::language($e->{'message'})) {
			chat::whisper($p, 'language(', player::infraction($p, 1), ')');
		} elsif($e->{'blocked'} && config::option('bullyKick')) {
			player::infraction($p, 0.5);
		}
	},

	'serverMessage'	=> sub {
		my($e, $p)=@_;
		my($msg)=join(' ', @{$e->{'arguments'}});

		ui::chat_log('*', 'server', $msg);
	},

	'objectiveGameStart'	=> sub {
		my($e, $p)=@_;

		map::teams($e->{'leftTeam'}, $e->{'rightTeam'});
		plus::round;
	},

	'roundEnd'	=> sub {
		my($e, $p)=@_;
		my(%stats)=%{$e->{'participantStatsByName'}};
		my(%award)=%{$e->{'winnerByAward'}};
		my($pls)=$e->{'participants'};
		my($ratio)=[];
		my($cps)=[];
		my($saves)=[];
		my($keys)=[];
		my($player);

		if(config::option('awards') && player::count>2) {
			if($stats{'Crashes'}) {
				plus::most('Training Wheels Award: ', $stats{'Crashes'}, $pls);
			}
			if($stats{'Deaths'}) {
				plus::most('Kenny McCormick Award: ', $stats{'Deaths'}, $pls);
			}
			if($stats{'Ball Possession Time'}) {
				plus::most('Ball Hog Award: ', $stats{'Ball Possession Time'}, $pls);
			}
			if($stats{'Damage Dealt'}) {
				plus::most('Sledge Hammer Award: ', $stats{'Damage Dealt'}, $pls);
			}
			if($stats{'Damage Received'}) {
				plus::most('Tank Award: ', $stats{'Damage Received'}, $pls);
			}
	
			if($stats{'Kills'} && $stats{'Deaths'} && !map::type('coop')) {
				for(my $i=0; $i<@$pls; $i++) {
					$stats{'Deaths'}->[$i]=1 unless($stats{'Deaths'}->[$i]);
					$ratio->[$i]=$stats{'Kills'}->[$i]/$stats{'Deaths'}->[$i];
				}
				plus::most('Best Ratio: ', $ratio, $pls);
			}

			if(map::type('race')) {
				for(my $i=0; $i<@$pls; $i++) {
					$player=player::lookup($pls->[$i]);
					$cps->[$i]=$player->{'stats'}{'checkpoint'} if($player);
				}
				plus::most('Front Runner: ', $cps, $pls);
			}

			if(map::mode('ball')) {
				for(my $i=0; $i<@$pls; $i++) {
					$player=player::lookup($pls->[$i]);
					$saves->[$i]=$player->{'stats'}{'saves'} if($player);
				}
				plus::most('Savior Award: ', $saves, $pls);
			}

			if('key finder stats') {
				for(my $i=0; $i<@$pls; $i++) {
					$player=player::lookup($pls->[$i]);
					$keys->[$i]=$player->{'stats'}{'keys'} if($player);
				}
				plus::most('Key Master: ', $keys, $pls);
			}
		}

		records::enter($e);

		map::end;

		#This is a good time to do slow stuff:
		altbouncer::upload if(altbouncer::count > 250);
	},

	'restartMap'	=> sub {
		my($e, $p)=@_;

		server::trigger('logPlanePositions', 'restartMap', $e, $p);
	},

	'logPlanePositions:restartMap'	=> sub {
		my($e1, $p1, $e2, $p2)=@_;
		my(@alive)=();
		my($p3);

		foreach my $player (keys(%{$e1->{'positionByPlayer'}})) {
			$p3=player::lookup($player);

			next if($p3->{'isBot'});
			next if($e1->{'positionByPlayer'}{$player} eq '-1,-1');

			push(@alive, $p3);
		}

		if(@alive==1 && $p2==$alive[0]) {
			server::send('balanceTeams');
		} elsif(@alive<=2 && map::type('coop')) {
			if(grep($p2==$_, @alive)) {
				server::send('balanceTeams');
			}
		}
	},

	'restartServer'	=> sub {
		my($e, $p)=@_;

		return unless($e->{'superAdmin'});

		chat::all('Restarting server in');
		ui::display('', '', 'Restarting server in');
		chat::all("5"); ui::display('', '', '5');
		sleep(1);
		chat::all("4"); ui::display('', '', '4');
		sleep(1);
		chat::all("3"); ui::display('', '', '3');
		sleep(1);
		chat::all("2"); ui::display('', '', '2');
		sleep(1);
		chat::all("1"); ui::display('', '', '1');
		sleep(1);

		if(config::option('updateMapList')) {
			config::find_maps;
		} else {
			config::read_maps;
		}

		config::write_launcher_config;

		server::start;
		server::reopen_log;
	},

	'updatePrepareRestart'	=> sub {
		sleep(5);
		server::reopen_log;
	},

	'serverShutdown'	=> sub {
		server::shutdown;
	},

	'serverHitch'	=> sub {
		my($e)=@_;
		my($lag);

		return if($e->{'changedMap'});
		return if(($e->{'time'}-map::start)<10*$config::Clock);

		$lag=$e->{'duration'}/$config::Clock;
		if($lag > config::option('hitchThreshold')) {
			chat::all(sprintf('Server lag: %.2f seconds', $lag));
		}
	},
);

=head2 Console Interaction and Management

When using the B<alti+server> console, there are commands which are not
available under any other circumstance.  These allow the console access
to data which is otherwise easy to access from the game, or to execute
functions which should not be accessible from elsewhere.  These commands
start with a slash (/) character, just like all other commands.

The size of this list depend on the C<OPTIONS> value for C<superAdmin>.
If C<superAdmin> is set to C<console>, then all super admin functions are
also only available from the console.

=cut

%CONSOLE=(
	'server'			=> sub {
		my($action, $name, @args)=@_;
		my($value)=join(' ', @args);
		my($s)=player::server;
		my($lookup);
		my($current);

		if($action eq 'list') {
			'defer';
		} elsif($action eq 'set') {
			unless(config::option_exists($name)) {
				chat::whisper($s, 'Invalid option name', $name);
				return;
			}

			if($name=~m/Color/i && $value!~m/black|blue|cyan|green|magenta|red|white|yellow/) {
				chat::whisper($s, 'Invalid color:', $value);
				return;
			} elsif($name eq 'ulSizeLimit') {
				if($value=~m/(\d+)g/i) {
					$value=$1*(2**30);
				} elsif($value=~m/(\d+)m/i) {
					$value=$1*(2**20);
				} elsif($value=~m/(\d+)k/i) {
					$value=$1*1024;
				}
			}

			config::option_set($name, $value);

			ui::setup_screen if($name=~m/^ui|Color$/i);
		} elsif($action eq 'unset') {
			config::option_del($name);
			chat::whisper($s, $name, 'restored to default');

			ui::setup_screen if($name=~m/^ui|Color$/i);
		} elsif($action eq 'add') {
			unless(config::option_exists($name)) {
				chat::whisper($s, 'Invalid option name', $name);
				return;
			}

			$current=config::option($name);

			if($name=~m/(superA|a)dmins/ && $value!~m/^[0-9a-f-]{36}$/) {
				if($lookup=player::lookup($value)) {
					$value=$lookup->{'vaporId'};
				} elsif(($lookup)=altbouncer::lookup($value)) {
					$value=$lookup->{'vaporID'};
				} else {
					chat::whisper($s, 'Could not find vaporID');
					return;
				}
			}

			unless($current=~m/(^|;)$value(;|$)/) {
				config::option_set($name, join(';', $current, $value));
			}
		} elsif($action eq 'del') {
			$current=config::option($name);
			$current=~s/$value;|;?$value//;
			config::option_set($name, $current);
		} else {
			chat::whisper($s, 'Syntax: /server [list|set|unset] [...]');
			return;
		}

		$current=config::option($name);
		foreach my $entry (split(m/;/, $current)) {
			chat::whisper($s, "$name:", $entry);
		}
	},

	'showPlayer'		=> sub {
		my($s)=player::server;
		my($player)=player::lookup(@_);
		my(@keys)=qw(
			nickname
			player
			vaporId
			team
			level
			aceRank
			ip
			country
		);

		foreach my $key (@keys) {
			chat::whisper($s, "$key:", $player->{$key});
		}
		chat::whisper($s, 'joined:',
			scalar(localtime($server::Start + $player->{'time'}/$config::Clock)));
	},

	'showTeams'		=> sub {
		my($s)=player::server;
		my($left, $right)=(map::team_color('left'), map::team_color('right'));

		chat::whisper($s, sprintf('%-16s:', "left  ($left)"),
			join(', ', map($_->{'nickname'}, player::list('left'))));

		chat::whisper($s, sprintf('%-16s:', "right ($right)"),
			join(', ', map($_->{'nickname'}, player::list('right'))));

		chat::whisper($s, sprintf('%-16s:', 'spec'),
			join(', ', map($_->{'nickname'}, player::list('spec'))));
	},

	'showSeen'		=> sub {
		my($s)=player::server;
		my($found)=0;

		unless(config::option('altBouncer')) {
			chat::whisper($s, 'altBouncer is set to disabled, no records');
			return;
		}

		foreach my $player (altbouncer::seen) {
			chat::whisper($s, sprintf('%-20s  %36s  %s',
					$player->{'nickname'},
					$player->{'vaporID'},
					utils::date($player->{'lastPlayedWithTime'}/$config::Clock),
				));
			$found=1;
		}

		chat::whisper($s, 'seen list is empty') unless($found);
	},

	'chatLeft'		=> sub {
		chat::team('left', @_);
	},

	'chatRight'		=> sub {
		chat::team('right', @_);
	},

	'chatSpec'		=> sub {
		chat::team('spec', @_);
	},

	'shutdown'		=> sub {
		altbouncer::upload;
		server::shutdown;
		ui::shutdown;
		exit(0);
	},
);

=head2 Errors and Signals

If the B<alti+server> code recognizes a failure or if it receives a signal
to exit, it ensures the Altitude game engine is shut down first, then
exits.  Any warnings (which would be produced from using deprecated functions)
are sent to the server log (top) window of the user interface.

=cut

local(%SIG)=(
	'__WARN__'	=> sub {
		ui::slog(@_);
	},
	'__DIE__'		=> sub {
		server::shutdown;
		ui::shutdown;
		print @_, "\n";
		exit(1);
	},
	'HUP'		=> $CONSOLE{'shutdown'},
	'TERM'		=> $CONSOLE{'shutdown'},
	'INT'		=> $CONSOLE{'shutdown'},
);

=head2 Operation

The Altitude game engine will be invoked by B<alti+server> and will also be
closed by B<alti+server>.  If an error occurs with the server, B<alti+server>
will attempt to restart the server.  All managment of the Altitude game engine
should be performed from within B<alti+server> to ensure it has proper
knowledge of ports, players, log files, standard output, etc.

=cut

my($REQ, $SOUT, $TRIGGER);

ui::setup_screen;

stash::upgrade;

config::launcher;

if(config::option('updateMapList')) {
	config::find_maps;
} else {
	config::read_maps;
}

if(config::lobby) {
	stash::set('nextMap', 'admin', config::lobby);
}

config::write_launcher_config;

server::start;

while(1) {
	foreach my $fh (server::data) {
		if(server::is_log($fh)) {
			next unless($REQ=server::event);
		
			if($TRIGGER=server::triggers($REQ->{'type'})) {
				my($trigger)=shift(@$TRIGGER);
				$HOOKS{$trigger}->(&event($REQ), @$TRIGGER);
			} elsif(exists($HOOKS{$REQ->{'type'}})) {
				$HOOKS{$REQ->{'type'}}->(&event($REQ));
			} elsif(exists($HOOKS{$REQ->{'command'}})) {
				$HOOKS{$REQ->{'command'}}->(&event($REQ));
			}
		} elsif(server::is_output($fh)) {
			$SOUT=server::output;

			if($SOUT=~m/Starting server on port $config::Port/) {
				server::reopen_log;
			} elsif($SOUT=~m/BindException: Address already in use/) {
				ui::slog('Another instance is already running');

				server::interrupt;
				server::shutdown;
				ui::shutdown;
				exit(1);
			} elsif($SOUT=~m/Error processing packet .*, playerId=(\d+)/) {
				player::infraction(player::lookup($1), 1);
			} elsif($SOUT=~m/$FATAL_SERVER_ERRORS/) {
				server::interrupt;
				server::shutdown;

				if($SOUT=~m/config size \((\d+) bytes\) exceeds max/) {
					config::resize($1);

					if(config::option('updateMapList')) {
						config::find_maps;
					} else {
						ui::shutdown;
						print "Config size too big, remove maps from mapList\n";
						exit(1);
					}
				}

				server::start;
				server::reopen_log;
			} elsif($SOUT=~m/Data Transfer Since Launch/) {
				ui::slog('INFO  : alti+server uptime:',
					server::uptime);

				ui::slog('INFO  : CPU Totals (user system):',
					server::cpu_hrs);

				if(player::none) {
					if(
						map::idle > config::option('timeIdleChange') ||
						map::cpu  > config::option('cpuUsedChange')
					) {
						server::send('changeMap',
							config::lobby || config::random_map);
						map::end;
						altbouncer::upload;
					}

					if(altbouncer::count > 100) {
						altbouncer::upload;
					}
				}
			}

			ui::slog($SOUT);
		} elsif($fh==0xDEAD) {
			ui::slog('!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!');
			ui::slog('!!   Server is hung, restarting   !!');
			ui::slog('!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!');

			server::interrupt;

			sleep(2);

			server::start;
			server::reopen_log;
		} else {
			input::stdin;
		}
	}
}

END {
	server::shutdown;
	ui::shutdown;
	exit(0);
}

=head1 NOTES

The B<alti+server> program is an interactive server manager, which is not
convenient for running on a headless system or (for example) VPS.  It is
recommended that B<alti+server> be run in a detachable terminal emulator
to allow it to continue to function during a disconnect.  The author prefers
screen, but tmux and dtach would both work just as well.  It is a good idea
to name the detatched session if you run multiple already, so it is easy to
re-attach to.

=head1 AUTHOR

biell @ pobox . com 

=head1 PUBLIC DOMAIN NOTICE

This is free and unencumbered software released into the public domain.

Anyone is free to copy, modify, publish, use, compile, sell, or
distribute this software, either in source code form or as a compiled
binary, for any purpose, commercial or non-commercial, and by any
means.

In jurisdictions that recognize copyright laws, the author or authors
of this software dedicate any and all copyright interest in the
software to the public domain. We make this dedication for the benefit
of the public at large and to the detriment of our heirs and
successors. We intend this dedication to be an overt act of
relinquishment in perpetuity of all present and future rights to this
software under copyright law.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.

For more information, please refer to <http://unlicense.org/>

=cut

